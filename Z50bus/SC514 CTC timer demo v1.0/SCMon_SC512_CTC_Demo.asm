; **********************************************************************
; **  Z80 CTC Demo  v1.0                        by Stephen C Cousins  **
; **********************************************************************

; Program written for the Small Computer Monitor (SCM) running on a 
; system with a SC514 (Z80 CTC card for Z50Bus) set to address 0x60

; This code demonstrates how to generate a periodic mode 2 interrupt 
; using a Z80 CTC.

; CTC channel 0 is set to divide the onboard oscillator's frequency
; by 256. The onboard oscillator is assumed to be 1.8432 MHz (CLKX)
; giving a 7200 Hz output from channel 0. ie. 1843200 / 256 = 7200.

; CTC channel 1 is set to generate an interrupt every 10 ms (100 Hz).
; Channel 1's input is connected to channel 0's output, thus its input 
; is 7200 Hz. By dividing by 72 the output of channel 1 is 100 Hz.

; CTC channel 2 counts the output pulses from channel 1, thus it counts
; the number of 10 ms events. Note, the counter counts down, not up.
; Channel 2's input is connected to channel 1's output. 
; This is totally optional to the interrupts generated by channel 1.

; Channel 1 generates a 10 ms (100 Hz) period interrupt. 

; The interrupt routine increments a centi-second (0.01 second) counter 
; in RAM. This simple counter can be polled in software to keep track
; of any timing requirements it may have. In this example the program
; outputs an asterisk once per second.

; The interrupt routine also increments a centi-second timer, in RAM,
; from 0 to 100. When it reaches 100 the interrupt routine resets it to 
; zero and increments the seconds timer, in RAM.

; The interrupt vector table starts at 0x8200 and are used as follows:
;   0x8200-8201  Interrupt vector for CTC channel 0
;   0x8202-8203  Interrupt vector for CTC channel 1
;   0x8204-8205  Interrupt vector for CTC channel 2
;   0x8206-8207  Interrupt vector for CTC channel 3


            .PROC Z80           ;SCWorkshop select processor

; The base I/O address for the CTC is set with jumpers
ctc:        .EQU 0x60           ;Base I/O address for CTC


; **********************************************************************
; Memory usage constants

codestart:  .EQU 0x8000         ;Program code starts here

counter:    .EQU 0x8100         ;Counter in RAM counts centi-seconds
timerCS:    .EQU 0x8101         ;Timer in RAM counts centi-seconds
timerS:     .EQU 0x8102         ;Timer in RAM counts seconds

vectors:    .EQU 0x8200         ;Interrupt vector table in RAM


; **********************************************************************
; Initialisation constants
;
; CTC channel control register
;   Bit 7:   Interrupt     1 = Enable   0 = Disable
;   Bit 6:   Mode          1 = Counter  0 = Timer
;   Bit 5:   Prescaler     1 = 256      0 = 16        (timer mode only)
;   Bit 4:   Edge select   1 = Rising   0 = Falling
;   Bit 3:   Time trigger  1 = CLK/TRG  0 = Auto when time const loaded
;   Bit 2:   Time constant 1 = Follows  0 = Continue operation
;   Bit 1:   Reset         1 = Reset    0 = Continue operation
;   Bit 0:   Control/vect  1 = Control  0 = Vector
; Notes:
;   Timer mode uses the system clock (CLK) as the clock source
;   Counter mode uses the channel's input pin (CTx) as the clock source
;   Typically, in counter mode input will be the onboard oscillator clock (CLKX)
;   Use of CLKX is preferred as it is independent of the system clock frequency 
;     although counter mode does not have the benefit of the prescaler 
;
; Channel 0 is used to divide its input clock (CLKX) down to 7200 Hz
; Fit a jumper shunt for CTC 0 input = CLKX
; CLKX is the on-board oscillator, assumed to be 1.8432 MHz
; Channel 0 is set for:
;    interrupts off
;    mode = counter
;    prescaler = n/a
;    edge = rising (not critical so can just as well be set for falling)
;    reload count = 0 (=256, zero is interpreted as 256)
;    CTC 0 input = 1843200 Hz
; The countdown timer is reloaded with 0 (=256) every time is reaches zero
;    CTC 0 output = 1843200 / 256 = 7200 Hz
channelA:   .EQU 0              ;CTC channel number (0 to 3)
portA:      .EQU ctc+channelA   ;CTC I/O port address for this channel
controlA:   .EQU 0b01010101     ;CTC channel control register value
countA:     .EQU 0              ;CTC channel timer reload value
vectorA:    .EQU 2 * channelA   ;Offset in interrupt vector table
;
; Channel 1 is used to divide its input clock (CTC 0 output) down to 100 Hz
; Fit a jumper shunt for CTC 1 input = CTC 0 output
; Channel 1 is set for:
;    interrupts on
;    mode = counter
;    prescaler = n/a
;    edge = rising (not critical so can just as well be set for falling)
;    reload count = 72
;    CTC 1 input = 7200 Hz
; The countdown timer is reloaded with 72 every time is reaches zero
;    CTC 1 output = 7200 / 72 = 100 Hz (10 milliseconds)
channelB:   .EQU 1              ;CTC channel number (0 to 3)
portB:      .EQU ctc+channelB   ;CTC I/O port address for this channel
controlB:   .EQU 0b11010101     ;CTC channel control register value
countB:     .EQU 72             ;CTC channel timer reload value
vectorB:    .EQU 2 * channelB   ;Offset in interrupt vector table
;
; Channel 2 is used to count down in 10 milli-second ticks
; This is not required to generating 100 Hz interrupts
; Fit a jumper shunt to connect CTC 2 input to CTC 1 output
; Channel 2 is set for:
;    interrupts off
;    mode = counter
;    prescaler = n/a
;    edge = rising (not critical so can just as well be set for falling)
;    reload count = 0 (=256, zero is interpreted as 256)
channelC:   .EQU 2              ;CTC channel number (0 to 3)
portC:      .EQU ctc+channelC   ;CTC I/O port address for this channel
controlC:   .EQU 0b01010101     ;CTC channel control register value
countC:     .EQU 0              ;CTC channel counter reload value
vectorC:    .EQU 2 * channelC   ;Offset in interrupt vector table


; **********************************************************************
; Program code

            .ORG codestart      ;Program code starts here

            DI                  ;Disable interrupts during initialisation

; Clear interrupt counter
            XOR  A              ;Clear register A to zero
            LD   (counter),A    ;Clear interrupt counter
            LD   (timerCS),A    ;Clear centi-second timer
            LD   (timerS),A     ;Clear seconds timer

; Initialise interrupt vector table entry for CTC channel B
            LD   HL,CTC_Int     ;Iinterrupt routine address
            LD   (vectors+vectorB),HL   ;Interrupt vector for CTC channel B

; Initialise Z80 for interrupt mode 2
            LD   A,vectors\256  ;Get hi byte of int vector table address
            LD   I,A            ;Set Z80's int vector table address (hi)
            IM   2              ;Set interrupt mode 2

; Initialise CTC interrupt vector
            LD   A,0b00000000   ;Set int vector for the CTC to 0b0000000x
            OUT  (ctc),A

; Initialise CTC channel A
            LD   A,controlA     ;Control register value
            OUT  (portA),A
            LD   A,countA       ;Reload counter/ timer value
            OUT  (portA),A

; Initialise CTC channel B
            LD   A,controlB     ;Control register value
            OUT  (portB),A
            LD   A,countB       ;Reload counter/ timer value
            OUT  (portB),A

; Initialise CTC channel C
            LD   A,controlC     ;Control register value
            OUT  (portC),A
            LD   A,countC       ;Reload counter/ timer value
            OUT  (portC),A

; Enable interrupts and return to SCM command line interpreter
            EI                  ;Enable interrupts

; Return here or comment out to show polling of the interrupt counter
;           RET                 ;Return to Small Computer Monitor

; Example code showing polling of the interrupt counter
; Test code to output '*' every time "counter" reaches 1 second
; RAM location "counter" is increments every 10 ms by the interrupt rountine
@Wait:      EI
            NOP                 ;Do whatever here
; Disable interrupts while handling 'counter'
            DI
            LD   A,(counter)    ;Wait for counter value = 100
            CP   100            ;  which is 100 x 10 ms = 1s
            JR   NZ,@Wait
            XOR  A              ;Reset counter to zero
            LD   (counter),A
; Enable interrupts as we've finished with 'counter'
            EI
            LD   A,'*'          ;Output '*' to terminal
            LD   C,2            ;  using SCM's API function 2
            RST  0x30           ;  RST 30 is call to SCM's API
            JR   @Wait


; CTC interrupt routine
; This routine increments "counter" every time it runs (every 10 ms)
; It also incrments a centi-second timer and a seconds timer
CTC_Int:    PUSH AF             ;Preserve AF
; Increment simple centi-second counter value in RAM
            LD   A,(counter)    ;Read current interrupt counter
            INC  A              ;Increment interrupt counter
            LD   (counter),A    ;Store updated interrupt counter
; Increment centi-second timer
            LD   A,(timerCS)    ;Read current centi-second timer
            INC  A              ;Increment centi-second timer
            LD   (timerCS),A    ;Store updated centi-second timer
            CP   100            ;Have we reached 1 second?
            JR   NZ,@Exit       ;No, so exit
; We have reached a 1 second event
            XOR  A              ;Prepare to clear centi-second timer
            LD   (timerCS),A    ;Store updated centi-second timer
            LD   A,(timerS)     ;Read current seconds timer
            INC  A              ;Increment seconds timer
            LD   (timerS),A     ;Store updated seconds timer
@Exit:      POP  AF             ;Restore AF
            EI                  ;Enable interrupts
            RETI                ;Return from interrupt




