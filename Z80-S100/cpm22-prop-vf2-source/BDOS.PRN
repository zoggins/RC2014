'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1


                                	title	'Bdos Interface, Bdos, Version 2.2 Feb, 1980'
                                
                                	.Z80
  0000'                         	aseg
                                	org	100h
                         C      	maclib	MEMCFG.LIB	; define configuration parameters
  0040                   C      msize	equ	64		; adjust per installed system memory
                         C      
                         C      ; configuration parameters for BIOS
                         C      ;bioslen	equ	0c00h		; adjust as bios changes are made (if necessary)
  0003                   C      bioslen		equ	3
  0000                   C      nhdisks	equ	0		; total number of hard disks (set to 0
                         C      				;   if no hard disks desired)
  0001                   C      needZ80	equ	1		; 0 = 8080 is ok, 1 = Z80 is needed
  0001                   C      patchOS	equ	1		; 0 = do not patch CCP and BODS
                         C      					; 1 = patch orignal CCP and original BDOS
                         C      
                         C      ; common definitions and derived values - no change should be necessary below
  0800                   C      ccplen	equ	0800h		; cp/m constant
  0E00                   C      bdoslen	equ	0e00h		; cp/m constant
                         C      
                         C      ; cp/m image size (rounded up to next 1k boundary)
                         C      ;cpmlen	equ	(ccplen + bdoslen + bioslen + 03ffh) / 0400h
                         C      
  003D                   C      msiz	equ	msize-bioslen				;SUBTRACT BIOS SIZE
  A400                   C      bias	equ (msiz-20)*1024				;THE DRI BIAS FACTOR
                         C      
                         C      ;ccpph	equ	(msize - cpmlen) * 1024		; old ccp start address
  D800                   C      ccpph	equ	3400H+bias					; udpated ccp start address
  E000                   C      bdosph	equ	ccpph + ccplen				; bdos start address
  EE00                   C      biosph	equ	ccpph + ccplen + bdoslen	; bios start address
                         C      
                                	.phase	bdosph
  EE00                          bios	equ	biosph
                                
                                ;*****************************************************************
                                ;*****************************************************************
                                ;**                                                             **
                                ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                                ;**            I n t e r f a c e   M o d u l e                  **
                                ;**                                                             **
                                ;*****************************************************************
                                ;*****************************************************************
                                
                                ;	Copyright (c) 1978, 1979, 1980
                                ;	Digital Research
                                ;	Box 579, Pacific Grove
                                ;	California
                                
                                
                                ;      20 january 1980
                                
  0018                          ssize	equ	24		;24 level stack
                                
                                ;	low memory locations
  0000                          reboot	equ	0000h		;reboot system
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-1


  0003                          ioloc	equ	0003h		;i/o byte location
  0006                          bdosa	equ	0006h		;address field of jp BDOS
                                
                                ;	bios access constants
  EE00                          bootf	defl	bios+3*0	;cold boot function
  EE03                          wbootf	defl	bios+3*1	;warm boot function
  EE06                          constf	defl	bios+3*2	;console status function
  EE09                          coninf	defl	bios+3*3	;console input function
  EE0C                          conoutf	defl	bios+3*4	;console output function
  EE0F                          listf	defl	bios+3*5	;list output function
  EE12                          punchf	defl	bios+3*6	;punch output function
  EE15                          readerf	defl	bios+3*7	;reader input function
  EE18                          homef	defl	bios+3*8	;disk home function
  EE1B                          seldskf	defl	bios+3*9	;select disk function
  EE1E                          settrkf	defl	bios+3*10	;set track function
  EE21                          setsecf	defl	bios+3*11	;set sector function
  EE24                          setdmaf	defl	bios+3*12	;set dma function
  EE27                          readf	defl	bios+3*13	;read disk function
  EE2A                          writef	defl	bios+3*14	;write disk function
  EE2D                          liststf	defl	bios+3*15	;list status function
  EE30                          sectran	defl	bios+3*16	;sector translate
                                
                                ;	equates for non graphic characters
  0003                          ctlc	equ	03h		;control c
  0005                          ctle	equ	05h		;physical eol
  0008                          ctlh	equ	08h		;backspace
  0010                          ctlp	equ	10h		;prnt toggle
  0012                          ctlr	equ	12h		;repeat line
  0013                          ctls	equ	13h		;stop/start screen
  0015                          ctlu	equ	15h		;line delete
  0018                          ctlx	equ	18h		;=ctl-u
  001A                          ctlz	equ	1ah		;end of file
  007F                          rubout	equ	7fh		;char delete
  0009                          tab	equ	09h		;tab char
  000D                          cr	equ	0dh		;carriage return
  000A                          lf	equ	0ah		;line feed
  005E                          ctl	equ	5eh		;up arrow
                                
  E000    00 00 00 00           	db	0,0,0,0,0,0
  E004    00 00                 
                                
                                ;	enter here from the user's program with function number in c,
                                ;	and information address in d,e
  E006    C3 E011               	jp	bdose		;past parameter block
                                
                                ;	************************************************
                                ;	*** relative locations 0009 - 000e           ***
                                ;	************************************************
  E009    E099                  pererr:	dw	persub		;permanent error subroutine
  E00B    E0A5                  selerr:	dw	selsub		;select error subroutine
  E00D    E0AB                  roderr:	dw	rodsub		;ro disk error subroutine
  E00F    E0B1                  roferr:	dw	rofsub		;ro file error subroutine
                                
                                
  E011    EB                    bdose:	ex	de,hl		;arrive here from user programs
  E012    22 E343               	ld	(info),hl
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-2


  E015    EB                    	ex	de,hl		;info=DE, DE=info
  E016    7B                    	ld	a,e
  E017    32 EDD6               	ld	(linfo),a	;linfo = low(info) - don't equ
  E01A    21 0000               	ld	hl,0
  E01D    22 E345               	ld	(aret),hl	;return value defaults to 0000
                                				;save user's stack pointer, set to local stack
  E020    39                    	add	hl,sp
  E021    22 E30F               	ld	(entsp),hl	;entsp = stackptr
  E024    31 E341               	ld	sp,lstack	;local stack setup
  E027    AF                    	xor	a
  E028    32 EDE0               	ld	(fcbdsk),a
  E02B    32 EDDE               	ld	(resel),a	;fcbdsk,resel=false
  E02E    21 ED74               	ld	hl,goback	;return here after all functions
  E031    E5                    	push	hl		;jmp goback equivalent to ret
  E032    79                    	ld	a,c
  E033    FE 29                 	cp	nfuncs
  E035    D0                    	ret	nc		;skip if invalid #
  E036    4B                    	ld	c,e		;possible output character to C
  E037    21 E047               	ld	hl,functab
  E03A    5F                    	ld	e,a
  E03B    16 00                 	ld	d,0		;DE=func, HL=.ciotab
  E03D    19                    	add	hl,de
  E03E    19                    	add	hl,de
  E03F    5E                    	ld	e,(hl)
  E040    23                    	inc	hl
  E041    56                    	ld	d,(hl)		;DE=functab(func)
  E042    2A E343               	ld	hl,(info)	;info in DE for later xchg
  E045    EB                    	ex	de,hl
  E046    E9                    	jp	(hl)		;dispatched
                                
                                ;	dispatch table for functions
  E047                          functab:
  E047    EE03 E2C8             	dw	wbootf, func1, func2, func3
  E04B    E190 E2CE             
  E04F    EE12 EE0F             	dw	punchf, listf, func6, func7
  E053    E2D4 E2ED             
  E057    E2F3 E2F8             	dw	func8, func9, func10,func11
  E05B    E1E1 E2FE             
  000C                          diskf	equ	($-functab)/2	;disk funcs
  E05F    EC7E EC83             	dw	func12,func13,func14,func15
  E063    EC45 EC9C             
  E067    ECA5 ECAB             	dw	func16,func17,func18,func19
  E06B    ECC8 ECD7             
  E06F    ECE0 ECE6             	dw	func20,func21,func22,func23
  E073    ECEC ECF5             
  E077    ECFE ED04             	dw	func24,func25,func26,func27
  E07B    ED0A ED11             
  E07F    E52C ED17             	dw	func28,func29,func30,func31
  E083    ED1D ED26             
  E087    ED2D ED41             	dw	func32,func33,func34,func35
  E08B    ED47 ED4D             
  E08F    EC0E ED53             	dw	func36,func37,func38,func39
  E093    E304 E304             
  E097    ED9B                  	dw	func40
  0029                          nfuncs	equ	($-functab)/2
                                
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-3


                                
                                ;	error subroutines
  E099    21 E0CA               persub:	ld	hl,permsg	;report permanent error
  E09C    CD E0E5               	call	errflg		;to report the error
  E09F    FE 03                 	cp	ctlc
  E0A1    CA 0000               	jp	z,reboot	;reboot if response is ctlc
  E0A4    C9                    	ret			;and ignore the error
                                
  E0A5    21 E0D5               selsub:	ld	hl,selmsg	;report select error
  E0A8    C3 E0B4               	jp	wait$err	;wait console before boot
                                
  E0AB    21 E0E1               rodsub:	ld	hl,rodmsg	;report write to read/only disk
  E0AE    C3 E0B4               	jp	wait$err	;wait console
                                
  E0B1                          rofsub:				;report read/only file
  E0B1    21 E0DC               	ld	hl,rofmsg	;drop through to wait for console
                                
  E0B4                          wait$err:			;wait for response before boot
  E0B4    CD E0E5               	call	errflg
  E0B7    C3 0000               	jp	reboot
                                
                                ;	error messages
  E0BA    42 64 6F 73           dskmsg:	db	'Bdos Err On '
  E0BE    20 45 72 72           
  E0C2    20 4F 6E 20           
  E0C6    20 3A 20 24           dskerr:	db	' : $'		;filled in by errflg
  E0CA    42 61 64 20           permsg:	db	'Bad Sector$'
  E0CE    53 65 63 74           
  E0D2    6F 72 24              
  E0D5    53 65 6C 65           selmsg:	db	'Select$'
  E0D9    63 74 24              
  E0DC    46 69 6C 65           rofmsg:	db	'File '
  E0E0    20                    
  E0E1    52 2F 4F 24           rodmsg:	db	'R/O$'
                                
                                
  E0E5    E5                    errflg:	push	hl		;report error to console, message address in HL
  E0E6    CD E1C9               	call	crlf		;stack mssg address, new line
  E0E9    3A E342               	ld	a,(curdsk)
  E0EC    C6 41                 	add	a,'A'
  E0EE    32 E0C6               	ld	(dskerr),a	;current disk name
  E0F1    01 E0BA               	ld	bc,dskmsg
  E0F4    CD E1D3               	call	print		;the error message
  E0F7    C1                    	pop	bc
  E0F8    CD E1D3               	call	print		;error mssage tail
                                ;	jp	conin		;to get the input character
                                				;(drop through to conin)
                                ;	ret
                                
                                
                                ;	console handlers
  E0FB    21 E30E               conin:	ld	hl,kbchar	;read console character to A
  E0FE    7E                    	ld	a,(hl)
  E0FF    36 00                 	ld	(hl),0
  E101    B7                    	or	a
  E102    C0                    	ret	nz
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-4


                                				;no previous keyboard character ready
  E103    C3 EE09               	jp	coninf		;get character externally
                                ;	ret
  E106    CD E0FB               conech:	call	conin		;read character with echo
  E109    CD E114               	call	echoc
  E10C    D8                    	ret	c		;echo character?
                                				;character must be echoed before return
  E10D    F5                    	push	af
  E10E    4F                    	ld	c,a
  E10F    CD E190               	call	tabout
  E112    F1                    	pop	af
  E113    C9                    	ret			;with character in A
                                
  E114                          echoc:				;echo character if graphic
  E114    FE 0D                 	cp	cr		;cr, lf, tab, or backspace
  E116    C8                    	ret	z		;carriage return?
  E117    FE 0A                 	cp	lf
  E119    C8                    	ret	z		;line feed?
  E11A    FE 09                 	cp	tab
  E11C    C8                    	ret	z		;tab?
  E11D    FE 08                 	cp	ctlh
  E11F    C8                    	ret	z		;backspace?
  E120    FE 20                 	cp	' '
  E122    C9                    	ret			;carry set if not graphic
                                
  E123                          conbrk:				;check for character ready
  E123    3A E30E               	ld	a,(kbchar)
  E126    B7                    	or	a
  E127    C2 E145               	jp	nz,conb1	;skip if active kbchar
                                				;no active kbchar, check external break
  E12A    CD EE06               	call	constf
  E12D    E6 01                 	and	1
  E12F    C8                    	ret	z		;return if no char ready
                                				;character ready, read it
  E130    CD EE09               	call	coninf		;to A
  E133    FE 13                 	cp	ctls
  E135    C2 E142               	jp	nz,conb0	;check stop screen function
                                				;found ctls, read next character
  E138    CD EE09               	call	coninf		;to A
  E13B    FE 03                 	cp	ctlc
  E13D    CA 0000               	jp	z,reboot	;ctlc implies re-boot
                                				;not a reboot, act as if nothing has happened
  E140    AF                    	xor	a
  E141    C9                    	ret			;with zero in accumulator
  E142                          conb0:
                                				;character in accum, save it
  E142    32 E30E               	ld	(kbchar),a
  E145                          conb1:
                                				;return with true set in accumulator
  E145    3E 01                 	ld	a,1
  E147    C9                    	ret
                                
  E148                          conout:				;compute character position/write console char from C
                                				;compcol = true if computing column position
  E148    3A E30A               	ld	a,(compcol)
  E14B    B7                    	or	a
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-5


  E14C    C2 E162               	jp	nz,compout
                                				;write the character, then compute the column
                                				;write console character from C
  E14F    C5                    	push	bc
  E150    CD E123               	call	conbrk		;check for screen stop function
  E153    C1                    	pop	bc
  E154    C5                    	push	bc		;recall/save character
  E155    CD EE0C               	call	conoutf		;externally, to console
  E158    C1                    	pop	bc
  E159    C5                    	push	bc		;recall/save character
                                				;may be copying to the list device
  E15A    3A E30D               	ld	a,(listcp)
  E15D    B7                    	or	a
  E15E    C4 EE0F               	call	nz,listf	;to printer, if so
  E161    C1                    	pop	bc		;recall the character
  E162                          compout:
  E162    79                    	ld	a,c		;recall the character
                                				;and compute column position
  E163    21 E30C               	ld	hl,column	;A = char, HL = .column
  E166    FE 7F                 	cp	rubout
  E168    C8                    	ret	z		;no column change if nulls
  E169    34                    	inc	(hl)		;column = column + 1
  E16A    FE 20                 	cp	' '
  E16C    D0                    	ret	nc		;return if graphic
                                				;not graphic, reset column position
  E16D    35                    	dec	(hl)		;column = column - 1
  E16E    7E                    	ld	a,(hl)
  E16F    B7                    	or	a
  E170    C8                    	ret	z		;return if at zero
                                				;not at zero, may be backspace or end line
  E171    79                    	ld	a,c		;character back to A
  E172    FE 08                 	cp	ctlh
  E174    C2 E179               	jp	nz,notbacksp
                                				;backspace character
  E177    35                    	dec	(hl)		;column = column - 1
  E178    C9                    	ret
                                
  E179                          notbacksp:			;not a backspace character, eol?
  E179    FE 0A                 	cp	lf
  E17B    C0                    	ret	nz		;return if not
                                				;end of line, column = 0
  E17C    36 00                 	ld	(hl),0		;column = 0
  E17E    C9                    	ret
                                
  E17F                          ctlout:				;send C character with possible preceding up-arrow
  E17F    79                    	ld	a,c
  E180    CD E114               	call	echoc		;cy if not graphic (or special case)
  E183    D2 E190               	jp	nc,tabout	;skip if graphic, tab, cr, lf, or ctlh
                                				;send preceding up arrow
  E186    F5                    	push	af
  E187    0E 5E                 	ld	c,ctl
  E189    CD E148               	call	conout		;up arrow
  E18C    F1                    	pop	af
  E18D    F6 40                 	or	40h		;becomes graphic letter
  E18F    4F                    	ld	c,a		;ready to print
                                				;(drop through to tabout)
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-6


                                
  E190                          tabout:				;expand tabs to console
  E190    79                    	ld	a,c
  E191    FE 09                 	cp	tab
  E193    C2 E148               	jp	nz,conout	;direct to conout if not
                                				;tab encountered, move to next tab position
  E196    0E 20                 tab0:	ld	c,' '
  E198    CD E148               	call	conout		;another blank
  E19B    3A E30C               	ld	a,(column)
  E19E    E6 07                 	and	111b		;column mod 8 = 0 ?
  E1A0    C2 E196               	jp	nz,tab0		;back for another if not
  E1A3    C9                    	ret
                                
  E1A4                          backup:				;back-up one screen position
  E1A4    CD E1AC               	call	pctlh
  E1A7    0E 20                 	ld	c,' '
  E1A9    CD EE0C               	call	conoutf
                                ;	(drop through to pctlh)
  E1AC                          pctlh:				;send ctlh to console without affecting column count
  E1AC    0E 08                 	ld	c,ctlh
  E1AE    C3 EE0C               	jp	conoutf
                                ;	ret
  E1B1                          crlfp:				;print #, cr, lf for ctlx, ctlu, ctlr functions
                                				;then move to strtcol (starting column)
  E1B1    0E 23                 	ld	c,'#'
  E1B3    CD E148               	call	conout
  E1B6    CD E1C9               	call	crlf		;column = 0, move to position strtcol
  E1B9    3A E30C               crlfp0:	ld	a,(column)
  E1BC    21 E30B               	ld	hl,strtcol
  E1BF    BE                    	cp	(hl)
  E1C0    D0                    	ret	nc		;stop when column reaches strtcol
  E1C1    0E 20                 	ld	c,' '
  E1C3    CD E148               	call	conout		;print blank
  E1C6    C3 E1B9               	jp	crlfp0
                                
  E1C9    0E 0D                 crlf:	ld	c,cr		;carriage return line feed sequence
  E1CB    CD E148               	call	conout
  E1CE    0E 0A                 	ld	c,lf
  E1D0    C3 E148               	jp	conout
                                ;	ret
  E1D3    0A                    print:	ld	a,(bc)		;print message until M(BC) = '$'
  E1D4    FE 24                 	cp	'$'
  E1D6    C8                    	ret	z		;stop on $
                                				;more to print
  E1D7    03                    	inc	bc
  E1D8    C5                    	push	bc
  E1D9    4F                    	ld	c,a		;char to C
  E1DA    CD E190               	call	tabout		;another character printed
  E1DD    C1                    	pop	bc
  E1DE    C3 E1D3               	jp	print
                                
  E1E1                          read:				;read to info address (max length, current length, buffer)
  E1E1    3A E30C               	ld	a,(column)
  E1E4    32 E30B               	ld	(strtcol),a	;save start for ctl-x, ctl-h
  E1E7    2A E343               	ld	hl,(info)
  E1EA    4E                    	ld	c,(hl)
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-7


  E1EB    23                    	inc	hl
  E1EC    E5                    	push	hl
  E1ED    06 00                 	ld	b,0
                                				;B = current buffer length,
                                				;C = maximum buffer length,
                                				;HL= next to fill - 1
  E1EF                          readnx:				;read next character, BC, HL active
  E1EF    C5                    	push	bc
  E1F0    E5                    	push	hl		;blen, cmax, HL saved
  E1F1    CD E0FB               readn0:	call	conin		;next char in A
  E1F4    E6 7F                 	and	7fh		;mask parity bit
  E1F6    E1                    	pop	hl
  E1F7    C1                    	pop	bc		;reactivate counters
  E1F8    FE 0D                 	cp	cr
  E1FA    CA E2C1               	jp	z,readen	;end of line?
  E1FD    FE 0A                 	cp	lf
  E1FF    CA E2C1               	jp	z,readen	;also end of line
  E202    FE 08                 	cp	ctlh
  E204    C2 E216               	jp	nz,noth		;backspace?
                                				;do we have any characters to back over?
  E207    78                    	ld	a,b
  E208    B7                    	or	a
  E209    CA E1EF               	jp	z,readnx
                                				;characters remain in buffer, backup one
  E20C    05                    	dec	b		;remove one character
  E20D    3A E30C               	ld	a,(column)
  E210    32 E30A               	ld	(compcol),a	;col > 0
                                				;compcol > 0 marks repeat as length compute
  E213    C3 E270               	jp	linelen		;uses same code as repeat
                                
  E216                          noth:				;not a backspace
  E216    FE 7F                 	cp	rubout
  E218    C2 E226               	jp	nz,notrub	;rubout char?
                                				;rubout encountered, rubout if possible
  E21B    78                    	ld	a,b
  E21C    B7                    	or	a
  E21D    CA E1EF               	jp	z,readnx	;skip if len=0
                                				;buffer has characters, resend last char
  E220    7E                    	ld	a,(hl)
  E221    05                    	dec	b
  E222    2B                    	dec	hl		;A = last char
                                				;blen=blen-1, next to fill - 1 decremented
  E223    C3 E2A9               	jp	rdech1		;act like this is an echo
                                
  E226                          notrub:				;not a rubout character, check end line
  E226    FE 05                 	cp	ctle
  E228    C2 E237               	jp	nz,note		;physical end line?
                                				;yes, save active counters and force eol
  E22B    C5                    	push	bc
  E22C    E5                    	push	hl
  E22D    CD E1C9               	call	crlf
  E230    AF                    	xor	a
  E231    32 E30B               	ld	(strtcol),a	;start position = 00
  E234    C3 E1F1               	jp	readn0		;for another character
                                
  E237                          note:				;not end of line, list toggle?
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-8


  E237    FE 10                 	cp	ctlp
  E239    C2 E248               	jp	nz,notp		;skip if not ctlp
                                				;list toggle - change parity
  E23C    E5                    	push	hl		;save next to fill - 1
  E23D    21 E30D               	ld	hl,listcp	;HL=.listcp flag
  E240    3E 01                 	ld	a,1
  E242    96                    	sub	(hl)		;True-listcp
  E243    77                    	ld	(hl),a		;listcp = not listcp
  E244    E1                    	pop	hl
  E245    C3 E1EF               	jp	readnx		;for another char
                                
  E248                          notp:				;not a ctlp, line delete?
  E248    FE 18                 	cp	ctlx
  E24A    C2 E25F               	jp	nz,notx
  E24D    E1                    	pop	hl		;discard start position
                                				;loop while column > strtcol
  E24E    3A E30B               backx:	ld	a,(strtcol)
  E251    21 E30C               	ld	hl,column
  E254    BE                    	cp	(hl)
  E255    D2 E1E1               	jp	nc,read		;start again
  E258    35                    	dec	(hl)		;column = column - 1
  E259    CD E1A4               	call	backup		;one position
  E25C    C3 E24E               	jp	backx
                                
  E25F                          notx:				;not a control x, control u?
                                				;not control-X, control-U?
  E25F    FE 15                 	cp	ctlu
  E261    C2 E26B               	jp	nz,notu		;skip if not
                                				;delete line (ctlu)
  E264    CD E1B1               	call	crlfp		;physical eol
  E267    E1                    	pop	hl		;discard starting position
  E268    C3 E1E1               	jp	read		;to start all over
                                
  E26B                          notu:				;not line delete, repeat line?
  E26B    FE 12                 	cp	ctlr
  E26D    C2 E2A6               	jp	nz,notr
  E270                          linelen:			;repeat line, or compute line len (ctlh)
                                				;if compcol > 0
  E270    C5                    	push	bc
  E271    CD E1B1               	call	crlfp		;save line length
  E274    C1                    	pop	bc
  E275    E1                    	pop	hl
  E276    E5                    	push	hl
  E277    C5                    	push	bc
                                				;bcur, cmax active, beginning buff at HL
  E278    78                    rep0:	ld	a,b
  E279    B7                    	or	a
  E27A    CA E28A               	jp	z,rep1		;count len to 00
  E27D    23                    	inc	hl
  E27E    4E                    	ld	c,(hl)		;next to print
  E27F    05                    	dec	b
  E280    C5                    	push	bc
  E281    E5                    	push	hl		;count length down
  E282    CD E17F               	call	ctlout		;character echoed
  E285    E1                    	pop	hl
  E286    C1                    	pop	bc		;recall remaining count
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-9


  E287    C3 E278               	jp	rep0		;for the next character
                                
  E28A                          rep1:				;end of repeat, recall lengths
                                				;original BC still remains pushed
  E28A    E5                    	push	hl		;save next to fill
  E28B    3A E30A               	ld	a,(compcol)
  E28E    B7                    	or	a		;>0 if computing length
  E28F    CA E1F1               	jp	z,readn0	;for another char if so
                                				;column position computed for ctlh
  E292    21 E30C               	ld	hl,column
  E295    96                    	sub	(hl)		;diff > 0
  E296    32 E30A               	ld	(compcol),a	;count down below
                                				;move back compcol-column spaces
  E299                          backsp:				;move back one more space
  E299    CD E1A4               	call	backup		;one space
  E29C    21 E30A               	ld	hl,compcol
  E29F    35                    	dec	(hl)
  E2A0    C2 E299               	jp	nz,backsp
  E2A3    C3 E1F1               	jp	readn0		;for next character
                                
  E2A6                          notr:				;not a ctlr, place into buffer
  E2A6    23                    rdecho:	inc	hl
  E2A7    77                    	ld	(hl),a		;character filled to mem
  E2A8    04                    	inc	b		;blen = blen + 1
  E2A9                          rdech1:				;look for a random control character
  E2A9    C5                    	push	bc
  E2AA    E5                    	push	hl		;active values saved
  E2AB    4F                    	ld	c,a		;ready to print
  E2AC    CD E17F               	call	ctlout		;may be up-arrow C
  E2AF    E1                    	pop	hl
  E2B0    C1                    	pop	bc
  E2B1    7E                    	ld	a,(hl)		;recall char
  E2B2    FE 03                 	cp	ctlc		;set flags for reboot test
  E2B4    78                    	ld	a,b		;move length to A
  E2B5    C2 E2BD               	jp	nz,notc		;skip if not a control c
  E2B8    FE 01                 	cp	1		;control C, must be length 1
  E2BA    CA 0000               	jp	z,reboot	;reboot if blen = 1
                                				;length not one, so skip reboot
  E2BD                          notc:				;not reboot, are we at end of buffer?
  E2BD    B9                    	cp	c
  E2BE    DA E1EF               	jp	c,readnx	;go for another if not
  E2C1                          readen:				;end of read operation, store blen
  E2C1    E1                    	pop	hl
  E2C2    70                    	ld	(hl),b		;M(current len) = B
  E2C3    0E 0D                 	ld	c,cr
  E2C5    C3 E148               	jp	conout		;return carriage
                                ;	ret
  E2C8                          func1:				;return console character with echo
  E2C8    CD E106               	call	conech
  E2CB    C3 E301               	jp	sta$ret
                                
  E190                          func2	equ	tabout
                                				;write console character with tab expansion
                                
  E2CE                          func3:				;return reader character
  E2CE    CD EE15               	call	readerf
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-10


  E2D1    C3 E301               	jp	sta$ret
                                
                                ;func4:	equated to punchf
                                				;write punch character
                                
                                ;func5:	equated to listf
                                				;write list character
                                				;write to list device
                                
  E2D4                          func6:				;direct console i/o - read if 0ffh
  E2D4    79                    	ld	a,c
  E2D5    3C                    	inc	a
  E2D6    CA E2E0               	jp	z,dirinp	;0ffh => 00h, means input mode
  E2D9    3C                    	inc	a
  E2DA    CA EE06               	jp	z,constf	;0feH in C for status
                                				;direct output function
  E2DD    C3 EE0C               	jp	conoutf
                                
  E2E0    CD EE06               dirinp:	call	constf		;status check
  E2E3    B7                    	or	a
  E2E4    CA ED91               	jp	z,retmon	;skip, return 00 if not ready
                                				;character is ready, get it
  E2E7    CD EE09               	call	coninf		;to A
  E2EA    C3 E301               	jp	sta$ret
                                
  E2ED                          func7:				;return io byte
  E2ED    3A 0003               	ld	a,(ioloc)
  E2F0    C3 E301               	jp	sta$ret
                                
  E2F3                          func8:				;set i/o byte
  E2F3    21 0003               	ld	hl,ioloc
  E2F6    71                    	ld	(hl),c
  E2F7    C9                    	ret			;jmp goback
                                
  E2F8                          func9:				;write line until $ encountered
  E2F8    EB                    	ex	de,hl		;was lhld info
  E2F9    4D                    	ld	c,l
  E2FA    44                    	ld	b,h		;BC=string address
  E2FB    C3 E1D3               	jp	print		;out to console
                                
  E1E1                          func10	equ	read
                                				;read a buffered console line
                                
  E2FE                          func11:				;check console status
  E2FE    CD E123               	call	conbrk
                                				;(drop through to sta$ret)
  E301                          sta$ret:			;store the A register to aret
  E301    32 E345               	ld	(aret),a
  E304                          func$ret:
  E304    C9                    	ret			;jmp goback (pop stack for non cp/m functions)
                                
  E305                          setlret1:			;set lret = 1
  E305    3E 01                 	ld	a,1
  E307    C3 E301               	jp	sta$ret
                                
                                
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-11


                                
                                ;	data areas
                                
  E30A                          compcol:
  E30A    00                    	db	0		;true if computing column position
  E30B                          strtcol:
  E30B    00                    	db	0		;starting column position after read
  E30C    00                    column:	db	0		;column position
  E30D    00                    listcp:	db	0		;listing toggle
  E30E    00                    kbchar:	db	0		;initial key char = 00
  E30F                          entsp:	ds	2		;entry stack pointer
  E311                          	ds	ssize*2		;stack size
  E341                          lstack:
                                ;	end of Basic I/O System
                                
                                ;*****************************************************************
                                ;*****************************************************************
                                
                                ;	common values shared between bdosi and bdos
  E341                          usrcode:
  E341    00                    	db	0		;current user number
  E342    00                    curdsk:	db	0		;current disk number
  E343                          info:	ds	2		;information address
  E345                          aret:	ds	2		;address value to return
  E345                          lret	equ	aret		;low(aret)
                                
                                ;*****************************************************************
                                ;*****************************************************************
                                ;**                                                             **
                                ;**   B a s i c    D i s k   O p e r a t i n g   S y s t e m    **
                                ;**                                                             **
                                ;*****************************************************************
                                ;*****************************************************************
                                
  0022                          dvers	equ	22h		;version 2.2
                                ;	module addresses
                                
                                ;	literal constants
  00FF                          true	equ	0ffh		;constant true
  0000                          false	equ	000h		;constant false
  FFFF                          enddir	equ	0ffffh		;end of directory
  0001                          byte	equ	1		;number of bytes for "byte" type
  0002                          word	equ	2		;number of bytes for "word" type
                                
                                ;	fixed addresses in low memory
  005C                          tfcb	equ	005ch		;default fcb location
  0080                          tbuff	equ	0080h		;default buffer location
                                
                                ;	fixed addresses referenced in bios module are
                                ;	pererr (0009), selerr (000c), roderr (000f)
                                
                                ;	error message handlers
                                
                                ;per$error:			;report permanent error to user
                                ;	ld	hl,pererr
                                ;	jp	goerr
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-12


                                
                                ;rod$error:			;report read/only disk error
                                ;	ld	hl,roderr
                                ;	jp	goerr
                                
                                ;rof$error:			;report read/only file error
                                ;	ld	hl,roferr
                                ;	jp	goerr
                                
  E347                          sel$error:			;report select error
  E347    21 E00B               	ld	hl,selerr
                                
                                
  E34A                          goerr:				;HL = .errorhandler, call subroutine
  E34A    5E                    	ld	e,(hl)
  E34B    23                    	inc	hl
  E34C    56                    	ld	d,(hl)		;address of routine in DE
  E34D    EB                    	ex	de,hl
  E34E    E9                    	jp	(hl)		;to subroutine
                                
                                
                                
                                ;	local subroutines for bios interface
                                
  E34F                          move:				;move data length of length C from source DE to
                                				;destination given by HL
  E34F    0C                    	inc	c		;in case it is zero
  E350    0D                    move0:	dec	c
  E351    C8                    	ret	z		;more to move
  E352    1A                    	ld	a,(de)
  E353    77                    	ld	(hl),a		;one byte moved
  E354    13                    	inc	de
  E355    23                    	inc	hl		;to next byte
  E356    C3 E350               	jp	move0
                                
  E359                          selectdisk:			;select the disk drive given by curdsk, and fill
                                				;the base addresses curtrka - alloca, then fill
                                				;the values of the disk parameter block
  E359    3A E342               	ld	a,(curdsk)
  E35C    4F                    	ld	c,a		;current disk# to c
                                				;lsb of e = 0 if not yet logged - in
  E35D    CD EE1B               	call	seldskf		;HL filled by call
                                				;HL = 0000 if error, otherwise disk headers
  E360    7C                    	ld	a,h
  E361    B5                    	or	l
  E362    C8                    	ret	z		;return with 0000 in HL and z flag
                                				;disk header block address in hl
  E363    5E                    	ld	e,(hl)
  E364    23                    	inc	hl
  E365    56                    	ld	d,(hl)
  E366    23                    	inc	hl		;DE=.tran
  E367    22 EDB3               	ld	(cdrmaxa),hl
  E36A    23                    	inc	hl
  E36B    23                    	inc	hl		;.cdrmax
  E36C    22 EDB5               	ld	(curtrka),hl
  E36F    23                    	inc	hl
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-13


  E370    23                    	inc	hl		;HL=.currec
  E371    22 EDB7               	ld	(curreca),hl
  E374    23                    	inc	hl
  E375    23                    	inc	hl		;HL=.buffa
                                				;DE still contains .tran
  E376    EB                    	ex	de,hl
  E377    22 EDD0               	ld	(tranv),hl	;.tran vector
  E37A    21 EDB9               	ld	hl,buffa	;DE= source for move, HL=dest
  E37D    0E 08                 	ld	c,addlist
  E37F    CD E34F               	call	move		;addlist filled
                                				;now fill the disk parameter block
  E382    2A EDBB               	ld	hl,(dpbaddr)
  E385    EB                    	ex	de,hl		;DE is source
  E386    21 EDC1               	ld	hl,sectpt	;HL is destination
  E389    0E 0F                 	ld	c,dpblist
  E38B    CD E34F               	call	move		;data filled
                                				;now set single/double map mode
  E38E    2A EDC6               	ld	hl,(maxall)	;largest allocation number
  E391    7C                    	ld	a,h		;00 indicates < 255
  E392    21 EDDD               	ld	hl,single
  E395    36 FF                 	ld	(hl),true	;assume a=00
  E397    B7                    	or	a
  E398    CA E39D               	jp	z,retselect
                                				;high order of maxall not zero, use double dm
  E39B    36 00                 	ld	(hl),false
  E39D                          retselect:
  E39D    3E FF                 	ld	a,true
  E39F    B7                    	or	a
  E3A0    C9                    	ret			;select disk function ok
                                
  E3A1                          home:				;move to home position, then offset to start of dir
  E3A1    CD EE18               	call	homef		;move to track 00, sector 00 reference
                                				;lxi h,offset ;mov c,m ;inx h ;mov b,m ;call settrkf
                                				;first directory position selected
  E3A4    AF                    	xor	a		;constant zero to accumulator
  E3A5    2A EDB5               	ld	hl,(curtrka)
  E3A8    77                    	ld	(hl),a
  E3A9    23                    	inc	hl
  E3AA    77                    	ld	(hl),a		;curtrk=0000
  E3AB    2A EDB7               	ld	hl,(curreca)
  E3AE    77                    	ld	(hl),a
  E3AF    23                    	inc	hl
  E3B0    77                    	ld	(hl),a		;currec=0000
                                				;curtrk, currec both set to 0000
  E3B1    C9                    	ret
                                
  E3B2                          rdbuff:				;read buffer and check condition
  E3B2    CD EE27               	call	readf		;current drive, track, sector, dma
  E3B5    C3 E3BB               	jp	diocomp		;check for i/o errors
                                
  E3B8                          wrbuff:				;write buffer and check condition
                                				;write type (wrtype) is in register C
                                				;wrtype = 0 => normal write operation
                                				;wrtype = 1 => directory write operation
                                				;wrtype = 2 => start of new block
  E3B8    CD EE2A               	call	writef		;current drive, track, sector, dma
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-14


  E3BB                          diocomp:			;check for disk errors
  E3BB    B7                    	or	a
  E3BC    C8                    	ret	z
  E3BD    21 E009               	ld	hl,pererr
  E3C0    C3 E34A               	jp	goerr
                                
  E3C3                          seek$dir:			;seek the record containing the current dir entry
  E3C3    2A EDEA               	ld	hl,(dcnt)	;directory counter to HL
  E3C6    0E 02                 	ld	c,dskshf
  E3C8    CD E4EA               	call	hlrotr		;value to HL
  E3CB    22 EDE5               	ld	(arecord),hl
  E3CE    22 EDEC               	ld	(drec),hl	;ready for seek
                                ;	jp	seek
                                ;	ret
                                
                                
  E3D1                          seek:				;seek the track given by arecord (actual record)
                                				;local equates for registers
                                				;load the registers from memory
  E3D1    21 EDE5               	ld	hl,arecord
  E3D4    4E                    	ld	c,(hl)
  E3D5    23                    	inc	hl
  E3D6    46                    	ld	b,(hl)
  E3D7    2A EDB7               	ld	hl,(curreca)
  E3DA    5E                    	ld	e,(hl)
  E3DB    23                    	inc	hl
  E3DC    56                    	ld	d,(hl)
  E3DD    2A EDB5               	ld	hl,(curtrka)
  E3E0    7E                    	ld	a,(hl)
  E3E1    23                    	inc	hl
  E3E2    66                    	ld	h,(hl)
  E3E3    6F                    	ld	l,a
                                				;loop while arecord < currec
  E3E4    79                    seek0:	ld	a,c
  E3E5    93                    	sub	e
  E3E6    78                    	ld	a,b
  E3E7    9A                    	sbc	a,d
  E3E8    D2 E3FA               	jp	nc,seek1	;skip if arecord >= currec
                                				;currec = currec - sectpt
  E3EB    E5                    	push	hl
  E3EC    2A EDC1               	ld	hl,(sectpt)
  E3EF    7B                    	ld	a,e
  E3F0    95                    	sub	l
  E3F1    5F                    	ld	e,a
  E3F2    7A                    	ld	a,d
  E3F3    9C                    	sbc	a,h
  E3F4    57                    	ld	d,a
  E3F5    E1                    	pop	hl
                                				;curtrk = curtrk - 1
  E3F6    2B                    	dec	hl
  E3F7    C3 E3E4               	jp	seek0		;for another try
                                
  E3FA                          seek1:				;look while arecord >= (t:=currec + sectpt)
  E3FA    E5                    	push	hl
  E3FB    2A EDC1               	ld	hl,(sectpt)
  E3FE    19                    	add	hl,de		;HL = currec+sectpt
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-15


  E3FF    DA E40F               	jp	c,seek2		;can be > FFFFH
  E402    79                    	ld	a,c
  E403    95                    	sub	l
  E404    78                    	ld	a,b
  E405    9C                    	sbc	a,h
  E406    DA E40F               	jp	c,seek2		;skip if t > arecord
                                				;currec = t
  E409    EB                    	ex	de,hl
                                				;curtrk = curtrk + 1
  E40A    E1                    	pop	hl
  E40B    23                    	inc	hl
  E40C    C3 E3FA               	jp	seek1		;for another try
                                
  E40F    E1                    seek2:	pop	hl
                                				;arrive here with updated values in each register
  E410    C5                    	push	bc
  E411    D5                    	push	de
  E412    E5                    	push	hl		;to stack for later
                                				;stack contains (lowest) BC=arecord, DE=currec, HL=curtrk
  E413    EB                    	ex	de,hl
  E414    2A EDCE               	ld	hl,(offset)
  E417    19                    	add	hl,de		;HL = curtrk+offset
  E418    44                    	ld	b,h
  E419    4D                    	ld	c,l
  E41A    CD EE1E               	call	settrkf		;track set up
                                				;note that BC - curtrk is difference to move in bios
  E41D    D1                    	pop	de		;recall curtrk
  E41E    2A EDB5               	ld	hl,(curtrka)
  E421    73                    	ld	(hl),e
  E422    23                    	inc	hl
  E423    72                    	ld	(hl),d		;curtrk updated
                                				;now compute sector as arecord-currec
  E424    D1                    	pop	de		;recall currec
  E425    2A EDB7               	ld	hl,(curreca)
  E428    73                    	ld	(hl),e
  E429    23                    	inc	hl
  E42A    72                    	ld	(hl),d
  E42B    C1                    	pop	bc		;BC=arecord, DE=currec
  E42C    79                    	ld	a,c
  E42D    93                    	sub	e
  E42E    4F                    	ld	c,a
  E42F    78                    	ld	a,b
  E430    9A                    	sbc	a,d
  E431    47                    	ld	b,a
  E432    2A EDD0               	ld	hl,(tranv)
  E435    EB                    	ex	de,hl		;BC=sector#, DE=.tran
  E436    CD EE30               	call	sectran		;HL = tran(sector)
  E439    4D                    	ld	c,l
  E43A    44                    	ld	b,h		;BC = tran(sector)
  E43B    C3 EE21               	jp	setsecf		;sector selected
                                ;	ret
                                
                                ;	file control block (fcb) constants
  00E5                          empty	equ	0e5h		;empty directory entry
  007F                          lstrec	equ	127		;last record# in extent
  0080                          recsiz	equ	128		;record size
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-16


  0020                          fcblen	equ	32		;file control block size
  0004                          dirrec	equ	recsiz/fcblen	;directory elts / record
  0002                          dskshf	equ	2		;log2(dirrec)
  0003                          dskmsk	equ	dirrec-1
  0005                          fcbshf	equ	5		;log2(fcblen)
                                
  000C                          extnum	equ	12		;extent number field
  001F                          maxext	equ	31		;largest extent number
  000D                          ubytes	equ	13		;unfilled bytes field
  000E                          modnum	equ	14		;data module number
  000F                          maxmod	equ	15		;largest module number
  0080                          fwfmsk	equ	80h		;file write flag is high order modnum
  000F                          namlen	equ	15		;name length
  000F                          reccnt	equ	15		;record count field
  0010                          dskmap	equ	16		;disk map field
  001F                          lstfcb	equ	fcblen-1
  0020                          nxtrec	equ	fcblen
  0021                          ranrec	equ	nxtrec+1	;random record field (2 bytes)
                                
                                ;	reserved file indicators
  0009                          rofile	equ	9		;high order of first type char
  000A                          invis	equ	10		;invisible file in dir command
                                ;	equ	11		;reserved
                                
                                ;	utility functions for file access
                                
  E43E                          dm$position:			;compute disk map position for vrecord to HL
  E43E    21 EDC3               	ld	hl,blkshf
  E441    4E                    	ld	c,(hl)		;shift count to C
  E442    3A EDE3               	ld	a,(vrecord)	;current virtual record to A
  E445    B7                    dmpos0:	or	a
  E446    1F                    	rra
  E447    0D                    	dec	c
  E448    C2 E445               	jp	nz,dmpos0
                                				;A = shr(vrecord,blkshf) = vrecord/2**(sect/block)
  E44B    47                    	ld	b,a		;save it for later addition
  E44C    3E 08                 	ld	a,8
  E44E    96                    	sub	(hl)		;8-blkshf to accumulator
  E44F    4F                    	ld	c,a		;extent shift count in register c
  E450    3A EDE2               	ld	a,(extval)	;extent value ani extmsk
  E453                          dmpos1:
                                				;blkshf = 3,4,5,6,7, C=5,4,3,2,1
                                				;shift is 4,3,2,1,0
  E453    0D                    	dec	c
  E454    CA E45C               	jp	z,dmpos2
  E457    B7                    	or	a
  E458    17                    	rla
  E459    C3 E453               	jp	dmpos1
                                
  E45C                          dmpos2:				;arrive here with A = shl(ext and extmsk,7-blkshf)
  E45C    80                    	add	a,b		;add the previous shr(vrecord,blkshf) value
                                				;A is one of the following values, depending upon alloc
                                				;bks blkshf
                                				;1k   3     v/8 + extval * 16
                                				;2k   4     v/16+ extval * 8
                                				;4k   5     v/32+ extval * 4
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-17


                                				;8k   6     v/64+ extval * 2
                                				;16k  7     v/128+extval * 1
  E45D    C9                    	ret			;with dm$position in A
                                
  E45E                          getdm:				;return disk map value from position given by BC
  E45E    2A E343               	ld	hl,(info)	;base address of file control block
  E461    11 0010               	ld	de,dskmap
  E464    19                    	add	hl,de		;HL =.diskmap
  E465    09                    	add	hl,bc		;index by a single byte value
  E466    3A EDDD               	ld	a,(single)	;single byte/map entry?
  E469    B7                    	or	a
  E46A    CA E471               	jp	z,getdmd	;get disk map single byte
  E46D    6E                    	ld	l,(hl)
  E46E    26 00                 	ld	h,0
  E470    C9                    	ret			;with HL=00bb
  E471                          getdmd:
  E471    09                    	add	hl,bc		;HL=.fcb(dm+i*2)
                                				;double precision value returned
  E472    5E                    	ld	e,(hl)
  E473    23                    	inc	hl
  E474    56                    	ld	d,(hl)
  E475    EB                    	ex	de,hl
  E476    C9                    	ret
                                
  E477                          index:				;compute disk block number from current fcb
  E477    CD E43E               	call	dm$position	;0...15 in register A
  E47A    4F                    	ld	c,a
  E47B    06 00                 	ld	b,0
  E47D    CD E45E               	call	getdm		;value to HL
  E480    22 EDE5               	ld	(arecord),hl
  E483    C9                    	ret
                                
  E484                          allocated:			;called following index to see if block allocated
  E484    2A EDE5               	ld	hl,(arecord)
  E487    7D                    	ld	a,l
  E488    B4                    	or	h
  E489    C9                    	ret
                                
  E48A                          atran:				;compute actual record address, assuming index called
  E48A    3A EDC3               	ld	a,(blkshf)	;shift count to reg A
  E48D    2A EDE5               	ld	hl,(arecord)
  E490    29                    atran0:	add	hl,hl
  E491    3D                    	dec	a
  E492    C2 E490               	jp	nz,atran0	;shl(arecord,blkshf)
  E495    22 EDE7               	ld	(arecord1),hl	;save shifted block #
  E498    3A EDC4               	ld	a,(blkmsk)
  E49B    4F                    	ld	c,a		;mask value to C
  E49C    3A EDE3               	ld	a,(vrecord)
  E49F    A1                    	and	c		;masked value in A
  E4A0    B5                    	or	l
  E4A1    6F                    	ld	l,a		;to HL
  E4A2    22 EDE5               	ld	(arecord),hl	;arecord=HL or (vrecord and blkmsk)
  E4A5    C9                    	ret
                                
  E4A6                          getexta:			;get current extent field address to A
  E4A6    2A E343               	ld	hl,(info)
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-18


  E4A9    11 000C               	ld	de,extnum
  E4AC    19                    	add	hl,de		;HL=.fcb(extnum)
  E4AD    C9                    	ret
                                
  E4AE                          getfcba:			;compute reccnt and nxtrec addresses for get/setfcb
  E4AE    2A E343               	ld	hl,(info)
  E4B1    11 000F               	ld	de,reccnt
  E4B4    19                    	add	hl,de
  E4B5    EB                    	ex	de,hl		;DE=.fcb(reccnt)
  E4B6    21 0011               	ld	hl,nxtrec-reccnt
  E4B9    19                    	add	hl,de		;HL=.fcb(nxtrec)
  E4BA    C9                    	ret
                                
  E4BB                          getfcb:				;set variables from currently addressed fcb
  E4BB    CD E4AE               	call	getfcba		;addresses in DE, HL
  E4BE    7E                    	ld	a,(hl)
  E4BF    32 EDE3               	ld	(vrecord),a	;vrecord=fcb(nxtrec)
  E4C2    EB                    	ex	de,hl
  E4C3    7E                    	ld	a,(hl)
  E4C4    32 EDE1               	ld	(rcount),a	;rcount=fcb(reccnt)
  E4C7    CD E4A6               	call	getexta		;HL=.fcb(extnum)
  E4CA    3A EDC5               	ld	a,(extmsk)	;extent mask to a
  E4CD    A6                    	and	(hl)		;fcb(extnum) and extmsk
  E4CE    32 EDE2               	ld	(extval),a
  E4D1    C9                    	ret
                                
  E4D2                          setfcb:				;place values back into current fcb
  E4D2    CD E4AE               	call	getfcba		;addresses to DE, HL
  E4D5    3A EDD5               	ld	a,(seqio)
  E4D8    FE 02                 	cp	02
  E4DA    C2 E4DE               	jp	nz,setfcb1
  E4DD    AF                    	xor	a		;check ranfill
  E4DE                          setfcb1:
  E4DE    4F                    	ld	c,a		;=1 if sequential i/o
  E4DF    3A EDE3               	ld	a,(vrecord)
  E4E2    81                    	add	a,c
  E4E3    77                    	ld	(hl),a		;fcb(nxtrec)=vrecord+seqio
  E4E4    EB                    	ex	de,hl
  E4E5    3A EDE1               	ld	a,(rcount)
  E4E8    77                    	ld	(hl),a		;fcb(reccnt)=rcount
  E4E9    C9                    	ret
                                
  E4EA                          hlrotr:				;hl rotate right by amount C
  E4EA    0C                    	inc	c		;in case zero
  E4EB                          hlrotr0:
  E4EB    0D                    	dec	c
  E4EC    C8                    	ret	z		;return when zero
  E4ED    7C                    	ld	a,h
  E4EE    B7                    	or	a
  E4EF    1F                    	rra
  E4F0    67                    	ld	h,a		;high byte
  E4F1    7D                    	ld	a,l
  E4F2    1F                    	rra
  E4F3    6F                    	ld	l,a		;low byte
  E4F4    C3 E4EB               	jp	hlrotr0
                                
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-19


  E4F7                          compute$cs:			;compute checksum for current directory buffer
  E4F7    0E 80                 	ld	c,recsiz	;size of directory buffer
  E4F9    2A EDB9               	ld	hl,(buffa)	;current directory buffer
  E4FC    AF                    	xor	a		;clear checksum value
  E4FD                          computecs0:
  E4FD    86                    	add	a,(hl)
  E4FE    23                    	inc	hl
  E4FF    0D                    	dec	c		;cs=cs+buff(recsiz-C)
  E500    C2 E4FD               	jp	nz,computecs0
  E503    C9                    	ret			;with checksum in A
                                
  E504                          hlrotl:				;rotate the mask in HL by amount in C
  E504    0C                    	inc	c		;may be zero
  E505                          hlrotl0:
  E505    0D                    	dec	c
  E506    C8                    	ret	z		;return if zero
  E507    29                    	add	hl,hl
  E508    C3 E505               	jp	hlrotl0
                                
  E50B                          set$cdisk:			;set a "1" value in curdsk position of BC
  E50B    C5                    	push	bc		;save input parameter
  E50C    3A E342               	ld	a,(curdsk)
  E50F    4F                    	ld	c,a		;ready parameter for shift
  E510    21 0001               	ld	hl,1		;number to shift
  E513    CD E504               	call	hlrotl		;HL = mask to integrate
  E516    C1                    	pop	bc		;original mask
  E517    79                    	ld	a,c
  E518    B5                    	or	l
  E519    6F                    	ld	l,a
  E51A    78                    	ld	a,b
  E51B    B4                    	or	h
  E51C    67                    	ld	h,a		;HL = mask or rol(1,curdsk)
  E51D    C9                    	ret
                                
  E51E                          nowrite:			;return true if dir checksum difference occurred
  E51E    2A EDAD               	ld	hl,(rodsk)
  E521    3A E342               	ld	a,(curdsk)
  E524    4F                    	ld	c,a
  E525    CD E4EA               	call	hlrotr
  E528    7D                    	ld	a,l
  E529    E6 01                 	and	1b
  E52B    C9                    	ret			;non zero if nowrite
                                
  E52C                          set$ro:				;set current disk to read only
  E52C    21 EDAD               	ld	hl,rodsk
  E52F    4E                    	ld	c,(hl)
  E530    23                    	inc	hl
  E531    46                    	ld	b,(hl)
  E532    CD E50B               	call	set$cdisk	;sets bit to 1
  E535    22 EDAD               	ld	(rodsk),hl
                                				;high water mark in directory goes to max
  E538    2A EDC8               	ld	hl,(dirmax)
  E53B    23                    	inc	hl
  E53C    EB                    	ex	de,hl		;DE = directory max
  E53D    2A EDB3               	ld	hl,(cdrmaxa)	;HL = .cdrmax
  E540    73                    	ld	(hl),e
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-20


  E541    23                    	inc	hl
  E542    72                    	ld	(hl),d		;cdrmax = dirmax
  E543    C9                    	ret
                                
  E544                          check$rodir:			;check current directory element for read/only status
  E544    CD E55E               	call	getdptra	;address of element
                                
  E547                          check$rofile:			;check current buff(dptr) or fcb(0) for r/o status
  E547    11 0009               	ld	de,rofile
  E54A    19                    	add	hl,de		;offset to ro bit
  E54B    7E                    	ld	a,(hl)
  E54C    17                    	rla
  E54D    D0                    	ret	nc		;return if not set
  E54E    21 E00F               	ld	hl,roferr
  E551    C3 E34A               	jp	goerr
                                ;	jp	rof$error 	;exit to read only disk message
                                
                                
  E554                          check$write:			;check for write protected disk
  E554    CD E51E               	call	nowrite
  E557    C8                    	ret	z		;ok to write if not rodsk
  E558    21 E00D               	ld	hl,roderr
  E55B    C3 E34A               	jp	goerr
                                ;	jp	rod$error	;read only disk error
                                
  E55E                          getdptra:			;compute the address of a directory element at
                                				;positon dptr in the buffer
  E55E    2A EDB9               	ld	hl,(buffa)
  E561    3A EDE9               	ld	a,(dptr)
  E564                          addh:				;HL = HL + A
  E564    85                    	add	a,l
  E565    6F                    	ld	l,a
  E566    D0                    	ret	nc
                                				;overflow to H
  E567    24                    	inc	h
  E568    C9                    	ret
                                
                                
  E569                          getmodnum:			;compute the address of the module number
                                				;bring module number to accumulator
                                				;(high order bit is fwf (file write flag)
  E569    2A E343               	ld	hl,(info)
  E56C    11 000E               	ld	de,modnum
  E56F    19                    	add	hl,de		;HL=.fcb(modnum)
  E570    7E                    	ld	a,(hl)
  E571    C9                    	ret			;A=fcb(modnum)
                                
  E572                          clrmodnum:			;clear the module number field for user open/make
  E572    CD E569               	call	getmodnum
  E575    36 00                 	ld	(hl),0		;fcb(modnum)=0
  E577    C9                    	ret
                                
  E578    CD E569               setfwf:	call	getmodnum	;HL=.fcb(modnum), A=fcb(modnum)
                                				;set fwf (file write flag) to "1"
  E57B    F6 80                 	or	fwfmsk
  E57D    77                    	ld	(hl),a		;fcb(modnum)=fcb(modnum) or 80h
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-21


                                				;also returns non zero in accumulator
  E57E    C9                    	ret
                                
                                
  E57F                          compcdr:			;return cy if cdrmax > dcnt
  E57F    2A EDEA               	ld	hl,(dcnt)
  E582    EB                    	ex	de,hl		;DE = directory counter
  E583    2A EDB3               	ld	hl,(cdrmaxa)	;HL=.cdrmax
  E586    7B                    	ld	a,e
  E587    96                    	sub	(hl)		;low(dcnt) - low(cdrmax)
  E588    23                    	inc	hl		;HL = .cdrmax+1
  E589    7A                    	ld	a,d
  E58A    9E                    	sbc	a,(hl)		;hig(dcnt) - hig(cdrmax)
                                				;condition dcnt - cdrmax  produces cy if cdrmax>dcnt
  E58B    C9                    	ret
                                
  E58C                          setcdr:				;if not (cdrmax > dcnt) then cdrmax = dcnt+1
  E58C    CD E57F               	call	compcdr
  E58F    D8                    	ret	c		;return if cdrmax > dcnt
                                				;otherwise, HL = .cdrmax+1, DE = dcnt
  E590    13                    	inc	de
  E591    72                    	ld	(hl),d
  E592    2B                    	dec	hl
  E593    73                    	ld	(hl),e
  E594    C9                    	ret
                                
  E595                          subdh:				;compute HL = DE - HL
  E595    7B                    	ld	a,e
  E596    95                    	sub	l
  E597    6F                    	ld	l,a
  E598    7A                    	ld	a,d
  E599    9C                    	sbc	a,h
  E59A    67                    	ld	h,a
  E59B    C9                    	ret
                                
  E59C                          newchecksum:
  E59C    0E FF                 	ld	c,true		;drop through to compute new checksum
  E59E                          checksum:			;compute current checksum record and update the
                                				;directory element if C=true, or check for = if not
                                				;drec < chksiz?
  E59E    2A EDEC               	ld	hl,(drec)
  E5A1    EB                    	ex	de,hl
  E5A2    2A EDCC               	ld	hl,(chksiz)
  E5A5    CD E595               	call	subdh		;DE-HL
  E5A8    D0                    	ret	nc		;skip checksum if past checksum vector size
                                				;drec < chksiz, so continue
  E5A9    C5                    	push	bc		;save init flag
  E5AA    CD E4F7               	call	compute$cs	;check sum value to A
  E5AD    2A EDBD               	ld	hl,(checka)	;address of check sum vector
  E5B0    EB                    	ex	de,hl
  E5B1    2A EDEC               	ld	hl,(drec)	;value of drec
  E5B4    19                    	add	hl,de		;HL = .check(drec)
  E5B5    C1                    	pop	bc		;recall true=0ffh or false=00 to C
  E5B6    0C                    	inc	c		;0ffh produces zero flag
  E5B7    CA E5C4               	jp	z,initial$cs
                                				;not initializing, compare
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-22


  E5BA    BE                    	cp	(hl)		;compute$cs=check(drec)?
  E5BB    C8                    	ret	z		;no message if ok
                                				;checksum error, are we beyond
                                				;the end of the disk?
  E5BC    CD E57F               	call	compcdr
  E5BF    D0                    	ret	nc		;no message if so
  E5C0    CD E52C               	call	set$ro		;read/only disk set
  E5C3    C9                    	ret
                                
  E5C4                          initial$cs:			;initializing the checksum
  E5C4    77                    	ld	(hl),a
  E5C5    C9                    	ret
                                
                                
  E5C6                          wrdir:				;write the current directory entry, set checksum
  E5C6    CD E59C               	call	newchecksum	;initialize entry
  E5C9    CD E5E0               	call	setdir		;directory dma
  E5CC    0E 01                 	ld	c,1		;indicates a write directory operation
  E5CE    CD E3B8               	call	wrbuff		;write the buffer
  E5D1    C3 E5DA               	jp	setdata		;to data dma address
                                ;	ret
  E5D4                          rd$dir:				;read a directory entry into the directory buffer
  E5D4    CD E5E0               	call	setdir		;directory dma
  E5D7    CD E3B2               	call	rdbuff		;directory record loaded
                                				;jmp setdata to data dma address
                                ;	ret
  E5DA                          setdata:			;set data dma address
  E5DA    21 EDB1               	ld	hl,dmaad
  E5DD    C3 E5E3               	jp	setdma		;to complete the call
                                
  E5E0                          setdir:				;set directory dma address
  E5E0    21 EDB9               	ld	hl,buffa	;jmp setdma to complete call
                                
  E5E3                          setdma:				;HL=.dma address to set (i.e., buffa or dmaad)
  E5E3    4E                    	ld	c,(hl)
  E5E4    23                    	inc	hl
  E5E5    46                    	ld	b,(hl)		;parameter ready
  E5E6    C3 EE24               	jp	setdmaf
                                
  E5E9                          dir$to$user:			;copy the directory entry to the user buffer
                                				;after call to search or searchn by user code
  E5E9    2A EDB9               	ld	hl,(buffa)
  E5EC    EB                    	ex	de,hl		;source is directory buffer
  E5ED    2A EDB1               	ld	hl,(dmaad)	;destination is user dma address
  E5F0    0E 80                 	ld	c,recsiz	;copy entire record
  E5F2    C3 E34F               	jp	move
                                ;	ret
                                
  E5F5                          end$of$dir:			;return zero flag if at end of directory, non zero
                                				;if not at end (end of dir if dcnt = 0ffffh)
  E5F5    21 EDEA               	ld	hl,dcnt
  E5F8    7E                    	ld	a,(hl)		;may be 0ffh
  E5F9    23                    	inc	hl
  E5FA    BE                    	cp	(hl)		;low(dcnt) = high(dcnt)?
  E5FB    C0                    	ret	nz		;non zero returned if different
                                				;high and low the same, = 0ffh?
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-23


  E5FC    3C                    	inc	a		;0ffh becomes 00 if so
  E5FD    C9                    	ret
                                
  E5FE                          set$end$dir:			;set dcnt to the end of the directory
  E5FE    21 FFFF               	ld	hl,enddir
  E601    22 EDEA               	ld	(dcnt),hl
  E604    C9                    	ret
                                
  E605                          read$dir:			;read next directory entry, with C=true if initializing
  E605    2A EDC8               	ld	hl,(dirmax)
  E608    EB                    	ex	de,hl		;in preparation for subtract
  E609    2A EDEA               	ld	hl,(dcnt)
  E60C    23                    	inc	hl
  E60D    22 EDEA               	ld	(dcnt),hl	;dcnt=dcnt+1
                                				;continue while dirmax >= dcnt (dirmax-dcnt no cy)
  E610    CD E595               	call	subdh		;DE-HL
  E613    D2 E619               	jp	nc,read$dir0
                                				;yes, set dcnt to end of directory
  E616    C3 E5FE               	jp	set$end$dir
                                ;	ret
                                
  E619                          read$dir0:			;not at end of directory, seek next element
                                				;initialization flag is in C
  E619    3A EDEA               	ld	a,(dcnt)
  E61C    E6 03                 	and	dskmsk		;low(dcnt) and dskmsk
  E61E    06 05                 	ld	b,fcbshf	;to multiply by fcb size
  E620                          read$dir1:
  E620    87                    	add	a,a
  E621    05                    	dec	b
  E622    C2 E620               	jp	nz,read$dir1
                                				;A = (low(dcnt) and dskmsk) shl fcbshf
  E625    32 EDE9               	ld	(dptr),a	;ready for next dir operation
  E628    B7                    	or	a
  E629    C0                    	ret	nz		;return if not a new record
  E62A    C5                    	push	bc		;save initialization flag C
  E62B    CD E3C3               	call	seek$dir	;seek proper record
  E62E    CD E5D4               	call	rd$dir		;read the directory record
  E631    C1                    	pop	bc		;recall initialization flag
  E632    C3 E59E               	jp	checksum	;checksum the directory elt
                                ;	ret
                                
                                
  E635                          getallocbit:			;given allocation vector position BC, return with byte
                                				;containing BC shifted so that the least significant
                                				;bit is in the low order accumulator position.  HL is
                                				;the address of the byte for possible replacement in
                                				;memory upon return, and D contains the number of shifts
                                				;required to place the returned value back into position
  E635    79                    	ld	a,c
  E636    E6 07                 	and	111b
  E638    3C                    	inc	a
  E639    5F                    	ld	e,a
  E63A    57                    	ld	d,a
                                				;d and e both contain the number of bit positions to shift
  E63B    79                    	ld	a,c
  E63C    0F                    	rrca
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-24


  E63D    0F                    	rrca
  E63E    0F                    	rrca
  E63F    E6 1F                 	and	11111b
  E641    4F                    	ld	c,a		;C shr 3 to C
  E642    78                    	ld	a,b
  E643    87                    	add	a,a
  E644    87                    	add	a,a
  E645    87                    	add	a,a
  E646    87                    	add	a,a
  E647    87                    	add	a,a		;B shl 5
  E648    B1                    	or	c
  E649    4F                    	ld	c,a		;bbbccccc to C
  E64A    78                    	ld	a,b
  E64B    0F                    	rrca
  E64C    0F                    	rrca
  E64D    0F                    	rrca
  E64E    E6 1F                 	and	11111b
  E650    47                    	ld	b,a		;BC shr 3 to BC
  E651    2A EDBF               	ld	hl,(alloca)	;base address of allocation vector
  E654    09                    	add	hl,bc
  E655    7E                    	ld	a,(hl)		;byte to A, hl = .alloc(BC shr 3)
                                				;now move the bit to the low order position of A
  E656    07                    rotl:	rlca
  E657    1D                    	dec	e
  E658    C2 E656               	jp	nz,rotl
  E65B    C9                    	ret
                                
                                
  E65C                          set$alloc$bit:			;BC is the bit position of ALLOC to set or reset.  The
                                				;value of the bit is in register E.
  E65C    D5                    	push	de
  E65D    CD E635               	call	getallocbit	;shifted val A, count in D
  E660    E6 FE                 	and	11111110b	;mask low bit to zero (may be set)
  E662    C1                    	pop	bc
  E663    B1                    	or	c		;low bit of C is masked into A
                                ;	jp	rotr 		;to rotate back into proper position
                                ;	ret
  E664                          rotr:
                                				;byte value from ALLOC is in register A, with shift count
                                				;in register C (to place bit back into position), and
                                				;target ALLOC position in registers HL, rotate and replace
  E664    0F                    	rrca
  E665    15                    	dec	d
  E666    C2 E664               	jp	nz,rotr		;back into position
  E669    77                    	ld	(hl),a		;back to ALLOC
  E66A    C9                    	ret
                                
  E66B                          scandm:				;scan the disk map addressed by dptr for non-zero
                                				;entries, the allocation vector entry corresponding
                                				;to a non-zero entry is set to the value of C (0,1)
  E66B    CD E55E               	call	getdptra	;HL = buffa + dptr
                                				;HL addresses the beginning of the directory entry
  E66E    11 0010               	ld	de,dskmap
  E671    19                    	add	hl,de		;hl now addresses the disk map
  E672    C5                    	push	bc		;save the 0/1 bit to set
  E673    0E 11                 	ld	c,fcblen-dskmap+1;size of single byte disk map + 1
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-25


  E675                          scandm0:			;loop once for each disk map entry
  E675    D1                    	pop	de		;recall bit parity
  E676    0D                    	dec	c
  E677    C8                    	ret	z		;all done scanning?
                                				;no, get next entry for scan
  E678    D5                    	push	de		;replace bit parity
  E679    3A EDDD               	ld	a,(single)
  E67C    B7                    	or	a
  E67D    CA E688               	jp	z,scandm1
                                				;single byte scan operation
  E680    C5                    	push	bc		;save counter
  E681    E5                    	push	hl		;save map address
  E682    4E                    	ld	c,(hl)
  E683    06 00                 	ld	b,0		;BC=block#
  E685    C3 E68E               	jp	scandm2
                                
  E688                          scandm1:			;double byte scan operation
  E688    0D                    	dec	c		;count for double byte
  E689    C5                    	push	bc		;save counter
  E68A    4E                    	ld	c,(hl)
  E68B    23                    	inc	hl
  E68C    46                    	ld	b,(hl)		;BC=block#
  E68D    E5                    	push	hl		;save map address
  E68E                          scandm2:			;arrive here with BC=block#, E=0/1
  E68E    79                    	ld	a,c
  E68F    B0                    	or	b		;skip if = 0000
  E690    CA E69D               	jp	z,scanm3
  E693    2A EDC6               	ld	hl,(maxall)	;check invalid index
  E696    7D                    	ld	a,l
  E697    91                    	sub	c
  E698    7C                    	ld	a,h
  E699    98                    	sbc	a,b		;maxall - block#
  E69A    D4 E65C               	call	nc,set$alloc$bit
                                				;bit set to 0/1
  E69D    E1                    scanm3:	pop	hl
  E69E    23                    	inc	hl		;to next bit position
  E69F    C1                    	pop	bc		;recall counter
  E6A0    C3 E675               	jp	scandm0		;for another item
                                
  E6A3                          initialize:			;initialize the current disk
                                				;lret = false ;set to true if $ file exists
                                				;compute the length of the allocation vector - 2
  E6A3    2A EDC6               	ld	hl,(maxall)
  E6A6    0E 03                 	ld	c,3		;perform maxall/8
                                				;number of bytes in alloc vector is (maxall/8)+1
  E6A8    CD E4EA               	call	hlrotr
  E6AB    23                    	inc	hl		;HL = maxall/8+1
  E6AC    44                    	ld	b,h
  E6AD    4D                    	ld	c,l		;count down BC til zero
  E6AE    2A EDBF               	ld	hl,(alloca)	;base of allocation vector
                                				;fill the allocation vector with zeros
  E6B1                          initial0:
  E6B1    36 00                 	ld	(hl),0
  E6B3    23                    	inc	hl		;alloc(i)=0
  E6B4    0B                    	dec	bc		;count length down
  E6B5    78                    	ld	a,b
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-26


  E6B6    B1                    	or	c
  E6B7    C2 E6B1               	jp	nz,initial0
                                				;set the reserved space for the directory
  E6BA    2A EDCA               	ld	hl,(dirblk)
  E6BD    EB                    	ex	de,hl
  E6BE    2A EDBF               	ld	hl,(alloca)	;HL=.alloc()
  E6C1    73                    	ld	(hl),e
  E6C2    23                    	inc	hl
  E6C3    72                    	ld	(hl),d		;sets reserved directory blks
                                				;allocation vector initialized, home disk
  E6C4    CD E3A1               	call	home
                                				;cdrmax = 3 (scans at least one directory record)
  E6C7    2A EDB3               	ld	hl,(cdrmaxa)
  E6CA    36 03                 	ld	(hl),3
  E6CC    23                    	inc	hl
  E6CD    36 00                 	ld	(hl),0
                                				;cdrmax = 0000
  E6CF    CD E5FE               	call	set$end$dir	;dcnt = enddir
                                				;read directory entries and check for allocated storage
  E6D2                          initial2:
  E6D2    0E FF                 	ld	c,true
  E6D4    CD E605               	call	read$dir
  E6D7    CD E5F5               	call	end$of$dir
  E6DA    C8                    	ret	z		;return if end of directory
                                				;not end of directory, valid entry?
  E6DB    CD E55E               	call	getdptra	;HL = buffa + dptr
  E6DE    3E E5                 	ld	a,empty
  E6E0    BE                    	cp	(hl)
  E6E1    CA E6D2               	jp	z,initial2	;go get another item
                                				;not empty, user code the same?
  E6E4    3A E341               	ld	a,(usrcode)
  E6E7    BE                    	cp	(hl)
  E6E8    C2 E6F6               	jp	nz,pdollar
                                				;same user code, check for '$' submit
  E6EB    23                    	inc	hl
  E6EC    7E                    	ld	a,(hl)		;first character
  E6ED    D6 24                 	sub	'$'		;dollar file?
  E6EF    C2 E6F6               	jp	nz,pdollar
                                				;dollar file found, mark in lret
  E6F2    3D                    	dec	a
  E6F3    32 E345               	ld	(lret),a	;lret = 255
  E6F6                          pdollar:			;now scan the disk map for allocated blocks
  E6F6    0E 01                 	ld	c,1		;set to allocated
  E6F8    CD E66B               	call	scandm
  E6FB    CD E58C               	call	setcdr		;set cdrmax to dcnt
  E6FE    C3 E6D2               	jp	initial2	;for another entry
                                
  E701                          copy$dirloc:			;copy directory location to lret following
                                				;delete, rename, ... ops
  E701    3A EDD4               	ld	a,(dirloc)
  E704    C3 E301               	jp	sta$ret
                                ;	ret
                                
  E707                          compext:			;compare extent# in A with that in C, return nonzero
                                				;if they do not match
  E707    C5                    	push	bc		;save C's original value
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-27


  E708    F5                    	push	af
  E709    3A EDC5               	ld	a,(extmsk)
  E70C    2F                    	cpl
  E70D    47                    	ld	b,a
                                				;B has negated form of extent mask
  E70E    79                    	ld	a,c
  E70F    A0                    	and	b
  E710    4F                    	ld	c,a		;low bits removed from C
  E711    F1                    	pop	af
  E712    A0                    	and	b		;low bits removed from A
  E713    91                    	sub	c
  E714    E6 1F                 	and	maxext		;set flags
  E716    C1                    	pop	bc		;restore original values
  E717    C9                    	ret
                                
  E718                          search:				;search for directory element of length C at info
  E718    3E FF                 	ld	a,0ffh
  E71A    32 EDD4               	ld	(dirloc),a	;changed if actually found
  E71D    21 EDD8               	ld	hl,searchl
  E720    71                    	ld	(hl),c		;searchl = C
  E721    2A E343               	ld	hl,(info)
  E724    22 EDD9               	ld	(searcha),hl	;searcha = info
  E727    CD E5FE               	call	set$end$dir	;dcnt = enddir
  E72A    CD E3A1               	call	home		;to start at the beginning
                                				;(drop through to searchn)
                                
  E72D                          searchn:			;search for the next directory element, assuming
                                				;a previous call on search which sets searcha and
                                				;searchl
  E72D    0E 00                 	ld	c,false
  E72F    CD E605               	call	read$dir	;read next dir element
  E732    CD E5F5               	call	end$of$dir
  E735    CA E794               	jp	z,search$fin	;skip to end if so
                                				;not end of directory, scan for match
  E738    2A EDD9               	ld	hl,(searcha)
  E73B    EB                    	ex	de,hl		;DE=beginning of user fcb
  E73C    1A                    	ld	a,(de)		;first character
  E73D    FE E5                 	cp	empty		;keep scanning if empty
  E73F    CA E74A               	jp	z,searchnext
                                				;not empty, may be end of logical directory
  E742    D5                    	push	de		;save search address
  E743    CD E57F               	call	compcdr		;past logical end?
  E746    D1                    	pop	de		;recall address
  E747    D2 E794               	jp	nc,search$fin	;artificial stop
  E74A                          searchnext:
  E74A    CD E55E               	call	getdptra	;HL = buffa+dptr
  E74D    3A EDD8               	ld	a,(searchl)
  E750    4F                    	ld	c,a		;length of search to c
  E751    06 00                 	ld	b,0		;b counts up, c counts down
  E753                          searchloop:
  E753    79                    	ld	a,c
  E754    B7                    	or	a
  E755    CA E783               	jp	z,endsearch
  E758    1A                    	ld	a,(de)
  E759    FE 3F                 	cp	'?'
  E75B    CA E77C               	jp	z,searchok	;? matches all
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-28


                                				;scan next character if not ubytes
  E75E    78                    	ld	a,b
  E75F    FE 0D                 	cp	ubytes
  E761    CA E77C               	jp	z,searchok
                                				;not the ubytes field, extent field?
  E764    FE 0C                 	cp	extnum		;may be extent field
  E766    1A                    	ld	a,(de)		;fcb character
  E767    CA E773               	jp	z,searchext	;skip to search extent
  E76A    96                    	sub	(hl)
  E76B    E6 7F                 	and	7fh		;mask-out flags/extent modulus
  E76D    C2 E72D               	jp	nz,searchn	;skip if not matched
  E770    C3 E77C               	jp	searchok	;matched character
                                
  E773                          searchext:			;A has fcb character
                                				;attempt an extent # match
  E773    C5                    	push	bc		;save counters
  E774    4E                    	ld	c,(hl)		;directory character to c
  E775    CD E707               	call	compext		;compare user/dir char
  E778    C1                    	pop	bc		;recall counters
  E779    C2 E72D               	jp	nz,searchn	;skip if no match
  E77C                          searchok:			;current character matches
  E77C    13                    	inc	de
  E77D    23                    	inc	hl
  E77E    04                    	inc	b
  E77F    0D                    	dec	c
  E780    C3 E753               	jp	searchloop
                                
  E783                          endsearch:			;entire name matches, return dir position
  E783    3A EDEA               	ld	a,(dcnt)
  E786    E6 03                 	and	dskmsk
  E788    32 E345               	ld	(lret),a
                                				;lret = low(dcnt) and 11b
  E78B    21 EDD4               	ld	hl,dirloc
  E78E    7E                    	ld	a,(hl)
  E78F    17                    	rla
  E790    D0                    	ret	nc		;dirloc=0ffh?
                                				;yes, change it to 0 to mark as found
  E791    AF                    	xor	a
  E792    77                    	ld	(hl),a		;dirloc=0
  E793    C9                    	ret
                                
  E794                          search$fin:			;end of directory, or empty name
  E794    CD E5FE               	call	set$end$dir	;may be artifical end
  E797    3E FF                 	ld	a,255
  E799    C3 E301               	jp	sta$ret
                                
  E79C                          delete:				;delete the currently addressed file
  E79C    CD E554               	call	check$write	;write protected?
  E79F    0E 0C                 	ld	c,extnum
  E7A1    CD E718               	call	search		;search through file type
  E7A4                          delete0:
                                				;loop while directory matches
  E7A4    CD E5F5               	call	end$of$dir
  E7A7    C8                    	ret	z		;stop if end
                                				;set each non zero disk map entry to 0
                                				;in the allocation vector
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-29


                                				;may be r/o file
  E7A8    CD E544               	call	check$rodir	;ro disk error if found
  E7AB    CD E55E               	call	getdptra	;HL=.buff(dptr)
  E7AE    36 E5                 	ld	(hl),empty
  E7B0    0E 00                 	ld	c,0
  E7B2    CD E66B               	call	scandm		;alloc elts set to 0
  E7B5    CD E5C6               	call	wrdir		;write the directory
  E7B8    CD E72D               	call	searchn		;to next element
  E7BB    C3 E7A4               	jp	delete0		;for another record
                                
  E7BE                          get$block:			;given allocation vector position BC, find the zero bit
                                				;closest to this position by searching left and right.
                                				;if found, set the bit to one and return the bit position
                                				;in hl.  if not found (i.e., we pass 0 on the left, or
                                				;maxall on the right), return 0000 in hl
  E7BE    50                    	ld	d,b
  E7BF    59                    	ld	e,c		;copy of starting position to de
  E7C0                          lefttst:
  E7C0    79                    	ld	a,c
  E7C1    B0                    	or	b
  E7C2    CA E7D1               	jp	z,righttst	;skip if left=0000
                                				;left not at position zero, bit zero?
  E7C5    0B                    	dec	bc
  E7C6    D5                    	push	de
  E7C7    C5                    	push	bc		;left,right pushed
  E7C8    CD E635               	call	getallocbit
  E7CB    1F                    	rra
  E7CC    D2 E7EC               	jp	nc,retblock	;return block number if zero
                                				;bit is one, so try the right
  E7CF    C1                    	pop	bc
  E7D0    D1                    	pop	de		;left, right restored
  E7D1                          righttst:
  E7D1    2A EDC6               	ld	hl,(maxall)	;value of maximum allocation#
  E7D4    7B                    	ld	a,e
  E7D5    95                    	sub	l
  E7D6    7A                    	ld	a,d
  E7D7    9C                    	sbc	a,h		;right=maxall?
  E7D8    D2 E7F4               	jp	nc,retblock0	;return block 0000 if so
  E7DB    13                    	inc	de
  E7DC    C5                    	push	bc
  E7DD    D5                    	push	de		;left, right pushed
  E7DE    42                    	ld	b,d
  E7DF    4B                    	ld	c,e		;ready right for call
  E7E0    CD E635               	call	getallocbit
  E7E3    1F                    	rra
  E7E4    D2 E7EC               	jp	nc,retblock	;return block number if zero
  E7E7    D1                    	pop	de
  E7E8    C1                    	pop	bc		;restore left and right pointers
  E7E9    C3 E7C0               	jp	lefttst		;for another attempt
  E7EC                          retblock:
  E7EC    17                    	rla
  E7ED    3C                    	inc	a		;bit back into position and set to 1
                                				;d contains the number of shifts required to reposition
  E7EE    CD E664               	call	rotr		;move bit back to position and store
  E7F1    E1                    	pop	hl
  E7F2    D1                    	pop	de		;HL returned value, DE discarded
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-30


  E7F3    C9                    	ret
                                
  E7F4                          retblock0:			;cannot find an available bit, return 0000
  E7F4    79                    	ld	a,c
  E7F5    B0                    	or	b
  E7F6    C2 E7C0               	jp	nz,lefttst	;also at beginning
  E7F9    21 0000               	ld	hl,0000h
  E7FC    C9                    	ret
                                
  E7FD                          copy$fcb:			;copy the entire file control block
  E7FD    0E 00                 	ld	c,0
  E7FF    1E 20                 	ld	e,fcblen	;start at 0, to fcblen-1
                                ;	jp	copy$dir
                                
  E801                          copy$dir:			;copy fcb information starting at C for E bytes
                                				;into the currently addressed directory entry
  E801    D5                    	push	de		;save length for later
  E802    06 00                 	ld	b,0		;double index to BC
  E804    2A E343               	ld	hl,(info)	;HL = source for data
  E807    09                    	add	hl,bc
  E808    EB                    	ex	de,hl		;DE=.fcb(C), source for copy
  E809    CD E55E               	call	getdptra	;HL=.buff(dptr), destination
  E80C    C1                    	pop	bc		;DE=source, HL=dest, C=length
  E80D    CD E34F               	call	move		;data moved
  E810                          seek$copy:			;enter from close to seek and copy current element
  E810    CD E3C3               	call	seek$dir	;to the directory element
  E813    C3 E5C6               	jp	wrdir		;write the directory element
                                ;	ret
  E816                          rename:				;rename the file described by the first half of
                                				;the currently addressed file control block. the
                                				;new name is contained in the last half of the
                                				;currently addressed file conrol block.  the file
                                				;name and type are changed, but the reel number
                                				;is ignored.  the user number is identical
  E816    CD E554               	call	check$write	;may be write protected
                                				;search up to the extent field
  E819    0E 0C                 	ld	c,extnum
  E81B    CD E718               	call	search
                                				;copy position 0
  E81E    2A E343               	ld	hl,(info)
  E821    7E                    	ld	a,(hl)		;HL=.fcb(0), A=fcb(0)
  E822    11 0010               	ld	de,dskmap
  E825    19                    	add	hl,de		;HL=.fcb(dskmap)
  E826    77                    	ld	(hl),a		;fcb(dskmap)=fcb(0)
                                				;assume the same disk drive for new named file
  E827                          rename0:
  E827    CD E5F5               	call	end$of$dir
  E82A    C8                    	ret	z		;stop at end of dir
                                				;not end of directory, rename next element
  E82B    CD E544               	call	check$rodir	;may be read-only file
  E82E    0E 10                 	ld	c,dskmap
  E830    1E 0C                 	ld	e,extnum
  E832    CD E801               	call	copy$dir
                                				;element renamed, move to next
  E835    CD E72D               	call	searchn
  E838    C3 E827               	jp	rename0
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-31


                                
  E83B                          indicators:			;set file indicators for current fcb
  E83B    0E 0C                 	ld	c,extnum
  E83D    CD E718               	call	search		;through file type
  E840    CD E5F5               indic0:	call	end$of$dir
  E843    C8                    	ret	z		;stop at end of dir
                                				;not end of directory, continue to change
  E844    0E 00                 	ld	c,0
  E846    1E 0C                 	ld	e,extnum	;copy name
  E848    CD E801               	call	copy$dir
  E84B    CD E72D               	call	searchn
  E84E    C3 E840               	jp	indic0
                                
  E851                          open:				;search for the directory entry, copy to fcb
  E851    0E 0F                 	ld	c,namlen
  E853    CD E718               	call	search
  E856    CD E5F5               	call	end$of$dir
  E859    C8                    	ret	z		;return with lret=255 if end
                                				;not end of directory, copy fcb information
  E85A                          open$copy:			;(referenced below to copy fcb info)
  E85A    CD E4A6               	call	getexta
  E85D    7E                    	ld	a,(hl)
  E85E    F5                    	push	af
  E85F    E5                    	push	hl		;save extent#
  E860    CD E55E               	call	getdptra
  E863    EB                    	ex	de,hl		;DE = .buff(dptr)
  E864    2A E343               	ld	hl,(info)	;HL=.fcb(0)
  E867    0E 20                 	ld	c,nxtrec	;length of move operation
  E869    D5                    	push	de		;save .buff(dptr)
  E86A    CD E34F               	call	move		;from .buff(dptr) to .fcb(0)
                                				;note that entire fcb is copied, including indicators
  E86D    CD E578               	call	setfwf		;sets file write flag
  E870    D1                    	pop	de
  E871    21 000C               	ld	hl,extnum
  E874    19                    	add	hl,de		;HL=.buff(dptr+extnum)
  E875    4E                    	ld	c,(hl)		;C = directory extent number
  E876    21 000F               	ld	hl,reccnt
  E879    19                    	add	hl,de		;HL=.buff(dptr+reccnt)
  E87A    46                    	ld	b,(hl)		;B holds directory record count
  E87B    E1                    	pop	hl
  E87C    F1                    	pop	af
  E87D    77                    	ld	(hl),a		;restore extent number
                                				;HL = .user extent#, B = dir rec cnt, C = dir extent#
                                				;if user ext < dir ext then user := 128 records
                                				;if user ext = dir ext then user := dir records
                                				;if user ext > dir ext then user := 0 records
  E87E    79                    	ld	a,c
  E87F    BE                    	cp	(hl)
  E880    78                    	ld	a,b		;ready dir reccnt
  E881    CA E88B               	jp	z,open$rcnt	;if same, user gets dir reccnt
  E884    3E 00                 	ld	a,0
  E886    DA E88B               	jp	c,open$rcnt	;user is larger
  E889    3E 80                 	ld	a,128		;directory is larger
  E88B                          open$rcnt:			;A has record count to fill
  E88B    2A E343               	ld	hl,(info)
  E88E    11 000F               	ld	de,reccnt
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-32


  E891    19                    	add	hl,de
  E892    77                    	ld	(hl),a
  E893    C9                    	ret
                                
  E894                          mergezero:			;HL = .fcb1(i), DE = .fcb2(i),
                                				;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
  E894    7E                    	ld	a,(hl)
  E895    23                    	inc	hl
  E896    B6                    	or	(hl)
  E897    2B                    	dec	hl
  E898    C0                    	ret	nz		;return if = 0000
  E899    1A                    	ld	a,(de)
  E89A    77                    	ld	(hl),a
  E89B    13                    	inc	de
  E89C    23                    	inc	hl		;low byte copied
  E89D    1A                    	ld	a,(de)
  E89E    77                    	ld	(hl),a
  E89F    1B                    	dec	de
  E8A0    2B                    	dec	hl		;back to input form
  E8A1    C9                    	ret
                                
  E8A2                          close:				;locate the directory element and re-write it
  E8A2    AF                    	xor	a
  E8A3    32 E345               	ld	(lret),a
  E8A6    32 EDEA               	ld	(dcnt),a
  E8A9    32 EDEB               	ld	(dcnt+1),a
  E8AC    CD E51E               	call	nowrite
  E8AF    C0                    	ret	nz		;skip close if r/o disk
                                				;check file write flag - 0 indicates written
  E8B0    CD E569               	call	getmodnum	;fcb(modnum) in A
  E8B3    E6 80                 	and	fwfmsk
  E8B5    C0                    	ret	nz		;return if bit remains set
  E8B6    0E 0F                 	ld	c,namlen
  E8B8    CD E718               	call	search		;locate file
  E8BB    CD E5F5               	call	end$of$dir
  E8BE    C8                    	ret	z		;return if not found
                                				;merge the disk map at info with that at buff(dptr)
  E8BF    01 0010               	ld	bc,dskmap
  E8C2    CD E55E               	call	getdptra
  E8C5    09                    	add	hl,bc
  E8C6    EB                    	ex	de,hl		;DE is .buff(dptr+16)
  E8C7    2A E343               	ld	hl,(info)
  E8CA    09                    	add	hl,bc		;DE=.buff(dptr+16), HL=.fcb(16)
  E8CB    0E 10                 	ld	c,fcblen-dskmap;length of single byte dm
  E8CD    3A EDDD               merge0:	ld	a,(single)
  E8D0    B7                    	or	a
  E8D1    CA E8E8               	jp	z,merged	;skip to double
                                				;this is a single byte map
                                				;if fcb(i) = 0 then fcb(i) = buff(i)
                                				;if buff(i) = 0 then buff(i) = fcb(i)
                                				;if fcb(i) <> buff(i) then error
  E8D4    7E                    	ld	a,(hl)
  E8D5    B7                    	or	a
  E8D6    1A                    	ld	a,(de)
  E8D7    C2 E8DB               	jp	nz,fcbnzero
                                				;fcb(i) = 0
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-33


  E8DA    77                    	ld	(hl),a		;fcb(i) = buff(i)
  E8DB                          fcbnzero:
  E8DB    B7                    	or	a
  E8DC    C2 E8E1               	jp	nz,buffnzero
                                				;buff(i) = 0
  E8DF    7E                    	ld	a,(hl)
  E8E0    12                    	ld	(de),a		;buff(i)=fcb(i)
  E8E1                          buffnzero:
  E8E1    BE                    	cp	(hl)
  E8E2    C2 E91F               	jp	nz,mergerr	;fcb(i) = buff(i)?
  E8E5    C3 E8FD               	jp	dmset		;if merge ok
                                
  E8E8                          merged:				;this is a double byte merge operation
  E8E8    CD E894               	call	mergezero	;buff = fcb if buff 0000
  E8EB    EB                    	ex	de,hl
  E8EC    CD E894               	call	mergezero
  E8EF    EB                    	ex	de,hl		;fcb = buff if fcb 0000
                                				;they should be identical at this point
  E8F0    1A                    	ld	a,(de)
  E8F1    BE                    	cp	(hl)
  E8F2    C2 E91F               	jp	nz,mergerr	;low same?
  E8F5    13                    	inc	de
  E8F6    23                    	inc	hl		;to high byte
  E8F7    1A                    	ld	a,(de)
  E8F8    BE                    	cp	(hl)
  E8F9    C2 E91F               	jp	nz,mergerr	;high same?
                                				;merge operation ok for this pair
  E8FC    0D                    	dec	c		;extra count for double byte
  E8FD    13                    dmset:	inc	de
  E8FE    23                    	inc	hl		;to next byte position
  E8FF    0D                    	dec	c
  E900    C2 E8CD               	jp	nz,merge0	;for more
                                				;end of disk map merge, check record count
                                				;DE = .buff(dptr)+32, HL = .fcb(32)
  E903    01 FFEC               	ld	bc,-(fcblen-extnum)
  E906    09                    	add	hl,bc
  E907    EB                    	ex	de,hl
  E908    09                    	add	hl,bc
                                				;DE = .fcb(extnum), HL = .buff(dptr+extnum)
  E909    1A                    	ld	a,(de)		;current user extent number
                                				;if fcb(ext) >= buff(fcb) then
                                				;buff(ext) := fcb(ext), buff(rec) := fcb(rec)
  E90A    BE                    	cp	(hl)
  E90B    DA E917               	jp	c,endmerge
                                				;fcb extent number >= dir extent number
  E90E    77                    	ld	(hl),a		;buff(ext) = fcb(ext)
                                				;update directory record count field
  E90F    01 0003               	ld	bc,reccnt-extnum
  E912    09                    	add	hl,bc
  E913    EB                    	ex	de,hl
  E914    09                    	add	hl,bc
                                				;DE=.buff(reccnt), HL=.fcb(reccnt)
  E915    7E                    	ld	a,(hl)
  E916    12                    	ld	(de),a		;buff(reccnt)=fcb(reccnt)
  E917                          endmerge:
  E917    3E FF                 	ld	a,true
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-34


  E919    32 EDD2               	ld	(fcb$copied),a	;mark as copied
  E91C    C3 E810               	jp	seek$copy	;ok to "wrdir" here - 1.4 compat
                                				;		ret
                                
  E91F                          mergerr:			;elements did not merge correctly
  E91F    21 E345               	ld	hl,lret
  E922    35                    	dec	(hl)		;=255 non zero flag set
  E923    C9                    	ret
                                
  E924                          make:				;create a new file by creating a directory entry
                                				;then opening the file
  E924    CD E554               	call	check$write	;may be write protected
  E927    2A E343               	ld	hl,(info)
  E92A    E5                    	push	hl		;save fcb address, look for e5
  E92B    21 EDAC               	ld	hl,efcb
  E92E    22 E343               	ld	(info),hl	;info = .empty
  E931    0E 01                 	ld	c,1
  E933    CD E718               	call	search		;length 1 match on empty entry
  E936    CD E5F5               	call	end$of$dir	;zero flag set if no space
  E939    E1                    	pop	hl		;recall info address
  E93A    22 E343               	ld	(info),hl	;in case we return here
  E93D    C8                    	ret	z		;return with error condition 255 if not found
  E93E    EB                    	ex	de,hl		;DE = info address
                                				;clear the remainder of the fcb
  E93F    21 000F               	ld	hl,namlen
  E942    19                    	add	hl,de		;HL=.fcb(namlen)
  E943    0E 11                 	ld	c,fcblen-namlen	;number of bytes to fill
  E945    AF                    	xor	a		;clear accumulator to 00 for fill
  E946    77                    make0:	ld	(hl),a
  E947    23                    	inc	hl
  E948    0D                    	dec	c
  E949    C2 E946               	jp	nz,make0
  E94C    21 000D               	ld	hl,ubytes
  E94F    19                    	add	hl,de		;HL = .fcb(ubytes)
  E950    77                    	ld	(hl),a		;fcb(ubytes) = 0
  E951    CD E58C               	call	setcdr		;may have extended the directory
                                				;now copy entry to the directory
  E954    CD E7FD               	call	copy$fcb
                                				;and set the file write flag to "1"
  E957    C3 E578               	jp	setfwf
                                ;	ret
                                
  E95A                          open$reel:			;close the current extent, and open the next one
                                				;if possible.  RMF is true if in read mode
  E95A    AF                    	xor	a
  E95B    32 EDD2               	ld	(fcb$copied),a	;set true if actually copied
  E95E    CD E8A2               	call	close		;close current extent
                                				;lret remains at enddir if we cannot open the next ext
  E961    CD E5F5               	call	end$of$dir
  E964    C8                    	ret	z		;return if end
                                				;increment extent number
  E965    2A E343               	ld	hl,(info)
  E968    01 000C               	ld	bc,extnum
  E96B    09                    	add	hl,bc		;HL=.fcb(extnum)
  E96C    7E                    	ld	a,(hl)
  E96D    3C                    	inc	a
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-35


  E96E    E6 1F                 	and	maxext
  E970    77                    	ld	(hl),a		;fcb(extnum)=++1
  E971    CA E983               	jp	z,open$mod	;move to next module if zero
                                				;may be in the same extent group
  E974    47                    	ld	b,a
  E975    3A EDC5               	ld	a,(extmsk)
  E978    A0                    	and	b
                                				;if result is zero, then not in the same group
  E979    21 EDD2               	ld	hl,fcb$copied	;true if the fcb was copied to directory
  E97C    A6                    	and	(hl)		;produces a 00 in accumulator if not written
  E97D    CA E98E               	jp	z,open$reel0	;go to next physical extent
                                				;result is non zero, so we must be in same logical ext
  E980    C3 E9AC               	jp	open$reel1	;to copy fcb information
  E983                          open$mod:			;extent number overflow, go to next module
  E983    01 0002               	ld	bc,modnum-extnum
  E986    09                    	add	hl,bc		;HL=.fcb(modnum)
  E987    34                    	inc	(hl)		;fcb(modnum)=++1
                                				;module number incremented, check for overflow
  E988    7E                    	ld	a,(hl)
  E989    E6 0F                 	and	maxmod		;mask high order bits
  E98B    CA E9B6               	jp	z,open$r$err	;cannot overflow to zero
                                				;otherwise, ok to continue with new module
  E98E                          open$reel0:
  E98E    0E 0F                 	ld	c,namlen
  E990    CD E718               	call	search		;next extent found?
  E993    CD E5F5               	call	end$of$dir
  E996    C2 E9AC               	jp	nz,open$reel1
                                				;end of file encountered
  E999    3A EDD3               	ld	a,(rmf)
  E99C    3C                    	inc	a		;0ffh becomes 00 if read
  E99D    CA E9B6               	jp	z,open$r$err	;sets lret = 1
                                				;try to extend the current file
  E9A0    CD E924               	call	make
                                				;cannot be end of directory
  E9A3    CD E5F5               	call	end$of$dir
  E9A6    CA E9B6               	jp	z,open$r$err	;with lret = 1
  E9A9    C3 E9AF               	jp	open$reel2
                                
  E9AC                          open$reel1:			;not end of file, open
  E9AC    CD E85A               	call	open$copy
  E9AF                          open$reel2:
  E9AF    CD E4BB               	call	getfcb		;set parameters
  E9B2    AF                    	xor	a
  E9B3    C3 E301               	jp	sta$ret		;lret = 0
                                ;	ret 			;with lret = 0
                                
  E9B6                          open$r$err:			;cannot move to next extent of this file
  E9B6    CD E305               	call	setlret1	;lret = 1
  E9B9    C3 E578               	jp	setfwf		;ensure that it will not be closed
                                ;	ret
                                
  E9BC                          seqdiskread:			;sequential disk read operation
  E9BC    3E 01                 	ld	a,1
  E9BE    32 EDD5               	ld	(seqio),a
                                				;drop through to diskread
                                
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-36


  E9C1                          diskread:			;(may enter from seqdiskread)
  E9C1    3E FF                 	ld	a,true
  E9C3    32 EDD3               	ld	(rmf),a		;read mode flag = true (open$reel)
                                				;read the next record from the current fcb
  E9C6    CD E4BB               	call	getfcb		;sets parameters for the read
  E9C9    3A EDE3               	ld	a,(vrecord)
  E9CC    21 EDE1               	ld	hl,rcount
  E9CF    BE                    	cp	(hl)		;vrecord-rcount
                                				;skip if rcount > vrecord
  E9D0    DA E9E6               	jp	c,recordok
                                				;not enough records in the extent
                                				;record count must be 128 to continue
  E9D3    FE 80                 	cp	128		;vrecord = 128?
  E9D5    C2 E9FB               	jp	nz,diskeof	;skip if vrecord<>128
  E9D8    CD E95A               	call	open$reel	;go to next extent if so
  E9DB    AF                    	xor	a
  E9DC    32 EDE3               	ld	(vrecord),a	;vrecord=00
                                				;now check for open ok
  E9DF    3A E345               	ld	a,(lret)
  E9E2    B7                    	or	a
  E9E3    C2 E9FB               	jp	nz,diskeof	;stop at eof
  E9E6                          recordok:			;arrive with fcb addressing a record to read
  E9E6    CD E477               	call	index
                                				;error 2 if reading unwritten data
                                				;(returns 1 to be compatible with 1.4)
  E9E9    CD E484               	call	allocated	;arecord=0000?
  E9EC    CA E9FB               	jp	z,diskeof
                                				;record has been allocated, read it
  E9EF    CD E48A               	call	atran		;arecord now a disk address
  E9F2    CD E3D1               	call	seek		;to proper track,sector
  E9F5    CD E3B2               	call	rdbuff		;to dma address
  E9F8    C3 E4D2               	jp	setfcb		;replace parameter
                                ;	ret
                                
  E9FB                          diskeof:
  E9FB    C3 E305               	jp	setlret1	;lret = 1
                                ;	ret
                                
  E9FE                          seqdiskwrite:			;sequential disk write
  E9FE    3E 01                 	ld	a,1
  EA00    32 EDD5               	ld	(seqio),a
                                				;drop through to diskwrite
                                
  EA03                          diskwrite:			;(may enter here from seqdiskwrite above)
  EA03    3E 00                 	ld	a,false
  EA05    32 EDD3               	ld	(rmf),a		;read mode flag
                                				;write record to currently selected file
  EA08    CD E554               	call	check$write	;in case write protected
  EA0B    2A E343               	ld	hl,(info)	;HL = .fcb(0)
  EA0E    CD E547               	call	check$rofile	;may be a read-only file
  EA11    CD E4BB               	call	getfcb		;to set local parameters
  EA14    3A EDE3               	ld	a,(vrecord)
  EA17    FE 80                 	cp	lstrec+1	;vrecord-128
                                				;skip if vrecord > lstrec
                                				;vrecord = 128, cannot open next extent
  EA19    D2 E305               	jp	nc,setlret1	;lret=1
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-37


  EA1C                          diskwr0:			;can write the next record, so continue
  EA1C    CD E477               	call	index
  EA1F    CD E484               	call	allocated
  EA22    0E 00                 	ld	c,0		;marked as normal write operation for wrbuff
  EA24    C2 EA6E               	jp	nz,diskwr1
                                				;not allocated
                                				;the argument to getblock is the starting
                                				;position for the disk search, and should be
                                				;the last allocated block for this file, or
                                				;the value 0 if no space has been allocated
  EA27    CD E43E               	call	dm$position
  EA2A    32 EDD7               	ld	(dminx),a	;save for later
  EA2D    01 0000               	ld	bc,0000h	;may use block zero
  EA30    B7                    	or	a
  EA31    CA EA3B               	jp	z,nopblock	;skip if no previous block
                                				;previous block exists at A
  EA34    4F                    	ld	c,a
  EA35    0B                    	dec	bc		;previous block # in BC
  EA36    CD E45E               	call	getdm		;previous block # to HL
  EA39    44                    	ld	b,h
  EA3A    4D                    	ld	c,l		;BC=prev block#
  EA3B                          nopblock:			;BC = 0000, or previous block #
  EA3B    CD E7BE               	call	get$block	;block # to HL
                                				;arrive here with block# or zero
  EA3E    7D                    	ld	a,l
  EA3F    B4                    	or	h
  EA40    C2 EA48               	jp	nz,blockok
                                				;cannot find a block to allocate
  EA43    3E 02                 	ld	a,2
  EA45    C3 E301               	jp	sta$ret		;lret=2
                                
  EA48                          blockok:			;allocated block number is in HL
  EA48    22 EDE5               	ld	(arecord),hl
  EA4B    EB                    	ex	de,hl		;block number to DE
  EA4C    2A E343               	ld	hl,(info)
  EA4F    01 0010               	ld	bc,dskmap
  EA52    09                    	add	hl,bc		;HL=.fcb(dskmap)
  EA53    3A EDDD               	ld	a,(single)
  EA56    B7                    	or	a		;set flags for single byte dm
  EA57    3A EDD7               	ld	a,(dminx)	;recall dm index
  EA5A    CA EA64               	jp	z,allocwd	;skip if allocating word
                                				;allocating a byte value
  EA5D    CD E564               	call	addh
  EA60    73                    	ld	(hl),e		;single byte alloc
  EA61    C3 EA6C               	jp	diskwru		;to continue
                                
  EA64                          allocwd:			;allocate a word value
  EA64    4F                    	ld	c,a
  EA65    06 00                 	ld	b,0		;double(dminx)
  EA67    09                    	add	hl,bc
  EA68    09                    	add	hl,bc		;HL=.fcb(dminx*2)
  EA69    73                    	ld	(hl),e
  EA6A    23                    	inc	hl
  EA6B    72                    	ld	(hl),d		;double wd
  EA6C                          diskwru:			;disk write to previously unallocated block
  EA6C    0E 02                 	ld	c,2		;marked as unallocated write
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-38


  EA6E                          diskwr1:			;continue the write operation of no allocation error
                                				;C = 0 if normal write, 2 if to prev unalloc block
  EA6E    3A E345               	ld	a,(lret)
  EA71    B7                    	or	a
  EA72    C0                    	ret	nz		;stop if non zero returned value
  EA73    C5                    	push	bc		;save write flag
  EA74    CD E48A               	call	atran		;arecord set
  EA77    3A EDD5               	ld	a,(seqio)
  EA7A    3D                    	dec	a
  EA7B    3D                    	dec	a
  EA7C    C2 EABB               	jp	nz,diskwr11
  EA7F    C1                    	pop	bc
  EA80    C5                    	push	bc
  EA81    79                    	ld	a,c
  EA82    3D                    	dec	a
  EA83    3D                    	dec	a
  EA84    C2 EABB               	jp	nz,diskwr11	;old allocation
  EA87    E5                    	push	hl		;arecord in hl ret from atran
  EA88    2A EDB9               	ld	hl,(buffa)
  EA8B    57                    	ld	d,a		;zero buffa & fill
  EA8C    77                    fill0:	ld	(hl),a
  EA8D    23                    	inc	hl
  EA8E    14                    	inc	d
  EA8F    F2 EA8C               	jp	p,fill0
  EA92    CD E5E0               	call	setdir
  EA95    2A EDE7               	ld	hl,(arecord1)
  EA98    0E 02                 	ld	c,2
  EA9A    22 EDE5               fill1:	ld	(arecord),hl
  EA9D    C5                    	push	bc
  EA9E    CD E3D1               	call	seek
  EAA1    C1                    	pop	bc
  EAA2    CD E3B8               	call	wrbuff		;write fill record
  EAA5    2A EDE5               	ld	hl,(arecord)	;restore last record
  EAA8    0E 00                 	ld	c,0		;change  allocate flag
  EAAA    3A EDC4               	ld	a,(blkmsk)
  EAAD    47                    	ld	b,a
  EAAE    A5                    	and	l
  EAAF    B8                    	cp	b
  EAB0    23                    	inc	hl
  EAB1    C2 EA9A               	jp	nz,fill1	;cont until cluster is zeroed
  EAB4    E1                    	pop	hl
  EAB5    22 EDE5               	ld	(arecord),hl
  EAB8    CD E5DA               	call	setdata
  EABB                          diskwr11:
  EABB    CD E3D1               	call	seek		;to proper file position
  EABE    C1                    	pop	bc
  EABF    C5                    	push	bc		;restore/save write flag (C=2 if new block)
  EAC0    CD E3B8               	call	wrbuff		;written to disk
  EAC3    C1                    	pop	bc		;C = 2 if a new block was allocated, 0 if not
                                				;increment record count if rcount<=vrecord
  EAC4    3A EDE3               	ld	a,(vrecord)
  EAC7    21 EDE1               	ld	hl,rcount
  EACA    BE                    	cp	(hl)		;vrecord-rcount
  EACB    DA EAD2               	jp	c,diskwr2
                                				;rcount <= vrecord
  EACE    77                    	ld	(hl),a
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-39


  EACF    34                    	inc	(hl)		;rcount = vrecord+1
  EAD0    0E 02                 	ld	c,2		;mark as record count incremented
  EAD2                          diskwr2:			;A has vrecord, C=2 if new block or new record#
  EAD2    0D                    	dec	c
  EAD3    0D                    	dec	c
  EAD4    C2 EADF               	jp	nz,noupdate
  EAD7    F5                    	push	af		;save vrecord value
  EAD8    CD E569               	call	getmodnum	;HL=.fcb(modnum), A=fcb(modnum)
                                				;reset the file write flag to mark as written fcb
  EADB    E6 7F                 	and	(not fwfmsk) and 0ffh;bit reset
  EADD    77                    	ld	(hl),a		;fcb(modnum) = fcb(modnum) and 7fh
  EADE    F1                    	pop	af		;restore vrecord
  EADF                          noupdate:			;check for end of extent, if found attempt to open
                                				;next extent in preparation for next write
  EADF    FE 7F                 	cp	lstrec		;vrecord=lstrec?
  EAE1    C2 EB00               	jp	nz,diskwr3	;skip if not
                                				;may be random access write, if so we are done
                                				;change next
  EAE4    3A EDD5               	ld	a,(seqio)
  EAE7    FE 01                 	cp	1
  EAE9    C2 EB00               	jp	nz,diskwr3	;skip next extent open op
                                				;update current fcb before going to next extent
  EAEC    CD E4D2               	call	setfcb
  EAEF    CD E95A               	call	open$reel	;rmf=false
                                				;vrecord remains at lstrec causing eof if
                                				;no more directory space is available
  EAF2    21 E345               	ld	hl,lret
  EAF5    7E                    	ld	a,(hl)
  EAF6    B7                    	or	a
  EAF7    C2 EAFE               	jp	nz,nospace
                                				;space available, set vrecord=255
  EAFA    3D                    	dec	a
  EAFB    32 EDE3               	ld	(vrecord),a	;goes to 00 next time
  EAFE                          nospace:
  EAFE    36 00                 	ld	(hl),0		;lret = 00 for returned value
  EB00                          diskwr3:
  EB00    C3 E4D2               	jp	setfcb		;replace parameters
                                ;	ret
                                
  EB03                          rseek:				;random access seek operation, C=0ffh if read mode
                                				;fcb is assumed to address an active file control block
                                				;(modnum has been set to 1100$0000b if previous bad seek)
  EB03    AF                    	xor	a
  EB04    32 EDD5               	ld	(seqio),a	;marked as random access operation
  EB07    C5                    rseek1:	push	bc		;save r/w flag
  EB08    2A E343               	ld	hl,(info)
  EB0B    EB                    	ex	de,hl		;DE will hold base of fcb
  EB0C    21 0021               	ld	hl,ranrec
  EB0F    19                    	add	hl,de		;HL=.fcb(ranrec)
  EB10    7E                    	ld	a,(hl)
  EB11    E6 7F                 	and	7fh
  EB13    F5                    	push	af		;record number
  EB14    7E                    	ld	a,(hl)
  EB15    17                    	rla			;cy=lsb of extent#
  EB16    23                    	inc	hl
  EB17    7E                    	ld	a,(hl)
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-40


  EB18    17                    	rla
  EB19    E6 1F                 	and	11111b		;A=ext#
  EB1B    4F                    	ld	c,a		;C holds extent number, record stacked
  EB1C    7E                    	ld	a,(hl)
  EB1D    1F                    	rra
  EB1E    1F                    	rra
  EB1F    1F                    	rra
  EB20    1F                    	rra
  EB21    E6 0F                 	and	1111b		;mod#
  EB23    47                    	ld	b,a		;B holds module#, C holds ext#
  EB24    F1                    	pop	af		;recall sought record #
                                				;check to insure that high byte of ran rec = 00
  EB25    23                    	inc	hl
  EB26    6E                    	ld	l,(hl)		;l=high byte (must be 00)
  EB27    2C                    	inc	l
  EB28    2D                    	dec	l
  EB29    2E 06                 	ld	l,6		;zero flag, l=6
                                				;produce error 6, seek past physical eod
  EB2B    C2 EB8B               	jp	nz,seekerr
                                				;otherwise, high byte = 0, A = sought record
  EB2E    21 0020               	ld	hl,nxtrec
  EB31    19                    	add	hl,de		;HL = .fcb(nxtrec)
  EB32    77                    	ld	(hl),a		;sought rec# stored away
                                				;arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
                                				;the r/w flag is still stacked.  compare fcb values
  EB33    21 000C               	ld	hl,extnum
  EB36    19                    	add	hl,de
  EB37    79                    	ld	a,c		;A=seek ext#
  EB38    96                    	sub	(hl)
  EB39    C2 EB47               	jp	nz,ranclose	;tests for = extents
                                				;extents match, check mod#
  EB3C    21 000E               	ld	hl,modnum
  EB3F    19                    	add	hl,de
  EB40    78                    	ld	a,b		;B=seek mod#
                                				;could be overflow at eof, producing module#
                                				;of 90H or 10H, so compare all but fwf
  EB41    96                    	sub	(hl)
  EB42    E6 7F                 	and	7fh
  EB44    CA EB7F               	jp	z,seekok	;same?
  EB47                          ranclose:
  EB47    C5                    	push	bc
  EB48    D5                    	push	de		;save seek mod#,ext#, .fcb
  EB49    CD E8A2               	call	close		;current extent closed
  EB4C    D1                    	pop	de
  EB4D    C1                    	pop	bc		;recall parameters and fill
  EB4E    2E 03                 	ld	l,3		;cannot close error #3
  EB50    3A E345               	ld	a,(lret)
  EB53    3C                    	inc	a
  EB54    CA EB84               	jp	z,badseek
  EB57    21 000C               	ld	hl,extnum
  EB5A    19                    	add	hl,de
  EB5B    71                    	ld	(hl),c		;fcb(extnum)=ext#
  EB5C    21 000E               	ld	hl,modnum
  EB5F    19                    	add	hl,de
  EB60    70                    	ld	(hl),b		;fcb(modnum)=mod#
  EB61    CD E851               	call	open		;is the file present?
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-41


  EB64    3A E345               	ld	a,(lret)
  EB67    3C                    	inc	a
  EB68    C2 EB7F               	jp	nz,seekok	;open successful?
                                				;cannot open the file, read mode?
  EB6B    C1                    	pop	bc		;r/w flag to c (=0ffh if read)
  EB6C    C5                    	push	bc		;everyone expects this item stacked
  EB6D    2E 04                 	ld	l,4		;seek to unwritten extent #4
  EB6F    0C                    	inc	c		;becomes 00 if read operation
  EB70    CA EB84               	jp	z,badseek	;skip to error if read operation
                                				;write operation, make new extent
  EB73    CD E924               	call	make
  EB76    2E 05                 	ld	l,5		;cannot create new extent #5
  EB78    3A E345               	ld	a,(lret)
  EB7B    3C                    	inc	a
  EB7C    CA EB84               	jp	z,badseek	;no dir space
                                				;file make operation successful
  EB7F                          seekok:
  EB7F    C1                    	pop	bc		;discard r/w flag
  EB80    AF                    	xor	a
  EB81    C3 E301               	jp	sta$ret		;with zero set
  EB84                          badseek:			;fcb no longer contains a valid fcb, mark
                                				;with 1100$000b in modnum field so that it
                                				;appears as overflow with file write flag set
  EB84    E5                    	push	hl		;save error flag
  EB85    CD E569               	call	getmodnum	;HL = .modnum
  EB88    36 C0                 	ld	(hl),11000000b
  EB8A    E1                    	pop	hl		;and drop through
  EB8B                          seekerr:
  EB8B    C1                    	pop	bc		;discard r/w flag
  EB8C    7D                    	ld	a,l
  EB8D    32 E345               	ld	(lret),a	;lret=#, nonzero
                                				;setfwf returns non-zero accumulator for err
  EB90    C3 E578               	jp	setfwf		;flag set, so subsequent close ok
                                ;	ret
                                
  EB93                          randiskread:			;random disk read operation
  EB93    0E FF                 	ld	c,true		;marked as read operation
  EB95    CD EB03               	call	rseek
  EB98    CC E9C1               	call	z,diskread	;if seek successful
  EB9B    C9                    	ret
                                
  EB9C                          randiskwrite:			;random disk write operation
  EB9C    0E 00                 	ld	c,false		;marked as write operation
  EB9E    CD EB03               	call	rseek
  EBA1    CC EA03               	call	z,diskwrite	;if seek successful
  EBA4    C9                    	ret
                                
  EBA5                          compute$rr:			;compute random record position for getfilesize/setrandom
  EBA5    EB                    	ex	de,hl
  EBA6    19                    	add	hl,de
                                				;DE=.buf(dptr) or .fcb(0), HL = .f(nxtrec/reccnt)
  EBA7    4E                    	ld	c,(hl)
  EBA8    06 00                 	ld	b,0		;BC = 0000 0000 ?rrr rrrr
  EBAA    21 000C               	ld	hl,extnum
  EBAD    19                    	add	hl,de
  EBAE    7E                    	ld	a,(hl)
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-42


  EBAF    0F                    	rrca
  EBB0    E6 80                 	and	80h		;A=e000 0000
  EBB2    81                    	add	a,c
  EBB3    4F                    	ld	c,a
  EBB4    3E 00                 	ld	a,0
  EBB6    88                    	adc	a,b
  EBB7    47                    	ld	b,a
                                				;BC = 0000 000? errrr rrrr
  EBB8    7E                    	ld	a,(hl)
  EBB9    0F                    	rrca
  EBBA    E6 0F                 	and	0fh
  EBBC    80                    	add	a,b
  EBBD    47                    	ld	b,a
                                				;BC = 000? eeee errrr rrrr
  EBBE    21 000E               	ld	hl,modnum
  EBC1    19                    	add	hl,de
  EBC2    7E                    	ld	a,(hl)		;A=XXX? mmmm
  EBC3    87                    	add	a,a
  EBC4    87                    	add	a,a
  EBC5    87                    	add	a,a
  EBC6    87                    	add	a,a		;cy=? A=mmmm 0000
  EBC7    F5                    	push	af
  EBC8    80                    	add	a,b
  EBC9    47                    	ld	b,a
                                				;cy=?, BC = mmmm eeee errr rrrr
  EBCA    F5                    	push	af		;possible second carry
  EBCB    E1                    	pop	hl		;cy = lsb of L
  EBCC    7D                    	ld	a,l		;cy = lsb of A
  EBCD    E1                    	pop	hl		;cy = lsb of L
  EBCE    B5                    	or	l		;cy/cy = lsb of A
  EBCF    E6 01                 	and	1		;A = 0000 000? possible carry-out
  EBD1    C9                    	ret
                                
  EBD2                          getfilesize:			;compute logical file size for current fcb
  EBD2    0E 0C                 	ld	c,extnum
  EBD4    CD E718               	call	search
                                				;zero the receiving ranrec field
  EBD7    2A E343               	ld	hl,(info)
  EBDA    11 0021               	ld	de,ranrec
  EBDD    19                    	add	hl,de
  EBDE    E5                    	push	hl		;save position
  EBDF    72                    	ld	(hl),d
  EBE0    23                    	inc	hl
  EBE1    72                    	ld	(hl),d
  EBE2    23                    	inc	hl
  EBE3    72                    	ld	(hl),d		;=00 00 00
  EBE4                          getsize:
  EBE4    CD E5F5               	call	end$of$dir
  EBE7    CA EC0C               	jp	z,setsize
                                				;current fcb addressed by dptr
  EBEA    CD E55E               	call	getdptra
  EBED    11 000F               	ld	de,reccnt	;ready for compute size
  EBF0    CD EBA5               	call	compute$rr
                                				;A=0000 000? BC = mmmm eeee errr rrrr
                                				;compare with memory, larger?
  EBF3    E1                    	pop	hl
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-43


  EBF4    E5                    	push	hl		;recall, replace .fcb(ranrec)
  EBF5    5F                    	ld	e,a		;save cy
  EBF6    79                    	ld	a,c
  EBF7    96                    	sub	(hl)
  EBF8    23                    	inc	hl		;ls byte
  EBF9    78                    	ld	a,b
  EBFA    9E                    	sbc	a,(hl)
  EBFB    23                    	inc	hl		;middle byte
  EBFC    7B                    	ld	a,e
  EBFD    9E                    	sbc	a,(hl)		;carry if .fcb(ranrec) > directory
  EBFE    DA EC06               	jp	c,getnextsize	;for another try
                                				;fcb is less or equal, fill from directory
  EC01    73                    	ld	(hl),e
  EC02    2B                    	dec	hl
  EC03    70                    	ld	(hl),b
  EC04    2B                    	dec	hl
  EC05    71                    	ld	(hl),c
  EC06                          getnextsize:
  EC06    CD E72D               	call	searchn
  EC09    C3 EBE4               	jp	getsize
                                
  EC0C                          setsize:
  EC0C    E1                    	pop	hl		;discard .fcb(ranrec)
  EC0D    C9                    	ret
                                
  EC0E                          setrandom:			;set random record from the current file control block
  EC0E    2A E343               	ld	hl,(info)
  EC11    11 0020               	ld	de,nxtrec	;ready params for computesize
  EC14    CD EBA5               	call	compute$rr	;DE=info, A=cy, BC=mmmm eeee errr rrrr
  EC17    21 0021               	ld	hl,ranrec
  EC1A    19                    	add	hl,de		;HL = .fcb(ranrec)
  EC1B    71                    	ld	(hl),c
  EC1C    23                    	inc	hl
  EC1D    70                    	ld	(hl),b
  EC1E    23                    	inc	hl
  EC1F    77                    	ld	(hl),a		;to ranrec
  EC20    C9                    	ret
                                
  EC21                          select:				;select disk info for subsequent input or output ops
  EC21    2A EDAF               	ld	hl,(dlog)
  EC24    3A E342               	ld	a,(curdsk)
  EC27    4F                    	ld	c,a
  EC28    CD E4EA               	call	hlrotr
  EC2B    E5                    	push	hl
  EC2C    EB                    	ex	de,hl		;save it for test below, send to seldsk
  EC2D    CD E359               	call	selectdisk
  EC30    E1                    	pop	hl		;recall dlog vector
  EC31    CC E347               	call	z,sel$error	;returns true if select ok
                                				;is the disk logged in?
  EC34    7D                    	ld	a,l
  EC35    1F                    	rra
  EC36    D8                    	ret	c		;return if bit is set
                                				;disk not logged in, set bit and initialize
  EC37    2A EDAF               	ld	hl,(dlog)
  EC3A    4D                    	ld	c,l
  EC3B    44                    	ld	b,h		;call ready
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-44


  EC3C    CD E50B               	call	set$cdisk
  EC3F    22 EDAF               	ld	(dlog),hl	;dlog=set$cdisk(dlog)
  EC42    C3 E6A3               	jp	initialize
                                ;	ret
                                
  EC45                          curselect:
  EC45    3A EDD6               	ld	a,(linfo)
  EC48    21 E342               	ld	hl,curdsk
  EC4B    BE                    	cp	(hl)
  EC4C    C8                    	ret	z		;skip if linfo=curdsk
  EC4D    77                    	ld	(hl),a		;curdsk=info
  EC4E    C3 EC21               	jp	select
                                ;	ret
                                
  EC51                          reselect:			;check current fcb to see if reselection necessary
  EC51    3E FF                 	ld	a,true
  EC53    32 EDDE               	ld	(resel),a	;mark possible reselect
  EC56    2A E343               	ld	hl,(info)
  EC59    7E                    	ld	a,(hl)		;drive select code
  EC5A    E6 1F                 	and	11111b		;non zero is auto drive select
  EC5C    3D                    	dec	a		;drive code normalized to 0..30, or 255
  EC5D    32 EDD6               	ld	(linfo),a	;save drive code
  EC60    FE 1E                 	cp	30
  EC62    D2 EC75               	jp	nc,noselect
                                				;auto select function, save curdsk
  EC65    3A E342               	ld	a,(curdsk)
  EC68    32 EDDF               	ld	(olddsk),a	;olddsk=curdsk
  EC6B    7E                    	ld	a,(hl)
  EC6C    32 EDE0               	ld	(fcbdsk),a	;save drive code
  EC6F    E6 E0                 	and	11100000b
  EC71    77                    	ld	(hl),a		;preserve hi bits
  EC72    CD EC45               	call	curselect
  EC75                          noselect:			;set user code
  EC75    3A E341               	ld	a,(usrcode)	;0...31
  EC78    2A E343               	ld	hl,(info)
  EC7B    B6                    	or	(hl)
  EC7C    77                    	ld	(hl),a
  EC7D    C9                    	ret
                                
                                ;	individual function handlers
  EC7E                          func12:				;return version number
  EC7E    3E 22                 	ld	a,dvers
  EC80    C3 E301               	jp	sta$ret		;lret = dvers (high = 00)
                                ;	ret
                                ;	jp	goback
                                
  EC83                          func13:				;reset disk system - initialize to disk 0
  EC83    21 0000               	ld	hl,0
  EC86    22 EDAD               	ld	(rodsk),hl
  EC89    22 EDAF               	ld	(dlog),hl
  EC8C    AF                    	xor	a
  EC8D    32 E342               	ld	(curdsk),a	;note that usrcode remains unchanged
  EC90    21 0080               	ld	hl,tbuff
  EC93    22 EDB1               	ld	(dmaad),hl	;dmaad = tbuff
  EC96    CD E5DA               	call	setdata		;to data dma address
  EC99    C3 EC21               	jp	select
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-45


                                ;	ret
                                ;	jp	goback
                                
  EC45                          func14	equ	curselect	;select disk info
                                ;	ret
                                ;	jp	goback
                                
  EC9C                          func15:				;open file
  EC9C    CD E572               	call	clrmodnum	;clear the module number
  EC9F    CD EC51               	call	reselect
  ECA2    C3 E851               	jp	open
                                ;	ret
                                ;	jp	goback
                                
  ECA5                          func16:				;close file
  ECA5    CD EC51               	call	reselect
  ECA8    C3 E8A2               	jp	close
                                ;	ret
                                ;	jp	goback
                                
  ECAB                          func17:				;search for first occurrence of a file
  ECAB    0E 00                 	ld	c,0		;length assuming '?' true
  ECAD    EB                    	ex	de,hl		;was lhld info
  ECAE    7E                    	ld	a,(hl)
  ECAF    FE 3F                 	cp	'?'		;no reselect if ?
  ECB1    CA ECC2               	jp	z,qselect	;skip reselect if so
                                				;normal search
  ECB4    CD E4A6               	call	getexta
  ECB7    7E                    	ld	a,(hl)
  ECB8    FE 3F                 	cp	'?'		;
  ECBA    C4 E572               	call	nz,clrmodnum	;module number zeroed
  ECBD    CD EC51               	call	reselect
  ECC0    0E 0F                 	ld	c,namlen
  ECC2                          qselect:
  ECC2    CD E718               	call	search
  ECC5    C3 E5E9               	jp	dir$to$user	;copy directory entry to user
                                ;	ret
                                ;	jp	goback
                                
  ECC8                          func18:				;search for next occurrence of a file name
  ECC8    2A EDD9               	ld	hl,(searcha)
  ECCB    22 E343               	ld	(info),hl
  ECCE    CD EC51               	call	reselect
  ECD1    CD E72D               	call	searchn
  ECD4    C3 E5E9               	jp	dir$to$user	;copy directory entry to user
                                ;	ret
                                ;	jp	goback
                                
  ECD7                          func19:				;delete a file
  ECD7    CD EC51               	call	reselect
  ECDA    CD E79C               	call	delete
  ECDD    C3 E701               	jp	copy$dirloc
                                ;	ret
                                ;	jp	goback
                                
  ECE0                          func20:				;read a file
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-46


  ECE0    CD EC51               	call	reselect
  ECE3    C3 E9BC               	jp	seqdiskread
                                ;	jp	goback
                                
  ECE6                          func21:				;write a file
  ECE6    CD EC51               	call	reselect
  ECE9    C3 E9FE               	jp	seqdiskwrite
                                ;	jp	goback
                                
  ECEC                          func22:				;make a file
  ECEC    CD E572               	call	clrmodnum
  ECEF    CD EC51               	call	reselect
  ECF2    C3 E924               	jp	make
                                ;	ret
                                ;	jp	goback
                                
  ECF5                          func23:				;rename a file
  ECF5    CD EC51               	call	reselect
  ECF8    CD E816               	call	rename
  ECFB    C3 E701               	jp	copy$dirloc
                                ;	ret
                                ;	jp	goback
                                
  ECFE                          func24:				;return the login vector
  ECFE    2A EDAF               	ld	hl,(dlog)
  ED01    C3 ED29               	jp	sthl$ret
                                ;	ret
                                ;	jp	goback
                                
  ED04                          func25:				;return selected disk number
  ED04    3A E342               	ld	a,(curdsk)
  ED07    C3 E301               	jp	sta$ret
                                ;	ret
                                ;	jp	goback
                                
  ED0A                          func26:				;set the subsequent dma address to info
  ED0A    EB                    	ex	de,hl		;was lhld info
  ED0B    22 EDB1               	ld	(dmaad),hl	;dmaad = info
  ED0E    C3 E5DA               	jp	setdata		;to data dma address
                                ;	ret
                                ;	jp	goback
                                
  ED11                          func27:				;return the login vector address
  ED11    2A EDBF               	ld	hl,(alloca)
  ED14    C3 ED29               	jp	sthl$ret
                                ;	ret
                                ;	jp	goback
                                
  E52C                          func28	equ	set$ro
                                				;write protect current disk
                                ;	ret
                                ;	jp	goback
                                
  ED17                          func29:				;return r/o bit vector
  ED17    2A EDAD               	ld	hl,(rodsk)
  ED1A    C3 ED29               	jp	sthl$ret
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-47


                                ;	ret
                                ;	jp	goback
                                
  ED1D                          func30:				;set file indicators
  ED1D    CD EC51               	call	reselect
  ED20    CD E83B               	call	indicators
  ED23    C3 E701               	jp	copy$dirloc	;lret=dirloc
                                ;	ret
                                ;	jp	goback
                                
  ED26                          func31:				;return address of disk parameter block
  ED26    2A EDBB               	ld	hl,(dpbaddr)
  ED29                          sthl$ret:
  ED29    22 E345               	ld	(aret),hl
  ED2C    C9                    	ret
                                ;	jp	goback
                                
  ED2D                          func32:				;set user code
  ED2D    3A EDD6               	ld	a,(linfo)
  ED30    FE FF                 	cp	0ffh
  ED32    C2 ED3B               	jp	nz,setusrcode
                                				;interrogate user code instead
  ED35    3A E341               	ld	a,(usrcode)
  ED38    C3 E301               	jp	sta$ret		;lret=usrcode
                                ;	ret
                                ;	jp	goback
                                
  ED3B                          setusrcode:
  ED3B    E6 1F                 	and	1fh
  ED3D    32 E341               	ld	(usrcode),a
  ED40    C9                    	ret
                                ;	jp	goback
                                
  ED41                          func33:				;random disk read operation
  ED41    CD EC51               	call	reselect
  ED44    C3 EB93               	jp	randiskread	;to perform the disk read
                                ;	ret
                                ;	jp	goback
                                
  ED47                          func34:				;random disk write operation
  ED47    CD EC51               	call	reselect
  ED4A    C3 EB9C               	jp	randiskwrite	;to perform the disk write
                                ;	ret
                                ;	jp	goback
                                
  ED4D                          func35:				;return file size (0-65536)
  ED4D    CD EC51               	call	reselect
  ED50    C3 EBD2               	jp	getfilesize
                                ;	ret
                                ;	jp	goback
                                
  EC0E                          func36	equ	setrandom	;set random record
                                ;	ret
                                ;	jp	goback
                                
  ED53    2A E343               func37:	ld	hl,(info)
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-48


  ED56    7D                    	ld	a,l
  ED57    2F                    	cpl
  ED58    5F                    	ld	e,a
  ED59    7C                    	ld	a,h
  ED5A    2F                    	cpl
  ED5B    2A EDAF               	ld	hl,(dlog)
  ED5E    A4                    	and	h
  ED5F    57                    	ld	d,a
  ED60    7D                    	ld	a,l
  ED61    A3                    	and	e
  ED62    5F                    	ld	e,a
  ED63    2A EDAD               	ld	hl,(rodsk)
  ED66    EB                    	ex	de,hl
  ED67    22 EDAF               	ld	(dlog),hl
  ED6A    7D                    	ld	a,l
  ED6B    A3                    	and	e
  ED6C    6F                    	ld	l,a
  ED6D    7C                    	ld	a,h
  ED6E    A2                    	and	d
  ED6F    67                    	ld	h,a
  ED70    22 EDAD               	ld	(rodsk),hl
  ED73    C9                    	ret
                                
  ED74                          goback:				;arrive here at end of processing to return to user
  ED74    3A EDDE               	ld	a,(resel)
  ED77    B7                    	or	a
  ED78    CA ED91               	jp	z,retmon
                                				;reselection may have taken place
  ED7B    2A E343               	ld	hl,(info)
  ED7E    36 00                 	ld	(hl),0		;fcb(0)=0
  ED80    3A EDE0               	ld	a,(fcbdsk)
  ED83    B7                    	or	a
  ED84    CA ED91               	jp	z,retmon
                                				;restore disk number
  ED87    77                    	ld	(hl),a		;fcb(0)=fcbdsk
  ED88    3A EDDF               	ld	a,(olddsk)
  ED8B    32 EDD6               	ld	(linfo),a
  ED8E    CD EC45               	call	curselect
                                
                                ;	return from the disk monitor
  ED91    2A E30F               retmon:	ld	hl,(entsp)
  ED94    F9                    	ld	sp,hl		;user stack restored
  ED95    2A E345               	ld	hl,(aret)
  ED98    7D                    	ld	a,l
  ED99    44                    	ld	b,h		;BA = HL = aret
  ED9A    C9                    	ret
                                
  E304                          func38	equ	func$ret
  E304                          func39	equ	func$ret
  ED9B                          func40:				;random disk write with zero fill of unallocated block
  ED9B    CD EC51               	call	reselect
  ED9E    3E 02                 	ld	a,2
  EDA0    32 EDD5               	ld	(seqio),a
  EDA3    0E 00                 	ld	c,false
  EDA5    CD EB07               	call	rseek1
  EDA8    CC EA03               	call	z,diskwrite	;if seek successful
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-49


  EDAB    C9                    	ret
                                
                                ;	data areas
                                
                                ;	initialized data
  EDAC    E5                    efcb:	db	empty		;0e5=available dir entry
  EDAD    0000                  rodsk:	dw	0		;read only disk vector
  EDAF    0000                  dlog:	dw	0		;logged-in disks
  EDB1    0080                  dmaad:	dw	tbuff		;initial dma address
                                
                                ;	curtrka - alloca are set upon disk select
                                ;	(data must be adjacent, do not insert variables)
                                ;	(address of translate vector, not used)
  EDB3                          cdrmaxa:
  EDB3                          	ds	word		;pointer to cur dir max value
  EDB5                          curtrka:
  EDB5                          	ds	word		;current track address
  EDB7                          curreca:
  EDB7                          	ds	word		;current record address
  EDB9                          buffa:	ds	word		;pointer to directory dma address
  EDBB                          dpbaddr:
  EDBB                          	ds	word		;current disk parameter block address
  EDBD                          checka:	ds	word		;current checksum vector address
  EDBF                          alloca:	ds	word		;current allocation vector address
  0008                          addlist	equ	$-buffa		;address list size
                                
                                ;	sectpt - offset obtained from disk parm block at dpbaddr
                                ;	(data must be adjacent, do not insert variables)
  EDC1                          sectpt:	ds	word		;sectors per track
  EDC3                          blkshf:	ds	byte		;block shift factor
  EDC4                          blkmsk:	ds	byte		;block mask
  EDC5                          extmsk:	ds	byte		;extent mask
  EDC6                          maxall:	ds	word		;maximum allocation number
  EDC8                          dirmax:	ds	word		;largest directory number
  EDCA                          dirblk:	ds	word		;reserved allocation bits for directory
  EDCC                          chksiz:	ds	word		;size of checksum vector
  EDCE                          offset:	ds	word		;offset tracks at beginning
  000F                          dpblist	equ	$-sectpt	;size of area
                                
                                ;	local variables
  EDD0                          tranv:	ds	word		;address of translate vector
  EDD2                          fcb$copied:
  EDD2                          	ds	byte		;set true if copy$fcb called
  EDD3                          rmf:	ds	byte		;read mode flag for open$reel
  EDD4                          dirloc:	ds	byte		;directory flag in rename, etc.
  EDD5                          seqio:	ds	byte		;1 if sequential i/o
  EDD6                          linfo:	ds	byte		;low(info)
  EDD7                          dminx:	ds	byte		;local for diskwrite
  EDD8                          searchl:
  EDD8                          	ds	byte		;search length
  EDD9                          searcha:
  EDD9                          	ds	word		;search address
  EDDB                          tinfo:	ds	word		;temp for info in "make"
  EDDD                          single:	ds	byte		;set true if single byte allocation map
  EDDE                          resel:	ds	byte		;reselection flag
  EDDF                          olddsk:	ds	byte		;disk on entry to bdos
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	1-50


  EDE0                          fcbdsk:	ds	byte		;disk named in fcb
  EDE1                          rcount:	ds	byte		;record count in current fcb
  EDE2                          extval:	ds	byte		;extent number and extmsk
  EDE3                          vrecord:
  EDE3                          	ds	word		;current virtual record
  EDE5                          arecord:
  EDE5                          	ds	word		;current actual record
  EDE7                          arecord1:
  EDE7                          	ds	word		;current actual block# * blkmsk
                                
                                ;	local variables for directory access
  EDE9                          dptr:	ds	byte		;directory pointer 0,1,2,3
  EDEA                          dcnt:	ds	word		;directory counter 0,1,...,dirmax
  EDEC                          drec:	ds	word		;directory record 0,1,...,dirmax/4
                                
                                ;bios	equ	($ and 0ff00h)+100h;next module
                                
                                	end
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	S


Macros:

Symbols:
E564 	ADDH            0008 	ADDLIST         EDBF 	ALLOCA          
E484 	ALLOCATED       EA64 	ALLOCWD         EDE5 	ARECORD         
EDE7 	ARECORD1        E345 	ARET            E48A 	ATRAN           
E490 	ATRAN0          E299 	BACKSP          E1A4 	BACKUP          
E24E 	BACKX           EB84 	BADSEEK         0006 	BDOSA           
E011 	BDOSE           0E00 	BDOSLEN         E000 	BDOSPH          
A400 	BIAS            EE00 	BIOS            0003 	BIOSLEN         
EE00 	BIOSPH          EDC4 	BLKMSK          EDC3 	BLKSHF          
EA48 	BLOCKOK         EE00 	BOOTF           EDB9 	BUFFA           
E8E1 	BUFFNZERO       0001 	BYTE            0800 	CCPLEN          
D800 	CCPPH           EDB3 	CDRMAXA         E544 	CHECK$RODIR     
E547 	CHECK$ROFILE    E554 	CHECK$WRITE     EDBD 	CHECKA          
E59E 	CHECKSUM        EDCC 	CHKSIZ          E8A2 	CLOSE           
E572 	CLRMODNUM       E30C 	COLUMN          E57F 	COMPCDR         
E30A 	COMPCOL         E707 	COMPEXT         E162 	COMPOUT         
E4F7 	COMPUTE$CS      EBA5 	COMPUTE$RR      E4FD 	COMPUTECS0      
E142 	CONB0           E145 	CONB1           E123 	CONBRK          
E106 	CONECH          E0FB 	CONIN           EE09 	CONINF          
E148 	CONOUT          EE0C 	CONOUTF         EE06 	CONSTF          
E801 	COPY$DIR        E701 	COPY$DIRLOC     E7FD 	COPY$FCB        
000D 	CR              E1C9 	CRLF            E1B1 	CRLFP           
E1B9 	CRLFP0          005E 	CTL             0003 	CTLC            
0005 	CTLE            0008 	CTLH            E17F 	CTLOUT          
0010 	CTLP            0012 	CTLR            0013 	CTLS            
0015 	CTLU            0018 	CTLX            001A 	CTLZ            
E342 	CURDSK          EDB7 	CURRECA         EC45 	CURSELECT       
EDB5 	CURTRKA         EDEA 	DCNT            E79C 	DELETE          
E7A4 	DELETE0         E3BB 	DIOCOMP         E5E9 	DIR$TO$USER     
EDCA 	DIRBLK          E2E0 	DIRINP          EDD4 	DIRLOC          
EDC8 	DIRMAX          0004 	DIRREC          E9FB 	DISKEOF         
000C 	DISKF           E9C1 	DISKREAD        EA1C 	DISKWR0         
EA6E 	DISKWR1         EABB 	DISKWR11        EAD2 	DISKWR2         
EB00 	DISKWR3         EA03 	DISKWRITE       EA6C 	DISKWRU         
EDAF 	DLOG            E43E 	DM$POSITION     EDB1 	DMAAD           
EDD7 	DMINX           E445 	DMPOS0          E453 	DMPOS1          
E45C 	DMPOS2          E8FD 	DMSET           EDBB 	DPBADDR         
000F 	DPBLIST         EDE9 	DPTR            EDEC 	DREC            
E0C6 	DSKERR          0010 	DSKMAP          E0BA 	DSKMSG          
0003 	DSKMSK          0002 	DSKSHF          0022 	DVERS           
E114 	ECHOC           EDAC 	EFCB            00E5 	EMPTY           
E5F5 	END$OF$DIR      FFFF 	ENDDIR          E917 	ENDMERGE        
E783 	ENDSEARCH       E30F 	ENTSP           E0E5 	ERRFLG          
EDC5 	EXTMSK          000C 	EXTNUM          EDE2 	EXTVAL          
0000 	FALSE           EDD2 	FCB$COPIED      EDE0 	FCBDSK          
0020 	FCBLEN          E8DB 	FCBNZERO        0005 	FCBSHF          
EA8C 	FILL0           EA9A 	FILL1           E304 	FUNC$RET        
E2C8 	FUNC1           E1E1 	FUNC10          E2FE 	FUNC11          
EC7E 	FUNC12          EC83 	FUNC13          EC45 	FUNC14          
EC9C 	FUNC15          ECA5 	FUNC16          ECAB 	FUNC17          
ECC8 	FUNC18          ECD7 	FUNC19          E190 	FUNC2           
ECE0 	FUNC20          ECE6 	FUNC21          ECEC 	FUNC22          
ECF5 	FUNC23          ECFE 	FUNC24          ED04 	FUNC25          
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	S-1


ED0A 	FUNC26          ED11 	FUNC27          E52C 	FUNC28          
ED17 	FUNC29          E2CE 	FUNC3           ED1D 	FUNC30          
ED26 	FUNC31          ED2D 	FUNC32          ED41 	FUNC33          
ED47 	FUNC34          ED4D 	FUNC35          EC0E 	FUNC36          
ED53 	FUNC37          E304 	FUNC38          E304 	FUNC39          
ED9B 	FUNC40          E2D4 	FUNC6           E2ED 	FUNC7           
E2F3 	FUNC8           E2F8 	FUNC9           E047 	FUNCTAB         
0080 	FWFMSK          E7BE 	GET$BLOCK       E635 	GETALLOCBIT     
E45E 	GETDM           E471 	GETDMD          E55E 	GETDPTRA        
E4A6 	GETEXTA         E4BB 	GETFCB          E4AE 	GETFCBA         
EBD2 	GETFILESIZE     E569 	GETMODNUM       EC06 	GETNEXTSIZE     
EBE4 	GETSIZE         ED74 	GOBACK          E34A 	GOERR           
E504 	HLROTL          E505 	HLROTL0         E4EA 	HLROTR          
E4EB 	HLROTR0         E3A1 	HOME            EE18 	HOMEF           
E477 	INDEX           E840 	INDIC0          E83B 	INDICATORS      
E343 	INFO            E5C4 	INITIAL$CS      E6B1 	INITIAL0        
E6D2 	INITIAL2        E6A3 	INITIALIZE      000A 	INVIS           
0003 	IOLOC           E30E 	KBCHAR          E7C0 	LEFTTST         
000A 	LF              E270 	LINELEN         EDD6 	LINFO           
E30D 	LISTCP          EE0F 	LISTF           EE2D 	LISTSTF         
E345 	LRET            E341 	LSTACK          001F 	LSTFCB          
007F 	LSTREC          E924 	MAKE            E946 	MAKE0           
EDC6 	MAXALL          001F 	MAXEXT          000F 	MAXMOD          
E8CD 	MERGE0          E8E8 	MERGED          E91F 	MERGERR         
E894 	MERGEZERO       000E 	MODNUM          E34F 	MOVE            
E350 	MOVE0           003D 	MSIZ            0040 	MSIZE           
000F 	NAMLEN          0001 	NEEDZ80         E59C 	NEWCHECKSUM     
0029 	NFUNCS          0000 	NHDISKS         EA3B 	NOPBLOCK        
EC75 	NOSELECT        EAFE 	NOSPACE         E179 	NOTBACKSP       
E2BD 	NOTC            E237 	NOTE            E216 	NOTH            
E248 	NOTP            E2A6 	NOTR            E226 	NOTRUB          
E26B 	NOTU            E25F 	NOTX            EADF 	NOUPDATE        
E51E 	NOWRITE         0020 	NXTREC          EDCE 	OFFSET          
EDDF 	OLDDSK          E851 	OPEN            E85A 	OPEN$COPY       
E983 	OPEN$MOD        E9B6 	OPEN$R$ERR      E88B 	OPEN$RCNT       
E95A 	OPEN$REEL       E98E 	OPEN$REEL0      E9AC 	OPEN$REEL1      
E9AF 	OPEN$REEL2      0001 	PATCHOS         E1AC 	PCTLH           
E6F6 	PDOLLAR         E009 	PERERR          E0CA 	PERMSG          
E099 	PERSUB          E1D3 	PRINT           EE12 	PUNCHF          
ECC2 	QSELECT         EB47 	RANCLOSE        EB93 	RANDISKREAD     
EB9C 	RANDISKWRITE    0021 	RANREC          EDE1 	RCOUNT          
E5D4 	RD$DIR          E3B2 	RDBUFF          E2A9 	RDECH1          
E2A6 	RDECHO          E1E1 	READ            E605 	READ$DIR        
E619 	READ$DIR0       E620 	READ$DIR1       E2C1 	READEN          
EE15 	READERF         EE27 	READF           E1F1 	READN0          
E1EF 	READNX          0000 	REBOOT          000F 	RECCNT          
E9E6 	RECORDOK        0080 	RECSIZ          E816 	RENAME          
E827 	RENAME0         E278 	REP0            E28A 	REP1            
EDDE 	RESEL           EC51 	RESELECT        E7EC 	RETBLOCK        
E7F4 	RETBLOCK0       ED91 	RETMON          E39D 	RETSELECT       
E7D1 	RIGHTTST        EDD3 	RMF             E00D 	RODERR          
E0E1 	RODMSG          EDAD 	RODSK           E0AB 	RODSUB          
E00F 	ROFERR          0009 	ROFILE          E0DC 	ROFMSG          
E0B1 	ROFSUB          E656 	ROTL            E664 	ROTR            
EB03 	RSEEK           EB07 	RSEEK1          007F 	RUBOUT          
E66B 	SCANDM          E675 	SCANDM0         E688 	SCANDM1         
'Bdos Interface, Bdos, Version 2.2 Feb, 1980'	MACRO-80 3.44	09-Dec-81	PAGE	S-2


E68E 	SCANDM2         E69D 	SCANM3          E718 	SEARCH          
E794 	SEARCH$FIN      EDD9 	SEARCHA         E773 	SEARCHEXT       
EDD8 	SEARCHL         E753 	SEARCHLOOP      E72D 	SEARCHN         
E74A 	SEARCHNEXT      E77C 	SEARCHOK        EDC1 	SECTPT          
EE30 	SECTRAN         E3D1 	SEEK            E810 	SEEK$COPY       
E3C3 	SEEK$DIR        E3E4 	SEEK0           E3FA 	SEEK1           
E40F 	SEEK2           EB8B 	SEEKERR         EB7F 	SEEKOK          
E347 	SEL$ERROR       EE1B 	SELDSKF         EC21 	SELECT          
E359 	SELECTDISK      E00B 	SELERR          E0D5 	SELMSG          
E0A5 	SELSUB          E9BC 	SEQDISKREAD     E9FE 	SEQDISKWRITE    
EDD5 	SEQIO           E65C 	SET$ALLOC$BIT   E50B 	SET$CDISK       
E5FE 	SET$END$DIR     E52C 	SET$RO          E58C 	SETCDR          
E5DA 	SETDATA         E5E0 	SETDIR          E5E3 	SETDMA          
EE24 	SETDMAF         E4D2 	SETFCB          E4DE 	SETFCB1         
E578 	SETFWF          E305 	SETLRET1        EC0E 	SETRANDOM       
EE21 	SETSECF         EC0C 	SETSIZE         EE1E 	SETTRKF         
ED3B 	SETUSRCODE      EDDD 	SINGLE          0018 	SSIZE           
E301 	STA$RET         ED29 	STHL$RET        E30B 	STRTCOL         
E595 	SUBDH           0009 	TAB             E196 	TAB0            
E190 	TABOUT          0080 	TBUFF           005C 	TFCB            
EDDB 	TINFO           EDD0 	TRANV           00FF 	TRUE            
000D 	UBYTES          E341 	USRCODE         EDE3 	VRECORD         
E0B4 	WAIT$ERR        EE03 	WBOOTF          0002 	WORD            
E3B8 	WRBUFF          E5C6 	WRDIR           EE2A 	WRITEF          



No Fatal error(s)


