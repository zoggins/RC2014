"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1


  0000'                         	aseg
                                	org	100h
                         C      	maclib	MEMCFG.LIB	; define msize and bioslen
  0040                   C      msize	equ	64		; adjust per installed system memory
                         C      
                         C      ; configuration parameters for BIOS
  0C00                   C      bioslen	equ	0c00h		; adjust as bios changes are made (if necessary)
  0000                   C      nhdisks	equ	0		; total number of hard disks (set to 0
                         C      				;   if no hard disks desired)
  0001                   C      needZ80	equ	1		; 0 = 8080 is ok, 1 = Z80 is needed
  0001                   C      patchOS	equ	1		; 0 = do not patch CCP and BODS
                         C      					; 1 = patch orignal CCP and original BDOS
                         C      
                         C      ; common definitions and derived values - no change should be necessary below
  0800                   C      ccplen	equ	0800h		; cp/m constant
  0E00                   C      bdoslen	equ	0e00h		; cp/m constant
                         C      
                         C      ; cp/m image size (rounded up to next 1k boundary)
  0009                   C      cpmlen	equ	(ccplen + bdoslen + bioslen + 03ffh) / 0400h
                         C      
  003D                   C      msiz	equ	msize-(bioslen/400H)		;SUBTRACT BIOS SIZE
  A400                   C      bias	equ (msiz-20)*1024				;THE DRI BIAS FACTOR
                         C      
                         C      ;ccpph	equ	(msize - cpmlen) * 1024		; old ccp start address
  D800                   C      ccpph	equ	3400H+bias					; udpated ccp start address
  E000                   C      bdosph	equ	ccpph + ccplen				; bdos start address
  EE00                   C      biosph	equ	ccpph + ccplen + bdoslen	; bios start address
                         C      
                                
                                	.phase	bdosph
                                
                                ;****************************************************************************
                                ;				Z S D O S
                                ;   A CP/M 2.2 compatible replacement Basic Disk Operating System (BDOS)
                                ;
                                ;     Copyright (C) 1986,7,8 by:
                                ;
                                ;          Harold F. Bower        and       Cameron W. Cotrill
                                ;
                                ;         7914 Redglobe Ct.                2160 N.W. 159th Place
                                ;         Severn, MD 21144-1048            Beaverton, OR  97006
                                ;         USA.                             USA.
                                ;
                                ;       HalBower@worldnet.att.net         ccotrill@symantec.com
                                ;
                                ;   This program is free software; you can redistribute it and/or modify
                                ;   it under the terms of the GNU General Public License as published by
                                ;   the Free Software Foundation; either version 2 of the License, or
                                ;   (at your option) any later version.
                                ;
                                ;   This program is distributed in the hope that it will be useful,
                                ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
                                ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                                ;   General Public License (file LICENSE.TXT) for more details.
                                ;
                                ;   You should have received a copy of the GNU General Public License
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-1


                                ;   along with this program; if not, write to the Free Software
                                ;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
                                ;---------------------------------------------------------------------------
                                ; ZSDOS is a CP/M 2.2 compatable BDOS replacement that contains numerous
                                ; enhancements.  It is based on P2DOS 2.1 by HAJ Ten Brugge and revisions
                                ; to P2DOS made by Harold F. Bower, Benjamin Ho, and Cameron W. Cotrill.
                                ; Several good ideas from both CP/M Plus(tm) and ZRDOS(tm) have been added.
                                ; The authors wish to thank Bridger Mitchell of Plu*Perfect Systems for
                                ; suggesting we put our heads together, for reviewing the efforts, and for
                                ; suggesting better methods for coding some sections.  Thanks also to Joe
                                ; Wright of Alpha Systems for his review and suggestions, as well as
                                ; squeezing a few more bytes for us.
                                
                                ; Support for Plu*Perfect'a BackGrounder ii(tm) and ZDS DateStamper(tm) is
                                ; included, as well as support for ZCPR/BGii WHEEL and PATH.
                                ; ZSDOS is compatable with NZCOM by Joe Wright of Alpha Systems.
                                
                                ; ZSDOS is designed for Z80 compatible processors ONLY!!!
                                ; ZSDOS is coded to run in Z280 protected mode and may be ROMmed.
                                
                                ; LEGAL DEPARTMENT:   P2DOS was written by H.A.J. Ten Brugge,  ZSDOS
                                ; modifications were by Cameron W. Cotrill and Harold F. Bower.
                                ; ZDDOS modifications were done by Carson Wilson, Cameron W. Cotrill
                                ; and Harold F. Bower.
                                
                                ; No author assumes responsibility or liability in the use of this
                                ; program or any of its support utilities.
                                
                                ; P2DOS is Copyright (C) 1985 by H.A.J. Ten Brugge  - All Rights Reserved
                                ;	H.A.J. Ten Brugge
                                ;	F. Zernikestraat 207
                                ;	7553 EC Hengelo
                                ;	Netherlands
                                ; Permission to use P2DOS code in ZSDOS granted to Harold F. Bower and
                                ;   Cameron W. Cotrill in letter 28 March 1988
                                
                                ;   Code sections marked (bm) are revisions suggested by Bridger Mitchell.
                                ;   Code sections marked (bh) are from SUPRBDOS mods to P2DOS by Benjamin Ho.
                                ;   Code sections marked (crw) are revisions to support internal datestamper
                                ;      and are Copyright (C) 1988 by Carson Wilson.
                                
                                ; NOTES: Backgrounder ii and DateStamper are trademarks of Plu*Perfect
                                ;  Systems.  CP/M is a trademark of Digital Research, Incorporated.
                                ;  ZRDOS is a trademark of Echelon, Incorporated.
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-2


                                
                                ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                                ; Version 1.2a, 11/04/89
                                ; Assemble with : SLR Z80ASMP or ZMAC
                                ; Revisions:
                                ; 11/04/89	Moved home call to rddir so bios hostbuf always
                                ;		updated before dir read.
                                ; 07/18/89	Fixed tderr routine in ZDDOS so return codes not
                                ; CWC		altered from tderr unless called from 102 or 103.
                                ; 06/20/89	Fixed bug in F10 ^R that output 256 spaces if ^R
                                ; CWC		entered with tab counter =0.
                                ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                                
                         C      	MACLIB	ZSDOS.LIB	; Get initialization code
                         C      ;.....
                         C      ; ZSDOS Customization.  		-HFB,  18 Sept 1987
                         C      ;					revised 07/17/88 CWC
                         C      
  0000                   C      FALSE	EQU	0
  FFFF                   C      TRUE	EQU	NOT FALSE
                         C      
                         C      ; Set these conditionals before assembly
                         C      
                         C      ;****************************************************************************
                         C      ; In the General Public Release version, we have included an equate which
                         C      ; controls an additional unreleased fix (which only Howard Goldstein found).
                         C      ; If the following equate is set TRUE, a version 1.1 BDOS will be produced
                         C      ; which will require no changes to any released utilities.  If set to FALSE,
                         C      ; a version 1.2 BDOS will result, and many support utility libraries and
                         C      ; overlays will need to be revised to make them function properly.    HFB
                         C      
  FFFF                   C      ZSDOS11	EQU	TRUE			; Set True for Ver 1.1, False for 1.2
                         C      
                         C      ;****************************************************************************
                         C      
  FFFF                   C      ZS	EQU	TRUE      		; Set True for ZSDOS, False for ZDDOS
                         C      
                         C      ;----------
                         C      ;   Select assembler for ZSDOS.  Any modifications to source code must
                         C      ; support these assemblers at minimum.
                         C      
  FFFF                   C      SLR	EQU	TRUE		; SLR Z80ASM or SLR180 Assembler, OR ZMAC
  0000                   C      ZAS	EQU	FALSE 		; MITEK/ECHELON ZAS Assembler (3.0 or later)
                         C      
                         C      	  IF ZAS
                         C      	NAME	DOS
                         C      	  ENDIF
                         C      
                         C      	  IF  SLR
                         C      	.Z80
                         C      	NAME	('DOS')
                         C      	  ENDIF
                         C      
                         C      	  IF ZAS AND ZS
                         C      	   IF  ZSDOS11
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-3


                         C      	.TITLE	'ZSDOS 1.1 - Enhanced CP/M BDOS Replacement'
                         C      	   ELSE		;~Zsdos11
                         C      	.TITLE	'ZSDOS 1.2 - Enhanced CP/M BDOS Replacement'
                         C      	   ENDIF	;Zsdos11
                         C      	  ENDIF
                         C      	  IF ZAS AND (NOT ZS)
                         C      	   IF  ZSDOS11
                         C      	.TITLE	'ZDDOS 1.1 - Enhanced CP/M BDOS Replacement w/DS'
                         C      	   ELSE		;~Zsdos11	
                         C      	.TITLE	'ZDDOS 1.2 - Enhanced CP/M BDOS Replacement w/DS'
                         C      	   ENDIF	;Zsdos11
                         C      	  ENDIF
                         C      
                         C      	  IF SLR AND ZS
                         C      	   IF  ZSDOS11
                         C      	TITLE	"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"
                         C      	   ELSE		;~Zsdos11
                         C      	TITLE	"ZSDOS 1.2 - Enhanced CP/M BDOS Replacement"
                         C      	   ENDIF	;Zsdos11
                         C      	  ENDIF
                         C      	  IF SLR AND (NOT ZS)
                         C      	   IF  ZSDOS11
                         C      	TITLE	"ZDDOS 1.1 - Enhanced CP/M BDOS Replacement w/DS"
                         C      	   ELSE		;~Zsdos11	
                         C      	TITLE	"ZDDOS 1.2 - Enhanced CP/M BDOS Replacement w/DS"
                         C      	   ENDIF	;Zsdos11
                         C      	  ENDIF
                         C      
                         C      ;----------
                         C      ;   P2DOS introduced a search path feature compatible with that used in
                         C      ; Richard Conn's ZCPR2 and ZCPR3.  If a requested file is not located in
                         C      ; the currently logged Drive/User, the SEARCH routine will sequentially
                         C      ; scan along the path until either the file is found or the end of the
                         C      ; path is reached.
                         C      
                         C      	  IF	ZS
  EDF1                   C      PATHAD	EQU	IPATH		; Set to the desired ZCPR2/3 search path.
                         C      	  ELSE			; use 0000H to disable path.  A short
                         C      PATHAD	EQU	00000H		; 3 element internal path is provided
                         C      	  ENDIF			; in ZSDOS.  ZDDOS does not use path.
                         C      
                         C      ;----------
                         C      ;   The WHEEL byte may be sensed from within ZSDOS by setting the following
                         C      ; address to that of the ZCPR3 WHEEL byte.  A value of 0 disables the WHEEL
                         C      ; byte sensing.
                         C      
  0000                   C      WHLADR	EQU	00000H		; Set WHEEL byte address (0FDFFH for SB180)
                         C      
                         C      ;----------
                         C      ;   Some systems, like the Kaypro 4, only recognize changes between single
                         C      ; and double-sided disks when the system is warm booted; BDOS Function 13
                         C      ; (reset disk) will not work.  By adding a "hook" to the BIOS of these mach-
                         C      ; ines and setting RESDSK to TRUE, BDOS functions 13 and 37 will allow changes
                         C      ; between single and double-sided disks; very handy for disk housekeeping
                         C      ; utilities such as NSWP, NULU, and cataloging programs.
                         C      
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-4


                         C      ;   The "hook" is added as follows: Obtain the source to your computer's BIOS.
                         C      ; Examine the code for WARM BOOT.  Somewhere, there should be a call to a rou-
                         C      ; tine which initializes the disk system after a warm boot, or which detects
                         C      ; changes between single and double-sided disks.  Call this routine DISKINT
                         C      ; for purposes of discussion.  Modify your BIOS's cold boot routine to ini-
                         C      ; tialize 3 bytes at address SETDSK as "JP DISKINT".  The location of SETDSK
                         C      ; is arbitrary, it may be in your BIOS, or in a reserved spot in CP/M's page 0.
                         C      
  0000                   C      RESDSK	EQU	FALSE
                         C      
                         C         IF	   RESDSK
                         C      SETDSK	EQU	004BH		; Set to suit your system (bh)
                         C         ENDIF		; resdsk (bh)
                         C      
                         C      ;----------
                         C      ;   The following equate is used to produce separate code and data segments
                         C      ; for blowing ZSDOS into ROM.  Calling BDOS Function 0 will initialize the
                         C      ; Data Segment to default values.
                         C      
  0000                   C      ROM	EQU	FALSE		; Separate data and code?
                         C      
                         C      ;----------
                         C      ;   Many ZSDOS features can be controlled while ZSDOS is running by altering
                         C      ; the FLAG byte.  Set the following equate to your desired configuration based
                         C      ; on your requirements.  The individual bit assignments in the FLAG byte are:
                         C      ;
                         C      ; Bit -	7 6 5 4 3 2 1 0
                         C      ;	 \ \ \ \ \ \ \ \__Public File Enable (1) / Disable (0)
                         C      ;	  \ \ \ \ \ \ \___Public/Path Write Enable (1) / Disable (0)
                         C      ;	   \ \ \ \ \ \____Read-Only Enable (1) / Disable (0)
                         C      ;	    \ \ \ \ \_____Fast Fixed Disk Relog Enable (1) / Disable (0)
                         C      ;	     \ \ \ \______Disk Change Warning Enable (1) / Disable (0)
                         C      ;	      \ \ \_______ZCPR2/3 Path Enable (1) / Disable (0)
                         C      ;	       \ \________Path without System Enable (1) / Disable (0)
                         C      ;		\_________(Reserved)
                         C      
  006D                   C      FLGBITS	EQU	01101101B	; PUBLIC On, P/P Write Off, R/O On, 
                         C      				; Fast Relog On,Disk Change warning Off, 
                         C      				; Path On, No System path On
                         C      
                         C      ; The operation of Bit 6 represents a deviation from the description of PUBLIC
                         C      ; Files as given in DDJ Article by Bridger Mitchell and Derek McKay of Plu*
                         C      ; Perfect Systems.  The PUBLIC Specification states that Public Files will NOT
                         C      ; be found by any wildcard reference except when a "?" is in the FCB+0 byte.
                         C      ; The code here relaxes that requirement as follows:  If we are in the same
                         C      ; user area as the public file, then don't report the file as PUBLIC, but find
                         C      ; it.  This has a nasty side effect - it allows erasing of PUBLIC files if we
                         C      ; are in the same area.  However, these files also show up on the directory
                         C      ; (they wouldn't otherwise), so at least we should know we're blasting them.
                         C      
                         C      ;----------
                         C      ; Equates for selecting ZSDOS or ZDDOS configurations
                         C      
                         C      ; Since much ZSDOS code must be deleted to embed DateStamper in ZDDOS, the
                         C      ; following flags do the stripping:
                         C      ;	PICKEY	- True = Don't save users' DE register
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-5


                         C      ;	CTLREN	- True = Add ^R Retype line to cons read, False = No ^R
                         C      ;	UNROLL	- True = Inline code for shifts, False = collapse into loops
                         C      ;	UPATH	- True = Add User path from OS, False = No OS path search
                         C      
                         C      	  IF ZS
  FFFF                   C      CTLREN	EQU	TRUE
  FFFF                   C      UNROLL	EQU	TRUE
  FFFF                   C      UPATH	EQU	TRUE
  0000                   C      PICKEY	EQU	FALSE
                         C      	  ELSE
                         C      CTLREN	EQU	FALSE
                         C      UNROLL	EQU	FALSE
                         C      UPATH	EQU	FALSE
                         C      PICKEY	EQU	FALSE
                         C      	  ENDIF
                         C      
                         C      ;----------
                         C      ; To Use the Named-COMMON aspect of NZCOM and JETLOADER (tm), the BIOS must
                         C      ; be referenced from the _BIOS_ name.  If operating under this scheme, set
                         C      ; the ZRL equate to TRUE.  With the ZRL equate set to FALSE, a standalone
                         C      ; .REL file will be produced with no external requirements.
                         C      
  0000                   C      ZRL	EQU	FALSE		; Set True .ZRL file with COMMON for NZCOM,
                         C      				;     False to produce straight .REL file
                                
  0000                          RAMLOW	EQU	0000H		; Start address memory
                                
                                ;	CSEG			; removed psco
  E000                          ZSDOS	EQU	$		; Start address ZSDOS
                                
                                	  IF  	ZRL
                                	COMMON	/_BIOS_/
                                BIOS:
                                	CSEG
                                	  ELSE
  EE00                          BIOS	EQU	ZSDOS+0E00H
                                	  ENDIF
                                
  EE00                          BOOT	EQU	BIOS+0000H	; Cold Boot
  EE03                          WBOOT	EQU	BIOS+0003H	; Warm Boot
  EE06                          CONST	EQU	BIOS+0006H	; Console Status
  EE09                          CONIN	EQU	BIOS+0009H	; Console Input
  EE0C                          CONOUT	EQU	BIOS+000CH	; Console Output
  EE0F                          LIST	EQU	BIOS+000FH	; List Output
  EE12                          PUNCH	EQU	BIOS+0012H	; Punch Output
  EE15                          READER	EQU	BIOS+0015H	; Reader Input
  EE18                          HOME	EQU	BIOS+0018H	; Home Disk
  EE1B                          SELDSK	EQU	BIOS+001BH	; Select Disk
  EE1E                          SETTRK	EQU	BIOS+001EH	; Select Track
  EE21                          SETSEC	EQU	BIOS+0021H	; Select Sector
  EE24                          SETDMA	EQU	BIOS+0024H	; Set DMA Address
  EE27                          READ	EQU	BIOS+0027H	; Read 128 Bytes
  EE2A                          WRITE	EQU	BIOS+002AH	; Write 128 Bytes
  EE2D                          LISTST	EQU	BIOS+002DH	; List Status
  EE30                          SECTRN	EQU	BIOS+0030H	; Sector Translation
                                
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-6


                                ; Internal Definitions
                                	  IF  ZSDOS11
  0001                          VERMAJ	EQU	1		; Major version number
  0001                          VERMIN	EQU	1		; Minor version number
                                	  ELSE
                                VERMAJ	EQU	1
                                VERMIN	EQU	2
                                	  ENDIF		;Zs
  0011                          VERS	EQU	VERMAJ*10H+VERMIN
                                
  0003                          CONTC	EQU	03H		; Key to generate warm boot
  0008                          CONTH	EQU	08H		; Backspace
  0009                          TAB	EQU	09H		; Tab
  000A                          LF	EQU	0AH		; Line feed
  000D                          CR	EQU	0DH		; Carriage return
  0010                          CONTP	EQU	10H		; Set/reset print flag
  0012                          CONTR	EQU	12H		; Retype line
  0013                          CONTS	EQU	13H		; Stop console output
  0018                          CONTX	EQU	18H		; Delete line (backspaces)
  0015                          CONTU	EQU	15H		; Same as Control-X
  007F                          RUBOUT	EQU	7FH		; Delete last char
                                
  001F                          MAXEXT	EQU	1FH		; Maximum extent number
  003F                          MAXMOD	EQU	3FH		; Maximum data module number
                                
  0091                          TDCKSM	EQU	91H		; CHECKSUM OF !!!TIME&.DAT
                                
                                ; Attribute Bit Definitions
                                
  0002                          PUBATT	EQU	2		; Public attribute offset
  0007                          PSFATT	EQU	7		; Public/system file (internal only)
  0008                          WHLATT	EQU	8		; Wheel protect attribute offset
  0009                          ROATT	EQU	9		; Read only attribute offset
  000A                          SYSATT	EQU	10		; System attribute offset
  000B                          ARCATT	EQU	11		; Archive attribute offset
                                
                                ; FCB POSITION EQUATES
                                
  000C                          FCBEXT	EQU	12		; Extent number
  000D                          FCBUSR	EQU	13		; User valid at offset 13 if set (internal)
  000E                          FCBMOD	EQU	14		; Data module number - D7 used as unmod flag
  000F                          FCBREC	EQU	15		; Record number
  0020                          NXTREC	EQU	32		; Next record number
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-7


                                
                                ;**************************************************************
                                ;*	 Z S D O S	P r o g r a m	  S t a r t	      *
                                ;**************************************************************
                                
                                ; WARNING!!  Do NOT change labels or sequences of ZSDOS through ZSDOS+25H
                                ;   ID string added for easy identification in running system (hfb)
                                
                                	  IF  ZS
  E000    00 00 00 00           	DEFB	0,0,0,0,0,0	; psco, Used in CP/M for serial number. these bytes
  E004    00 00                 
                                ;	DEFB	'ZSDOS '	; Used in CP/M for serial number. these bytes
                                	  ELSE			; are patched by INSTALOS to contain the serial
                                	DEFB	'ZDDOS '	; Number of the running system so MOVCPM can
                                	  ENDIF			; still be used without problems.
                                
                                ; ZSDOS Entry Point
                                
  E006    C3 E09B               START:	JP	ENTRY		; Jump to start of program code
                                
                                ; CP/M 2.2 Compatable Error Vector Table
                                
  E009    E34C                  STBDSC:	DEFW	ERROR		; Bad sector message
  E00B    E34C                  STSEL:	DEFW	ERROR		; Select error
  E00D    E34C                  STRO:	DEFW	ERROR		; Drive read only
  E00F    E34C                  SFILRO:	DEFW	ERROR		; File read only
                                
                                ; External Path Name
                                
  E011    EDF1                  PATH:	DEFW	PATHAD		; Path address for file open, 0 if no path
                                
                                ; Wheel Byte Pointer
                                
  E013    0000                  WHEEL:	DEFW	WHLADR		; Address of wheel byte, 0 if none
                                
                                ; User configuration byte
                                
  E015    6D                    FLAGS:	DEFB	FLGBITS		; Flag byte set in zsdos.lib
                                
                                ; Dispatch table for time/date stamp routines
                                
                                ; ZSDOS uses all vectors in this table as indicated.  ZDDOS uses all but
                                ; STUPDV, GETSTV, and PUTSTV.  STCRV is used to store the address of the
                                ; stamp for ZDDOS, thus allowing ZSCONFIG to enable and disable stamping
                                ; of Last Access and Modify.
                                
  E016    EDDD                  GSTIME:	DEFW	DOTDER		; Address of get/set time/date routine (hfb)
                                	  IF	ZS
  E018    EDDD                  STLAV:	DEFW	DOTDER		; Address of stamp last access routine
  E01A    EDDD                  STCRV:	DEFW	DOTDER		; Address of stamp create routine
  E01C    EDDD                  STUPDV:	DEFW	DOTDER		; Address of stamp modify routine
                                	  ELSE
                                STLAV:	DEFW	STIME		; Address of stamp last access routine
                                STCRV:	DEFW	STIME		; Address of stamp create routine
                                STUPDV:	DEFW	STIME		; Address of stamp modify routine
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-8


                                	  ENDIF
  E01E    EDDD                  GETSTV:	DEFW	DOTDER		; Address of get stamp routine
  E020    EDDD                  PUTSTV:	DEFW	DOTDER		; Address of set stamp routine
  E022    EDDD                  	DEFW	DOTDER		; Dummy vector to disable with ZSCONFIG
  E024    0000                  UNLOAD:	DEFW	0		; Pointer to remove Time Stamp routine
                                
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-9


                                
                                ;********************************************************
                                ;*	 Z S D O S	L o w	 R A M	 D a t a	*
                                ;********************************************************
                                
                                ; RAM has been moved down here to an area that is compatable with ZRDOS per
                                ; suggestion by Hal Bower.  The actual addresses used are NOT compatable with
                                ; ZRDOS.
                                
                                ; Due to ZSDOS's smaller RAM area, any program that saves RAM in accordance
                                ; with ZRDOS's specifications for re-entry into BDOS should work under ZSDOS
                                ; without problems.  Some code will be saved also, as well as the Flag Byte,
                                ; but this should be no problem for IOP'S.
                                
                                ; The Write Protect, Login, and Hard Disk Login Vectors are kept at the top of
                                ; ZSDOS, as they must reflect the current status of the Disk System and hence
                                ; should NOT be saved with other system variables Under ANY Circumstance!
                                
                                	  IF  ROM
                                	DSEG
                                	  ENDIF
  E026                          BGLORAM:
                                ;--------------------------------------------------------------------
                                ; The following locations MUST remain in EXACTLY this order
                                
  E026    00                    TABCNT:	DEFB	0		; Tab counter
  E027    00                    TABCX1:	DEFB	0		; Temporary Tab counter (used by RDBUF)
                                ;--------------------------------------------------------------------
                                
  E028    00                    FCONTP:	DEFB	0		; List enable flag (Control-P) - used by BGii
  E029    00                    LASTCH:	DEFB	0		; Last character - used by BGii
                                
                                ;--------------------------------------------------------------------
                                ; The following locations MUST remain in EXACTLY this order
                                
  E02A    00                    USER:	DEFB	0		; User number - used by BGii
  E02B    00                    DEFDRV:	DEFB	0		; Default drive number - used by BGii and DS
  E02C    00                    DRIVE:	DEFB	0		; Drive number
                                ;--------------------------------------------------------------------
                                
  E02D    00                    FCB0:	DEFB	0		; FCB byte 0
                                
  E02E                          BGHIRAM:
  E02E    0080                  DMA:	DEFW	0080H		; DMA address
                                
  E030    0000                  TRANS:	DEFW	0		; Translation vector
  E032    0000                  TEMP0:	DEFW	0		; Number of files on drive
                                
                                
  E034    0000                  DIRBUF:	DEFW	0		; Directory buffer pointer - used by bgii
  E036    0000                  IXP:	DEFW	0		; Disk parameter block
  E038    0000                  CSV:	DEFW	0		; Check sum pointer
  E03A    0000                  ALV:	DEFW	0		; Allocation vector pointer
                                
                                ;--------------------------------------------------------------------
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-10


                                ; The following locations MUST remain in EXACTLY this order
                                ; Copy of DPB for Current Drive
                                
  003C                          DPBOF	EQU	$-ZSDOS		; Value needed by ZSDOS
                                
  E03C    0000                  MAXSEC:	DEFW	0		; Number of sectors/track
  E03E    00                    NBLOCK:	DEFB	0		; Block shift
  E03F    00                    NMASK:	DEFB	0		; Mask number of blocks
  E040    00                    NEXTND:	DEFB	0		; Extent mask
  E041    0000                  MAXLEN:	DEFW	0		; Maximum block number-1
  E043    0000                  NFILES:	DEFW	0		; Maximum number of files-1
  E045    00                    NDIR0:	DEFB	0		; First two entries ALV buffer
  E046    00                    	DEFB	0		; ..(NDIR1)
  E047    0000                  NCHECK:	DEFW	0		; Number of checksum entries
  E049    0000                  NFTRK:	DEFW	0		; First track number
                                ;--------------------------------------------------------------------
  E04B    00                    FUNCT:	DEFB	0		; Function number
  E04C    0000                  PEXIT:	DEFW	0		; Exit code
                                ;--------------------------------------------------------------------
                                ; The following locations MUST remain in EXACTLY this order
                                
  E04E    00                    FLDRV:	DEFB	0		; Drive select used flag
  E04F    00                    RDWR:	DEFB	0		; Read/write flag
  E050    00                    SEARQU:	DEFB	0		; Search question mark used
  E051    00                    SEARPU:	DEFB	0		; Search public file
                                ;--------------------------------------------------------------------
  E052    0000                  RECDIR:	DEFW	0		; Record directory (checksum)
  E054    0000                  FILCNT:	DEFW	0		; File counter
  E056    00                    SECPNT:	DEFB	0		; Sector pointer
  E057    00                    SUBFLG:	DEFB	0		; Submit flag (reset disk command)
                                
  E058    0000                  DCOPY:	DEFW	0		; Copy address FCB
  E05A    00                    SEAREX:	DEFB	0		; Exit code search
  E05B    00                    SEARNB:	DEFB	0		; Search number of bytes
  E05C    00                    ERMODE:	DEFB	0		; BDOS error mode
                                
  E05D    0000                  ARWORD:	DEFW	0		; De argument on entry - used for BGii
  E05F    0000                  DEVAL:	DEFW	0		; Return value for DE reg
  E061    0000                  SPSAVE:	DEFW	0		; Stack pointer location
                                	  IF  ZS
  E063    5A 53 44 4F           	DEFB	'ZSDOS 1.1 Copyri'
  E067    53 20 31 2E           
  E06B    31 20 43 6F           
  E06F    70 79 72 69           
                                	  ELSE
                                	DEFB	'ZDDOS 1.1 Copyri'
                                	  ENDIF
  E073    67 68 74 20           	DEFB	'ght (c) 1987,88 '
  E077    28 63 29 20           
  E07B    31 39 38 37           
  E07F    2C 38 38 20           
  E083    20 43 2E 57           	DEFB	' C.W.Cotrill & H'
  E087    2E 43 6F 74           
  E08B    72 69 6C 6C           
  E08F    20 26 20 48           
  E093    2E 46 2E 42           	DEFB	'.F.Bow'
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-11


  E097    6F 77                 
  E099    65 72                 IXSAVE:	DEFB	'er'		; User's IX register
  E09B                          ZSDOSS:				; ZSDOS stack
                                
  E09B                          BGRAMTOP EQU	ZSDOSS
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-12


                                
                                ;	CSEG			; removed psco
                                ;**********************************************************************
                                ;*		 Z S D O S   e n t r y	 p o i n t		      *
                                ;**********************************************************************
                                
  E09B    AF                    ENTRY:	XOR	A		; Clear A
  E09C    47                    	LD	B,A		; For later 16 bit adds
  E09D    6F                    	LD	L,A
  E09E    67                    	LD	H,A		; Set HL to zero
  E09F    22 E04C               	LD	(PEXIT),HL	; Clear exit code
  E0A2    22 E04E               	LD	(FLDRV),HL	; Reset drive select and R/W flags
  E0A5    ED 73 E061            	LD	(SPSAVE),SP	; Save stack pointer
  E0A9    31 E09B               	LD	SP,ZSDOSS	; Get internal stack pointer
  E0AC    DD E5                 	PUSH	IX		; Save index register on our stack
  E0AE    D5                    	PUSH	DE		; Save parameter register
  E0AF    DD E1                 	POP	IX		; Get it back in IX
  E0B1    DD 22 E05D            	LD	(ARWORD),IX	; Save in memory for BGii
                                	  IF  NOT PICKEY
  E0B5    DD 22 E05F            	LD	(DEVAL),IX	; ..and for non-file access returns
                                	  ENDIF
  E0B9    21 E3E6               	LD	HL,DOSEXIT	; Get exit address ZSDOS
  E0BC    E5                    	PUSH	HL		; Save it on stack to return from ZSDOS
  E0BD    79                    	LD	A,C		; Get function code - B reg = 0
  E0BE    32 E04B               	LD	(FUNCT),A	; Save it for later use
  E0C1    FE 0C                 	CP	12		; Is it a non-disk function?
  E0C3    38 0D                 	JR	C,ENTRY0	; ..jump if so
  E0C5    FE 31                 	CP	MAXCMD		; Cmnd < Maximum Command Number (48)?
  E0C7    38 0D                 	JR	C,ENTRY1	; ..jump if disk function
                                
                                ; Extended function scanner for added functions
                                
  E0C9    FE 62                 	CP	98		; Is it less than Cmd98?
  E0CB    D8                    	RET	C		; ..return if so
  E0CC    FE 68                 	CP	103+1		; Is it greater than Cmd103?
  E0CE    D0                    	RET	NC		; ..quit if so
  E0CF    D6 31                 	SUB	98-MAXCMD	; Rework so 98-->49..103-->54
  E0D1    4F                    	LD	C,A		; Save reworked function #
                                			; ..fall thru to entry0..
                                
                                ; If Non-disk Function (ie Function # less than 12), push the address of
                                ;  the SAVEA routine on the Stack (save A reg as return code).	Saves
                                ;  code in Console Routines, as simple RET can be used in most cases.
                                
  E0D2    21 E4BB               ENTRY0:	LD	HL,SAVEA
  E0D5    E5                    	PUSH	HL		; Vector return thru A reg save
  E0D6    21 E0E2               ENTRY1:	LD	HL,CTABLE	; Load table
  E0D9    09                    	ADD	HL,BC		; Add
  E0DA    09                    	ADD	HL,BC		; Add twice to get word value
  E0DB    7E                    	LD	A,(HL)		; Get LSB
  E0DC    23                    	INC	HL		; Pointer to MSB
  E0DD    66                    	LD	H,(HL)		; Get MSB
  E0DE    6F                    	LD	L,A		; Save LSB in L
                                
                                ; Copy byte argument into A and C to simplify Function calls.  This allows
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-13


                                ;  direct BIOS jumps for several functions with resulting code savings.
                                
  E0DF    4B                    	LD	C,E		; Place arg in C for BIOS
  E0E0    7B                    	LD	A,E		; And in A for others
  E0E1    E9                    	JP	(HL)		; Jump to routine
                                
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-14


                                
                                ;******************************************************
                                ;*	 C O M M A N D	    T A B L E		      *
                                ;******************************************************
  E0E2                          CTABLE:
                                	  IF  ROM
                                	DEFW	RAMINI		; Set up RAM
                                	  ELSE
  E0E2    E3CA                  	DEFW	ERROR5		; Warm boot (BIOS) with ERMODE clear
                                	  ENDIF
  E0E4    E150                  	DEFW	CMND01		; Console input
  E0E6    E264                  	DEFW	WRCON		; Console output
  E0E8    EE15                  	DEFW	READER		; Reader input (BIOS)
  E0EA    EE12                  	DEFW	PUNCH		; Punch output (BIOS)
  E0EC    EE0F                  	DEFW	LIST		; List output (BIOS)
  E0EE    E15A                  	DEFW	CMND06		; Direct console I/O
  E0F0    E191                  	DEFW	CMND07		; Get I/O byte
  E0F2    E18E                  	DEFW	CMND08		; Set I/O byte
  E0F4    E2D5                  	DEFW	CMND09		; Print string
  E0F6    E195                  	DEFW	CMND10		; Read console buffer
  E0F8    E2B7                  	DEFW	CMND11		; Get console status
  E0FA    E4CF                  	DEFW	CMND12		; Return version number
  E0FC    E40A                  	DEFW	CMND13		; Reset disk system
  E0FE    E57A                  	DEFW	CMND14		; Select disk
  E100    EAB4                  	DEFW	CMND15		; Open file
  E102    E7A8                  	DEFW	CMND16		; Close file
  E104    E46E                  	DEFW	CMND17		; Search for first
  E106    E495                  	DEFW	CMND18		; Search for next
  E108    E4A5                  	DEFW	CMND19		; Delete file
  E10A    EBBE                  	DEFW	CMND20		; Read sequential
  E10C    EBFF                  	DEFW	CMND21		; Write sequential
  E10E    EB02                  	DEFW	CMND22		; Make file
  E110    E4B0                  	DEFW	CMND23		; Rename file
  E112    E4E8                  	DEFW	CMND24		; Return login vector
  E114    E4B8                  	DEFW	CMND25		; Return current disk
  E116    E833                  	DEFW	CMND26		; Set DMA address
  E118    E4E4                  	DEFW	CMND27		; Get address allocation vector
  E11A    E703                  	DEFW	CMND28		; Write protect disk
  E11C    E4DC                  	DEFW	CMND29		; Get R/O vector
  E11E    E4C7                  	DEFW	CMND30		; Set file attributes
  E120    E4EC                  	DEFW	CMND31		; Get address disk parameter header (DPH)
  E122    E4FB                  	DEFW	CMND32		; Get/set user code
  E124    EBB4                  	DEFW	CMND33		; Read random
  E126    EBF4                  	DEFW	CMND34		; Write random
  E128    E507                  	DEFW	CMND35		; Compute file size
  E12A    E50F                  	DEFW	CMND36		; Set random record
  E12C    E41A                  	DEFW	CMND37		; Reset multiple drive
  E12E    E4BE                  	DEFW	DUMMY		; Function 38 (unused)
  E130    E4E0                  	DEFW	CMND39		; Return fixed disk login vector
  E132    EBF4                  	DEFW	CMND40		; Write random with zero fill
  E134    E4BE                  	DEFW	DUMMY		; Function 41 (unused)
  E136    E4BE                  	DEFW	DUMMY		; Function 42 (unused)
  E138    E4BE                  	DEFW	DUMMY		; Function 43 (unused)
  E13A    E4BE                  	DEFW	DUMMY		; Function 44 (unused)
  E13C    E4F7                  	DEFW	CMND45		; Set Error Mode
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-15


  E13E    E4BE                  	DEFW	DUMMY		; Function 46 (unused)
  E140    E4F0                  	DEFW	CMND47		; Return DMA
  E142    E4D8                  	DEFW	CMND48		; Return DOS version
                                
  0031                          MAXCMD	EQU	($-CTABLE)/2	; Jww
                                
  E144    EDD7                  	DEFW	CMD98		; Get Time	; 49
  E146    EDD4                  	DEFW	CMD99		; Set Time	; 50
  E148    E4C2                  	DEFW	CMD100		; Get Flags	; 51
  E14A    E4BF                  	DEFW	CMD101		; Set Flags	; 52
  E14C    EDA4                  	DEFW	CMD102		; Get Stamp	; 53
  E14E    EDA4                  	DEFW	CMD103		; Put Stamp	; 54
                                
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-16


                                
                                ;******************************************************
                                ;*	 N o n - D i s k     F u n c t i o n s	      *
                                ;******************************************************
                                
                                	  IF  ROM
                                
                                ; Initialize RAM in Data Segment (ROM Systems Only)
                                
                                RAMINI:	LD	B,SPSAVE-BGLORAM ; Size of low RAM data segment (less stack)
                                	XOR	A
                                	LD	HL,BGLORAM	; Start of RAM
                                RAMIN1:	LD	(HL),A		; Clear first byte
                                	INC	HL
                                	DJNZ	RAMIN1		; And everything else
                                	  IF  ZS		; Need Internal path if ZSDOS
                                	LD	HL,IPATH	; Point to start of Internal Path
                                	LD	B,HDLOG+2-IPATH-1 ; and fill high mem less first byte of path
                                	LD	(HL),01		; Set path to Drive = A
                                	INC	HL		; ..point to user and Null (Sets user=0)
                                	  ELSE			; No Path if ZDDOS
                                	LD	HL,TDFVCT
                                	LD	B,HDLOG+2-TDFVCT ; Now high RAM
                                	  ENDIF		;Zs
                                RAMIN2:	LD	(HL),A
                                	INC	HL
                                	DJNZ	RAMIN2
                                	LD	HL,RAMLOW+80H	; Default DMA buffer
                                	LD	(DMA),HL	; And save it
                                	RST	0		; Now BIOS warm boot
                                	  ENDIF		; Rom
                                
                                ;.....
                                ; I/O Routines
                                
                                ; ZSDOS Console Input.	Read character from Console and Echo
                                ;  If Char=CR,LF,TAB,CONTH or >=Space
                                
  E150    CD E175               CMND01:	CALL	GETCH		; Get character (and test it  jww)
  E153    D8                    	RET	C		; Less than space, exit
  E154    E5                    PUTCH:	PUSH	HL		; Save regs for other calls
  E155    CD E264               	CALL	WRCON		; Echo character
  E158    E1                    	POP	HL
  E159    C9                    	RET
                                
                                ; Direct Console Input/Output
                                ;  Call with Char in C and E - Enhanced to CP/M-3 Spec
                                ;  Checks ZSDOS typeahead for reliable console I/O under all conditions
                                ;  as per a suggestion by Bridger Mitchell.
                                
  E15A    1C                    CMND06:	INC	E		; Test if get char if avail
  E15B    28 14                 	JR	Z,DCIO1		; Yes do input
  E15D    1C                    	INC	E		; Test for 0FEH
  E15E    28 06                 	JR	Z,DCIO2		; Yes, get status
  E160    1C                    	INC	E		; Test for 0FDH
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-17


  E161    28 12                 	JR	Z,GETCH		; Yes, wait for input char
  E163    C3 EE0C               	JP	CONOUT		; Else print char
                                
  E166    3A E029               DCIO2:	LD	A,(LASTCH)	; Check for buffered char
  E169    B7                    	OR	A
  E16A    3E 01                 	LD	A,0001B		; ..preset ready
  E16C    CC EE06               	CALL	Z,CONST		; Get console status
  E16F    A7                    	AND	A		; Test it
  E170    C9                    	RET			; And return it to caller
                                
  E171    CD E166               DCIO1:	CALL	DCIO2		; Get console status
  E174    C8                    	RET	Z		; Exit if no character present
                                				; Else fall thru
                                ; Get Character from Console
                                
  E175    21 E029               GETCH:	LD	HL,LASTCH	; Check ZSDOS type ahead for char
  E178    7E                    	LD	A,(HL)
  E179    36 00                 	LD	(HL),0		; Reset last character
  E17B    B7                    	OR	A		; ..set flags
  E17C    CC EE09               	CALL	Z,CONIN		; Get character (and test it  jww)
                                
                                ; Test Character
                                ;  Exit Carry=0: CR,LF,TAB,CONTH or >= Space
                                ;	Carry=1: All other Characters
                                
  E17F    FE 0D                 	CP	CR		; Is it a carriage return?
  E181    C8                    	RET	Z		; ..return if so
  E182    FE 0A                 	CP	LF		; Is it a line feed?
  E184    C8                    	RET	Z		; ..return if so
  E185    FE 09                 	CP	TAB		; Is it a tab?
  E187    C8                    	RET	Z		; ..return if so
  E188    FE 08                 	CP	CONTH		; Is it a backspace?
  E18A    C8                    	RET	Z		; ..return if so
  E18B    FE 20                 	CP	' '		; Test >=space
  E18D    C9                    	RET			; ..and return to caller
                                
                                ; Set I/O Status Byte
                                
  E18E    32 0003               CMND08:	LD	(RAMLOW+0003H),A ; And save it in RAM and fall through
                                
                                ; Get I/O Status Byte
                                
  E191    3A 0003               CMND07:	LD	A,(RAMLOW+0003H) ; Get I/O byte from RAM
  E194    C9                    	RET
                                
                                ; Buffered Console Read
                                
  E195    3A E026               CMND10:	LD	A,(TABCNT)
  E198    32 E027               	LD	(TABCX1),A	; Save start tab position
  E19B    13                    	INC	DE
  E19C    AF                    	XOR	A
  E19D    12                    	LD	(DE),A		; Set char count to zero
  E19E    13                    	INC	DE		; Point to actual buffer start
                                
  E19F    D5                    RDBUF1:	PUSH	DE		; Save buffer pointer
  E1A0    CD E175               	CALL	GETCH		; Get next byte from user
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-18


  E1A3    D1                    	POP	DE
  E1A4    21 E19F               	LD	HL,RDBUF1
  E1A7    E5                    	PUSH	HL		; Return address to stack
  E1A8    2A E05D               	LD	HL,(ARWORD)
  E1AB    4E                    	LD	C,(HL)		; Put buffer length in C
  E1AC    23                    	INC	HL		; And point to current length
                                
  E1AD    FE 0D                 	CP	CR
                                	  IF  CTLREN
  E1AF    28 02                 	JR	Z,JZRBX		; Exit if CR
                                	  ELSE
                                	JR	Z,RDBUFX
                                	  ENDIF		;Ctlren
                                
  E1B1    FE 0A                 	CP	LF
                                	  IF  CTLREN
  E1B3    CA E24E               JZRBX:	JP	Z,RDBUFX	; ..or LF
                                	  ELSE
                                	JR	Z,RDBUFX
                                	  ENDIF		;Ctlren
                                			;..Not CR or LF, so fall thru to next test
                                
                                ; Delete Character from Buffer
                                ;  RUB, Backspace, CR, LF are NEVER in the Buffer
                                
  E1B6    FE 7F                 RDBUF2:	CP	RUBOUT		; Delete char?
  E1B8    28 04                 	JR	Z,DOBACK	; ..jump if so
  E1BA    FE 08                 	CP	CONTH		; Control-H also deletes
  E1BC    20 36                 	JR	NZ,RDBUF3	; Skip to next test if no delete
                                
  E1BE    7E                    DOBACK:	LD	A,(HL)
  E1BF    A7                    	AND	A		; Test if attempting del from empty line
  E1C0    C8                    	RET	Z		; ..Exit if so
  E1C1    1B                    DOBAK0:	DEC	DE		; Back up to last character
  E1C2    35                    	DEC	(HL)		; Erase from buffer
  E1C3    D5                    	PUSH	DE		; Save buffer pointer
  E1C4    46                    	LD	B,(HL)		; Get new char count
  E1C5    23                    	INC	HL		; Point to first char
  E1C6    EB                    	EX	DE,HL
  E1C7    21 E026               	LD	HL,TABCNT
  E1CA    4E                    	LD	C,(HL)		; Save current Tab count
  E1CB    23                    	INC	HL
  E1CC    7E                    	LD	A,(HL)		; Get starting Tab position
  E1CD    2B                    	DEC	HL
  E1CE    77                    	LD	(HL),A		; Init the counter
  E1CF    04                    	INC	B		; Insure non-zero
  E1D0    18 05                 	JR	DOBAK2		; Jump to done test
                                
  E1D2    1A                    DOBAK1:	LD	A,(DE)		; Get char from buffer
  E1D3    CD E293               	CALL	WRCON2		; Counts chars
  E1D6    13                    	INC	DE
  E1D7    10 F9                 DOBAK2:	DJNZ	DOBAK1		; Continue count until done
  E1D9    79                    	LD	A,C		; Get prior tab count
  E1DA    96                    	SUB	(HL)		; Get diff between new and old
  E1DB    47                    	LD	B,A		; Set up as count
  E1DC    71                    	LD	(HL),C		; Restore prior count
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-19


  E1DD    D1                    	POP	DE		; Restore buffer pointer
                                
                                ; Delete B Characters from Console
                                
  E1DE    D5                    	PUSH	DE		; Save pointer
  E1DF    0E 08                 DOBAK5:	LD	C,CONTH
  E1E1    C5                    	PUSH	BC		; Save counter from destruction
  E1E2    CD EE0C               	CALL	CONOUT
  E1E5    0E 20                 	LD	C,' '
  E1E7    CD EE0C               	CALL	CONOUT		; Output backspace,space to CON: only
  E1EA    3E 08                 	LD	A,CONTH
  E1EC    CD E264               	CALL	WRCON		; Now backspace CON:, counter, and printer
  E1EF    C1                    	POP	BC		; Restore counter
  E1F0    10 ED                 	DJNZ	DOBAK5		; Loop until all done
  E1F2    D1                    	POP	DE		; Restore pointer
  E1F3    C9                    	RET
                                
                                ; Erase Buffer
                                
  E1F4    FE 15                 RDBUF3:	CP	CONTU		; Test erase line
  E1F6    28 04                 	JR	Z,ERALIN	; Do it if so
  E1F8    FE 18                 	CP	CONTX
  E1FA    20 0A                 	JR	NZ,RDBUF4	; Skip to next test if no erase line
                                
  E1FC    AF                    ERALIN:	XOR	A
  E1FD    B6                    	OR	(HL)		; Line empty?
  E1FE    C8                    	RET	Z		; Exit if so
  E1FF    E5                    	PUSH	HL
  E200    CD E1C1               	CALL	DOBAK0		; Else delete another (skip empty check)
  E203    E1                    	POP	HL
  E204    18 F6                 	JR	ERALIN
                                
  E206                          RDBUF4:			; If CTL-R=True, do following code, else bypass
                                	  IF  CTLREN
  E206    FE 12                 	CP	CONTR		; If ^R, type clean buffer version on console
  E208    20 24                 	JR	NZ,RDBUF5
  E20A    E5                    	PUSH	HL		; Save pointer to buffer length
  E20B    CD E2D2               	CALL	CROUT		; Do CR/LF
  E20E    21 E026               	LD	HL,TABCNT
  E211    36 00                 	LD	(HL),0		; Init Tab count
  E213    23                    	INC	HL
  E214    46                    	LD	B,(HL)		; And get Tab offset count
  E215    3E 20                 	LD	A,' '
  E217    04                    	inc	b		; [1.1] insure nz value
  E218    18 03                 	jr	rety1a		; [1.1] so case of lh side of screen ok
  E21A    CD E264               RETYP1:	CALL	WRCON		; Space off start of line
  E21D    10 FB                 rety1a:	DJNZ	RETYP1
  E21F    E1                    	POP	HL		; Point to buffer length
  E220    46                    	LD	B,(HL)		; Get how many chars to print
  E221    23                    	INC	HL		; Restore buffer pointer
  E222    EB                    	EX	DE,HL		; Put buffer pointer in DE
  E223    04                    	INC	B		; Comp for first DJNZ
  E224    18 05                 	JR	RETYP3		; Skip to done test
  E226    1A                    RETYP2:	LD	A,(DE)		; Get char from buffer
  E227    CD E253               	CALL	WRCTL		; Output it
  E22A    13                    	INC	DE		; Bump pointer
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-20


  E22B    10 F9                 RETYP3:	DJNZ	RETYP2		; Loop until done
  E22D    C9                    	RET
                                	  ENDIF		; Ctlren
                                
                                ; Toggle Line Printer Echo
                                
  E22E    FE 10                 RDBUF5:	CP	CONTP		; Toggle printer?
  E230    20 07                 	JR	NZ,RDBUF6	; Next test if not
  E232    21 E028               	LD	HL,FCONTP
  E235    7E                    	LD	A,(HL)		; Get printer echo flag
  E236    2F                    	CPL			; Toggle it
  E237    77                    	LD	(HL),A		; Put back
  E238    C9                    	RET
                                
                                ; Check if Control-C is First char in BUFF and Exit if so
                                
  E239    12                    RDBUF6:	LD	(DE),A		; Put character in buffer
  E23A    E5                    	PUSH	HL
  E23B    CD E253               	CALL	WRCTL		; Echo the character
  E23E    E1                    	POP	HL
  E23F    34                    	INC	(HL)		; Increment the character count
                                
  E240    7E                    	LD	A,(HL)		; Get current length
  E241    B9                    	CP	C		; Test against buffer size
  E242    28 0A                 	JR	Z,RDBUFX
  E244    3D                    	DEC	A		; Set Z flag for first character
  E245    1A                    	LD	A,(DE)		; Get the character back
  E246    13                    	INC	DE		; ..and bump the pointer
  E247    C0                    	RET	NZ		; Return if not the first character
  E248    FE 03                 	CP	CONTC		; Possible user abort?
  E24A    C0                    	RET	NZ		; ..return if not
  E24B    C3 E3CA               	JP	ERROR5		; Else jump to error reset exit
                                
                                ; Done with Read Console Buffer Function
                                
  E24E    E1                    RDBUFX:	POP	HL		; Clear RDBUF1 return address
  E24F    3E 0D                 	LD	A,CR
  E251    18 11                 	JR	WRCON		; ..and echo a CR
                                
                                ; Print Control Character as '^X'
                                
  E253    FE 20                 WRCTL:	CP	' '		; Test if control char
  E255    30 0D                 	JR	NC,WRCON	; Not, send it out
  E257    FE 09                 	CP	TAB		; Test if Tab
  E259    28 0D                 	JR	Z,WRCON0	; It is, so expand with spaces
  E25B    F5                    	PUSH	AF		; Save char
  E25C    3E 5E                 	LD	A,'^'		; Output a karet
  E25E    CD E277               	CALL	WRCON1		; No need for Tab test here
  E261    F1                    	POP	AF
  E262    C6 40                 	ADD	A,40H		; Convert to printable
                                				; And fall thru to WRCON
                                
                                ; Output char with List Echo, Tab Expansion (Function 2)
                                
  E264    FE 09                 WRCON:	CP	TAB		; Is it a Tab?
  E266    20 0F                 	JR	NZ,WRCON1	; ..jump if not
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-21


  E268    3E 20                 WRCON0:	LD	A,' '		; Expand Tab with spaces
  E26A    CD E277               	CALL	WRCON1		; Write space
  E26D    3A E026               	LD	A,(TABCNT)	; Get Tab count
  E270    E6 07                 	AND	7		; Test if done
  E272    20 F4                 	JR	NZ,WRCON0	; No then repeat
  E274    3E 09                 	LD	A,TAB		; Return Tab
  E276    C9                    	RET			; Return to caller
                                
  E277    C5                    WRCON1:	PUSH	BC
  E278    D5                    	PUSH	DE		; Save pointers
  E279    4F                    	LD	C,A
  E27A    C5                    	PUSH	BC		; Save character
                                
  E27C                          BGPTCH0	EQU	$+1		;<-- BGii patches this address
                                
  E27B    CD E2B7               	CALL	CMND11		; Test status and CONTS/CONTC
  E27E    C1                    	POP	BC		; Get character back
  E27F    C5                    	PUSH	BC		; Save it again
  E280    CD EE0C               	CALL	CONOUT		; Output it
  E283    C1                    	POP	BC		; Get character back
  E284    C5                    	PUSH	BC		; Save it again
  E285    3A E028               	LD	A,(FCONTP)	; Get printer echo flag
  E288    B7                    	OR	A		; Test it
  E289    C4 EE0F               	CALL	NZ,LIST		; Non zero => output char to printer
  E28C    C1                    	POP	BC		; Restore character
  E28D    79                    	LD	A,C		; Fall through to count routine
  E28E    D1                    	POP	DE
  E28F    C1                    	POP	BC		; Restore pointers
                                
                                ; Count Characters in line as shown by f10
                                
  E290    21 E026               	LD	HL,TABCNT	; Get pointer to Tab counter
  E293    34                    WRCON2:	INC	(HL)		; Increment Tab counter
  E294    FE 7F                 	CP	RUBOUT		; Test if character = Rubout
  E296    28 15                 	JR	Z,WRCON3	; Treat like Backspace
  E298    FE 20                 	CP	' '
  E29A    D0                    	RET	NC		; Ok if not Control
  E29B    FE 09                 	CP	TAB		; Only DOBACK ever gets Tabs through here
  E29D    28 11                 	JR	Z,WRCON4	; Handle differently if Tab
  E29F    FE 08                 	CP	CONTH
  E2A1    28 0A                 	JR	Z,WRCON3	; Or Backspace
  E2A3    34                    	INC	(HL)		; Must have been echoed as two chars
  E2A4    FE 0A                 	CP	LF
  E2A6    28 05                 	JR	Z,WRCON3	; ..unless it's LF
  E2A8    FE 0D                 	CP	CR		; ..or CR
  E2AA    C0                    	RET	NZ
  E2AB    36 02                 	LD	(HL),2		; Reset Tab count
  E2AD    35                    WRCON3:	DEC	(HL)		; Decrement Tab counter
  E2AE    35                    	DEC	(HL)
  E2AF    C9                    	RET			; And exit
                                
  E2B0    3E 07                 WRCON4:	LD	A,7		; Bumped by one already
  E2B2    86                    	ADD	A,(HL)		; Tabs are every 8 spaces
  E2B3    E6 F8                 	AND	0F8H		; ...mod 8
  E2B5    77                    	LD	(HL),A		; Save updated Tab count
  E2B6    C9                    	RET			; ..and continue
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-22


                                
                                ; Get Console Status - BGII uses this routine
                                
  E2B7                          BGCONST:
  E2B7    CD E166               CMND11:	CALL	DCIO2		; Get character present status
  E2BA    C8                    	RET	Z		; ..exit if none
  E2BB    CD E175               	CALL	GETCH		; Get next console char
  E2BE    FE 13                 	CP	CONTS		; Is it stop char?
  E2C0    20 0A                 	JR	NZ,GCONS2	; ..jump if Not
  E2C2    CD EE09               	CALL	CONIN		; Get next character
  E2C5    FE 03                 	CP	CONTC		; Does the user want to exit (^C)?
  E2C7    20 EE                 	JR	NZ,CMND11	; ..check for another character if not
  E2C9    C3 E3CA               	JP	ERROR5		; Else jump to warm boot & clear ERMODE
                                
  E2CC    32 E029               GCONS2:	LD	(LASTCH),A	; Save character
  E2CF    3E 01                 	LD	A,1		; Character present code
  E2D1    C9                    	RET			; Return to caller
                                
                                ; Echo CR,LF
                                
  E2D2    11 E349               CROUT:	LD	DE,MCRLF	; Fall through to output routine
                                
                                ; Output Message
                                
  E2D5    1A                    CMND09:	LD	A,(DE)		; Get byte from buffer
  E2D6    FE 24                 	CP	'$'		; Test last byte
  E2D8    C8                    	RET	Z		; Yes, then return to caller
  E2D9    13                    	INC	DE		; Point to next byte
  E2DA    CD E264               	CALL	WRCON		; Output character
  E2DD    18 F6                 	JR	CMND09		; And test again
                                
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-23


                                
                                ;**********************************************
                                ;*	 E r r o r	R o u t i n e s       *
                                ;**********************************************
                                
  E2DF    01 0064               PRDEC:	LD	BC,100
  E2E2    CD E2ED               	CALL	NUM
  E2E5    0E 0A                 	LD	C,10
  E2E7    CD E2ED               	CALL	NUM
  E2EA    01 0101               	LD	BC,101H
                                
                                ; Display Number
                                
  E2ED    16 FF                 NUM:	LD	D,-1		; Load number -1
  E2EF    14                    NUM1:	INC	D		; Increment number
  E2F0    91                    	SUB	C		; Divide by C
  E2F1    30 FC                 	JR	NC,NUM1		; Not finished then loop
  E2F3    81                    	ADD	A,C		; Restore last value
  E2F4    F5                    	PUSH	AF		; Save it
  E2F5    7A                    	LD	A,D		; Test if "0"
  E2F6    B0                    	OR	B		; And if leading zero
  E2F7    28 07                 	JR	Z,NUM2		; Yes, then exit
  E2F9    47                    	LD	B,A		; Set no leading zero
  E2FA    7A                    	LD	A,D		; Get number
  E2FB    C6 30                 	ADD	A,'0'		; Make ASCII
  E2FD    CD E154               	CALL	PUTCH		; Echo number preserving BC
  E300    F1                    NUM2:	POP	AF		; Restore number
  E301    C9                    	RET			; And exit
                                
                                ; Error Messages
                                
  E302    43 68 61 6E           MDSKCH:	DEFB	'Changed$'
  E306    67 65 64 24           
                                
  E30A    42 61 64 20           MBADSC:	DEFB	'Bad Sector$'
  E30E    53 65 63 74           
  E312    6F 72 24              
                                
  E315    4E 6F 20 44           MSEL:	DEFB	'No Drive$'
  E319    72 69 76 65           
  E31D    24                    
                                
  E31E    46 69 6C 65           MFILRO:	DEFB	'File '
  E322    20                    
                                
  E323    57 2F 50 24           MRO:	DEFB	'W/P$'
                                	 IF ZS
  E327    5A 53 44 4F           MBERR:	DEFB	'ZSDOS'
  E32B    53                    
                                	 ELSE
                                MBERR:	DEFB	'ZDDOS'
                                	 ENDIF
  E32C    20 65 72 72           	DEFB	' error on $'
  E330    6F 72 20 6F           
  E334    6E 20 24              
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-24


                                	 
  E337    0D 0A 43 61           MBFUNC:	DEFB	CR,LF,'Call'
  E33B    6C 6C                 
  E33D    3A 20 24              MDRIVE:	DEFB	': $'
                                
  E340    20 20 46 69           MFILE:	DEFB	'  File: $'
  E344    6C 65 3A 20           
  E348    24                    
                                
  E349    0D 0A 24              MCRLF:	DEFB	CR,LF,'$'
                                
                                ; New ZSDOS error handler - enter w/ error code in B and message pointer
                                ; in DE
                                
  E34C    3A E05C               ERROR:	LD	A,(ERMODE)
  E34F    4F                    	LD	C,A		; Save error mode
  E350    0F                    	RRCA			; Test supress print
  E351    38 5C                 	JR	C,ERROR3	; Suppressed, so skip dsp
                                
                                ; Print ZSDOS Error on X: Explanation
                                
  E353    C5                    	PUSH	BC
  E354    D5                    	PUSH	DE		; Save params
  E355    CD E2D2               	CALL	CROUT		; Output CR/LF
  E358    11 E327               	LD	DE,MBERR
  E35B    CD E2D5               	CALL	CMND09		; Output ZSDOS error on
  E35E    3A E02B               	LD	A,(DEFDRV)	; Get current default drive
  E361    C6 41                 	ADD	A,'A'		; Convert to ascii
  E363    CD E264               	CALL	WRCON		; Output it to console
  E366    11 E33D               	LD	DE,MDRIVE	; Point to drive tag
  E369    CD E2D5               	CALL	CMND09		; Put it also
  E36C    D1                    	POP	DE		; Restore error message pointer
  E36D    CD E2D5               	CALL	CMND09		; Send message
                                
                                ; Now print CALL: XXX [FILE: XXXXXXXX.XXX]
                                
  E370    11 E337               	LD	DE,MBFUNC
  E373    CD E2D5               	CALL	CMND09		; Display 'call: '
  E376    3A E04B               	LD	A,(FUNCT)	; Get function number
  E379    CD E2DF               	CALL	PRDEC		; Output it
  E37C    3A E04E               	LD	A,(FLDRV)
  E37F    A7                    	AND	A		; Was FCB used?
  E380    28 29                 	JR	Z,ERROR2	; ..Skip file name display if not
  E382    C1                    	POP	BC
  E383    C5                    	PUSH	BC		; Get error type
  E384    DD E5                 	PUSH	IX		; Save FCB pointer
  E386    3A E04B               	LD	A,(FUNCT)	; ARE WE ERASING A FILE?
  E389    FE 13                 	CP	19		; IF SO, GET NAME FROM DIRBUF AS
  E38B    20 04                 	JR	NZ,ERROR0	; AMBIG NAME MAY HAVE BEEN USED
  E38D    CD E6F1               	CALL	CALDIR		; Get DIR buffer pointer
  E390    E3                    	EX	(SP),HL		; To show what we really gagged on
  E391    11 E340               ERROR0:	LD	DE,MFILE
  E394    CD E2D5               	CALL	CMND09		; Output 'file: '
  E397    E1                    	POP	HL		; Point to FCB
  E398    06 0B                 	LD	B,11		; Output this many chars
  E39A    23                    ERROR1:	INC	HL
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-25


  E39B    3E 03                 	LD	A,3
  E39D    B8                    	CP	B		; Time to send '.'?
  E39E    3E 2E                 	LD	A,'.'		; Get ready for it
  E3A0    CC E154               	CALL	Z,PUTCH		; Send it if time
  E3A3    7E                    	LD	A,(HL)		; Get char
  E3A4    E6 7F                 	AND	7FH		; Mask attributes
  E3A6    CD E154               	CALL	PUTCH		; Output it
  E3A9    10 EF                 	DJNZ	ERROR1
  E3AB    CD E2D2               ERROR2:	CALL	CROUT		; Send CR,LF
  E3AE    C1                    	POP	BC		; Get error mode back
  E3AF    3E 04                 ERROR3:	LD	A,4
  E3B1    90                    	SUB	B		; Test if select error
  E3B2    20 0D                 	JR	NZ,ERROR4	; Skip if not
  E3B4    21 E02C               	ld	hl,drive	; point to old default
  E3B7    7E                    	ld	a,(hl)		; get it
  E3B8    2B                    	dec	hl		; point to bad drive
  E3B9    BE                    	cp	(hl)		; same?
  E3BA    28 05                 	jr	z,error4	; if so, skip relog
  E3BC    C5                    	PUSH	BC
  E3BD    CD E581               	CALL	SELDK		; Get BIOS back in step
  E3C0    C1                    	POP	BC
  E3C1    CB 49                 ERROR4:	BIT	1,C		; Test if return error mode
  E3C3    20 18                 	JR	NZ,ERROR7	; Go if return error
  E3C5    3E 01                 	LD	A,1
  E3C7    90                    	SUB	B		; Test if fatal error
  E3C8    30 05                 	JR	NC,ERROR6	; If not a fatal error
  E3CA    AF                    ERROR5:	XOR	A
  E3CB    32 E05C               	LD	(ERMODE),A	; Set DOS error mode to default CP/M
  E3CE    C7                    	RST	0		; ..and leave
                                
  E3CF    CD E171               ERROR6:	CALL	DCIO1		; Get console char if present
  E3D2    A7                    	AND	A		; Test if any
  E3D3    20 FA                 	JR	NZ,ERROR6	; Keep getting them until typeahead eaten
  E3D5    CD E175               	CALL	GETCH		; Now get operator's response
  E3D8    FE 03                 	CP	CONTC		; Test if abort
  E3DA    C0                    	RET	NZ		; If operator said ignore error
  E3DB    18 ED                 	JR	ERROR5		; Else boot
                                
  E3DD    78                    ERROR7:	LD	A,B		; Get error
  E3DE    67                    	LD	H,A		; Save code in H reg for return
  E3DF    A7                    	AND	A		; Test if disk changed warning
  E3E0    C8                    	RET	Z		; Continue relog if so
  E3E1    2E FF                 	LD	L,0FFH		; Set extended error code
  E3E3    22 E04C               	LD	(PEXIT),HL	; Save as return code
                                			; ..and fall thru to DOS exit
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-26


                                
                                ;******************************************************
                                ;*	 D O S	   E x i t    R o u t i n e	      *
                                ;******************************************************
                                
  E3E6    3A E04E               DOSEXIT: LD	A,(FLDRV)	; Test drive select used flag
  E3E9    B7                    	OR	A
  E3EA    28 0C                 	JR	Z,DOSEXT0	; No then exit
  E3EC    3A E02D               	LD	A,(FCB0)	; Get FCB byte 0
  E3EF    DD 77 00              	LD	(IX+0),A	; Save it
  E3F2    3A E02C               	LD	A,(DRIVE)	; Get old drive number
  E3F5    CD E581               	CALL	SELDK		; Select disk
                                	  IF  PICKEY
                                	LD	DE,(DEVAL)	; And DE reg for datestamper
                                	  ENDIF
                                
                                ; If the error handler was invoked, the stack is in an undefined
                                ;  condition at this point.  We therefore have to restore the user's
                                ;  IX register independent of stack position.  Thanks to Joe Wright's
                                ;  eagle eye for catching this one!
                                
  E3F8    ED 7B E061            DOSEXT0: LD	SP,(SPSAVE)	; Restore user stack
  E3FC    DD 2A E099            	LD	IX,(IXSAVE)	; Restore IX (stack is don't care)
  E400    2A E04C               	LD	HL,(PEXIT)	; Get exit code
                                	  IF  NOT PICKEY
  E403    ED 5B E05F            	LD	DE,(DEVAL)	; And DE reg for DateStamper
                                	  ENDIF
  E407    7D                    	LD	A,L		; Copy function code
  E408    44                    	LD	B,H
  E409    C9                    	RET			; And return to caller
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-27


                                
                                ;******************************************************
                                ;*	 D i s k     F u n c t i o n s		      *
                                ;******************************************************
                                
                                ; Reset Disk System
                                
  E40A    21 0080               CMND13:	LD	HL,RAMLOW+0080H	; Set up DMA address
  E40D    22 E02E               	LD	(DMA),HL	; And save it
  E410    CD E837               	CALL	STDMA		; Do BIOS call
  E413    AF                    	XOR	A		; Set default drive = 'A'
  E414    32 E02B               	LD	(DEFDRV),A	; Save it
  E417    11 FFFF               	LD	DE,0FFFFH	; Reset all drives
                                
                                ; Reset Multiple Login Drive - DE = Reset mask
                                ; Fixed Disk Login vector is also altered by this call
                                
  E41A    CD E45D               CMND37:	CALL	UNLOG		; Clear selected drives in DE from login
  E41D    3A E015               	LD	A,(FLAGS)
  E420    CB 57                 	BIT	2,A		; Test hard R/O enabled
  E422    20 06                 	JR	NZ,UNWPT1	; If enabled
  E424    21 EDFC               	LD	HL,DSKWP	; Get drive W/P vector
  E427    CD E466               	CALL	ANDDEM		; Reset W/P stat only of requested drvs
  E42A    3A E04B               UNWPT1:	LD	A,(FUNCT)
  E42D    FE 0D                 	CP	13		; Skip hard disk login change?
  E42F    21 EDFE               	LD	HL,HDLOG
  E432    C4 E466               	CALL	NZ,ANDDEM	; Clear HD Login Vector if Fcn 37
  E435                          RELOG1:
                                	  IF  ZS
  E435    2A EDFE               	LD	HL,(HDLOG)
  E438    CD E658               	CALL	HLORDE		; Don't clear fixed disks from T/D
  E43B    EB                    	EX	DE,HL		; Place modified logout in DE
  E43C    21 EDF8               	LD	HL,TDFVCT
  E43F    CD E466               	CALL	ANDDEM		; Clear T/D vector as needed
                                	  ENDIF
                                
  E442    3A E02B               	LD	A,(DEFDRV)	; Get default drive
  E445    F5                    	PUSH	AF
  E446                          RELOG2:
                                	  IF  RESDSK		; (bh)
                                	CALL	SETDSK		; Allow BIOS to detect density change (bh)
                                	  ELSE
  E446    00 00 00              	DEFB	0,0,0		; Make 3 NOP's to keep constant code (hfb)
                                	  ENDIF			; (bh)
  E449    F1                    	POP	AF
  E44A    CD E581               	CALL	SELDK		; Select default drive
                                
                                ; ZSDOS watches for any $*.* in any user on any drive during re-log,
                                ; make, and delete.  In this manner, SUBFLG will always be valid -
                                ; even under fast relog and NZCOM!  Thanks to Joe Wright for suggesting
                                ; the need for this, and suggesting ways to do it.
                                
  E44D    3A E057               SUBEXT:	LD	A,(SUBFLG)	; Get submit flag
  E450    18 69                 	JR	SAVEA		; Exit
                                
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-28


                                ; Check for possible existance of submit file by checking first
                                ; byte of dir entry or FCB for '$'.  Pointer to dir or FCB passed
                                ; to routine in HL.
                                
  E452    23                    CKSUB:	INC	HL		; Point to file name
  E453    7E                    	LD	A,(HL)		; Get first char filename
  E454    2B                    	DEC	HL
  E455    D6 24                 	SUB	'$'		; Test if '$'
  E457    C0                    	RET	NZ		; Not then exit
  E458    3D                    	DEC	A		; Load a with 0FFH
  E459    32 E057               	LD	(SUBFLG),A	; Save it in subflg
  E45C    C9                    	RET
                                
                                ; Unlog Drive mask in DE
                                
  E45D    7B                    UNLOG:	LD	A,E		; Get LSB
  E45E    2F                    	CPL			; Complement it
  E45F    5F                    	LD	E,A
  E460    7A                    	LD	A,D		; Get MSB
  E461    2F                    	CPL			; Complement it
  E462    57                    	LD	D,A		; DE = not reset
  E463    21 EDFA               	LD	HL,LOGIN	; Get addr of login vector
  E466    7B                    ANDDEM:	LD	A,E		; Clear login bits of reset drives
  E467    A6                    	AND	(HL)		; ..a byte at a time
  E468    77                    	LD	(HL),A		; Put to memory
  E469    23                    	INC	HL
  E46A    7A                    	LD	A,D
  E46B    A6                    	AND	(HL)
  E46C    77                    	LD	(HL),A
  E46D    C9                    	RET
                                
                                ; Search for File
                                
  E46E    CD E51F               CMND17:	CALL	SELDRV		; Select drive from FCB
  E471    DD 7E 00              	LD	A,(IX+0)
  E474    D6 3F                 	SUB	'?'		; Test if '?'
  E476    28 0D                 	JR	Z,CMD17B	; If so all entries match
  E478    DD 7E 0E              	LD	A,(IX+FCBMOD)	; Get system byte
  E47B    FE 3F                 	CP	'?'		; Test if '?'
  E47D    28 04                 	JR	Z,CMD17A	; Yes, jump
  E47F    DD 36 0E 00           	LD	(IX+FCBMOD),0	; Load system byte with Zero
  E483    3E 0F                 CMD17A:	LD	A,15		; Test first 15 items in FCB
  E485    CD E8F3               CMD17B:	CALL	SEARCH		; Do search
  E488    2A E034               CMD17C:	LD	HL,(DIRBUF)	; Copy directory buffer
  E48B    01 0080               	LD	BC,128		; Directory=128 bytes
  E48E    ED 5B E02E            MV2DMA:	LD	DE,(DMA)	; To DMA address
  E492    ED B0                 	LDIR
  E494    C9                    	RET			; Exit
                                
                                ; Search for Next Occurence of File
                                
  E495    DD 2A E058            CMND18:	LD	IX,(DCOPY)	; Get last FCB used by search
  E499    DD 22 E05D            	LD	(ARWORD),IX	; Save FCB pointer for BGii
  E49D    CD E51F               	CALL	SELDRV		; Select drive from FCB
  E4A0    CD E90A               	CALL	SEARCN		; Search next file match
  E4A3    18 E3                 	JR	CMD17C		; And copy directory to DMA address
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-29


                                
                                ; Delete File
                                
  E4A5    CD E51F               CMND19:	CALL	SELDRV		; Select drive from FCB
  E4A8    CD E86D               	CALL	DELETE		; Delete file
  E4AB    3A E05A               CMD19A:	LD	A,(SEAREX)	; Get exit byte 00=file found, 0FFH=Not
  E4AE    18 0B                 	JR	SAVEA		; And exit
                                
                                ; Rename File
                                
  E4B0    CD E51F               CMND23:	CALL	SELDRV		; Select drive from FCB
  E4B3    CD E9D7               	CALL	RENAM		; Rename file
  E4B6    18 F3                 	JR	CMD19A		; And exit
                                
                                ; Return Current Drive
                                
  E4B8    3A E02B               CMND25:	LD	A,(DEFDRV)	; Get current drive
  E4BB    32 E04C               SAVEA:	LD	(PEXIT),A	; Return character
  E4BE    C9                    DUMMY:	RET			; ..and exit ZSDOS
                                
                                ; Set flags
                                
  E4BF    32 E015               CMD101:	LD	(FLAGS),A	; Set ZSDOS flags
                                				; ..and fall thru
                                ; Get flags
                                
  E4C2    3A E015               CMD100:	LD	A,(FLAGS)	; Get ZSDOS flags
  E4C5    18 F4                 	JR	SAVEA		; ..and exit
                                
                                ; Change Status
                                
  E4C7    CD E51F               CMND30:	CALL	SELDRV		; Select drive from FCB
  E4CA    CD EA02               	CALL	CSTAT		; Change status
  E4CD    18 DC                 	JR	CMD19A		; And exit
                                
                                ; Return CP/M Version Number
                                
  E4CF                          ZDPCH1:
  E4CF    21 0022               CMND12:	LD	HL,22H		; Set CP/M compatable version number
                                	  IF  NOT ZS		; (crw)
                                	CP	'D'		; IS Caller testing for DS?
                                	JR	NZ,SAVHL	; ..exit if Not
                                	LD	A,(UNLOAD+1)	; See if Clock was installed by testing
                                				; ..MSB of Remove vector
                                	AND	A		; ..if it's zero, then No Clock
                                	JR	Z,SAVHL		; ..and No DateStamper
                                	LD	H,E		; Otherwise, return DS Active Flag
                                	LD	DE,CMD98A	; Have a clock, so get Clock Address
                                	  ENDIF
                                	  IF  NOT PICKEY
  E4D2    ED 53 E05F            	LD	(DEVAL),DE	; In case DS gave us a clock addr
                                	  ENDIF
  E4D6    18 1B                 	JR	SAVHL		; For speed
                                
                                ; Following commands return status in like manner and are consolidated here
                                ; in selected order with least-accessed commands taking longest to traverse
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-30


                                ; string, and frequently accessed/time critical exitting quickest.
                                
                                ; The code in this section is a bit obscure, as it depends on burying
                                ; instructions within other instructions.  6502 users have long used the
                                ; 'BIT' trick to skip instructions - this inspired me to see if similar
                                ; things could be done with the Z80.  Indeed they can, as this demonstrates.
                                ; When the Z80 jumps in at a label, it executes the LD HL instruction.	The
                                ; DEFB 0DDH turns the LD HL instructions that follow into LD IX.  In effect,
                                ; this turns the DEFB 0DDH into a one byte relative jump to SAVHL.  As IX
                                ; is never used by these calls, its loss is of no consequence.
                                ; A similar trick is used in SEAR15, resulting in a useless LD HL but
                                ; saving a byte.
                                
                                ; New Universal Return Version FUNCTION 48
                                
  E4D8                          CMND48:
                                	  IF  ZS
  E4D8    21 5311               	LD	HL,'S' SHL 8 + VERS ;"S" indicates ZSDOS - ZRDOS returns 0
                                	  ELSE
                                	LD	HL,'D' SHL 8 + VERS ;"D" indicates ZDDOS - ZRDOS returns 0
                                	  ENDIF
  E4DB    DD                    	DEFB	0DDH		; Trash IX and fall through
                                
                                ; Return Disk W/P Vector
                                
  E4DC    2A EDFC               CMND29:	LD	HL,(DSKWP)	; Get disk W/P vector
  E4DF    DD                    	DEFB	0DDH		; Trash IX and fall through
                                
                                ; Return Fixed Disk Login Vector
                                
  E4E0    2A EDFE               CMND39:	LD	HL,(HDLOG)	; Return fixed disk login vector
  E4E3    DD                    	DEFB	0DDH		; Trash IX and fall through
                                
                                ; Return ALV Vector
                                
  E4E4    2A E03A               CMND27:	LD	HL,(ALV)	; Get allocation vector
  E4E7    DD                    	DEFB	0DDH		; Trash IX and fall through
                                
                                ; Return Login Vector
                                
  E4E8    2A EDFA               CMND24:	LD	HL,(LOGIN)	; Get login vector
  E4EB    DD                    	DEFB	0DDH		; Trash IX and fall through
                                
                                ; Return Drive Table
                                
  E4EC    2A E036               CMND31:	LD	HL,(IXP)	; Get drive table
  E4EF    DD                    	DEFB	0DDH		; Trash IX and fall through
                                
                                ; Return Current DMA
                                
  E4F0    2A E02E               CMND47:	LD	HL,(DMA)	; Return current DMA addr
  E4F3    22 E04C               SAVHL:	LD	(PEXIT),HL	; Save it
  E4F6    C9                    	RET			; And exit
                                
                                ; Set BDOS Error Mode
                                
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-31


  E4F7    32 E05C               CMND45:	LD	(ERMODE),A	; Save error mode
  E4FA    C9                    	RET			; And exit
                                
                                ; Set/Get User Code
                                
  E4FB    21 E02A               CMND32:	LD	HL,USER		; Point to user byte location
  E4FE    3C                    	INC	A		; Test if 0FFH
  E4FF    7E                    	LD	A,(HL)		; Get old user code
  E500    28 B9                 	JR	Z,SAVEA		; If 0FFH then exit
  E502    7B                    	LD	A,E		; Get new user code
  E503    E6 1F                 	AND	01FH		; Mask it
  E505    77                    	LD	(HL),A		; Save it
  E506    C9                    	RET			; And exit
                                
                                ; Compute File Size Command
                                
  E507    CD E52D               CMND35:	CALL	SELDR1		; Select drive from FCB
  E50A    CD EA2B               	CALL	FILSZ		; Compute file size
  E50D    18 9C                 	JR	CMD19A		; And exit
                                
                                ; Set Random Record Count
                                
  E50F    21 0020               CMND36:	LD	HL,32		; Set pointer to next record
  E512    CD ED7F               	CALL	CALRRC		; Calculate random record count
  E515    DD 72 21              LDRRC:	LD	(IX+33),D	; And save random record count
  E518    DD 71 22              	LD	(IX+34),C
  E51B    DD 70 23              	LD	(IX+35),B
  E51E    C9                    	RET			; And exit
                                
                                ; Select Disk From FCB
                                
  E51F                          BGSELDRV:
  E51F    3A E05C               SELDRV:	LD	A,(ERMODE)	; Are we in modified user mode?
  E522    A7                    	AND	A
  E523    20 08                 	JR	NZ,SELDR1	; Jump if so, else..
  E525    2A E05D               	LD	HL,(ARWORD)	;
  E528    01 000D               	LD	BC,FCBUSR	; Point to user number
  E52B    09                    	ADD	HL,BC		;
  E52C    77                    	LD	(HL),A		; Clear user flag
  E52D    3E FF                 SELDR1:	LD	A,0FFH		; Set disk select done flag
  E52F    32 E04E               	LD	(FLDRV),A
  E532    3A E02B               	LD	A,(DEFDRV)	; Get current drive
  E535    5F                    	LD	E,A		; Save it in register E
  E536    2A E05D               	LD	HL,(ARWORD)
  E539    7E                    	LD	A,(HL)		; Get drive from FCB
  E53A    32 E02D               	LD	(FCB0),A	; Save it
  E53D    FE 3F                 	CP	'?'		; Test if '?'
  E53F    28 39                 	JR	Z,CMND14	; Yes, then select drive from register E
  E541    DD E5                 	PUSH	IX		; Save BGii's IX register
                                				; IX won't be altered on cmnd14
  E543    DD 2A E05D            	LD	IX,(ARWORD)	; Get FCB pointer
                                ;1.1a Changed to allow proper access to Drive P:
                                ;1.2a	AND	0FH		; Mask drive
  E547    E6 1F                 	AND	1FH		;1.2a Mask Drive
  E549    E5                    	PUSH	HL
  E54A    28 02                 	JR	Z,SELDR0	; Select drive from register E
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-32


  E54C    5E                    	LD	E,(HL)		; Get drive from FCB
  E54D    1D                    	DEC	E		; Decrement drive number so A=0
  E54E    CD E57A               SELDR0:	CALL	CMND14		; - do select of drive
  E551    E1                    	POP	HL		; Restore FCB pointer
                                
                                ; Resolve User for FCB - FCBPTR in IX, Returns User in A
                                
  E552    DD 7E 0D              	LD	A,(IX+FCBUSR)	; ..get potential user in case
  E555    CB 7F                 	BIT	7,A		; Is this a valid user?
  E557    20 07                 	JR	NZ,RESUS1	; Skip if there is
  E559    3A E02A               	LD	A,(USER)	; Get user number
  E55C    18 02                 	JR	RESUS1		; ..and bypass push IX
                                
                                ; Set User in FCB to Value passed in A
                                
  E55E    DD E5                 RESUSR:	PUSH	IX		; Preserve IX
  E560    DD 2A E05D            RESUS1:	LD	IX,(ARWORD)
  E564    E6 1F                 	AND	1FH		; User number in A
  E566    DD 77 00              	LD	(IX+0),A	; Save in FCB 0 byte
  E569    F6 80                 	OR	80H		; Set valid DOS user flag
  E56B    DD 77 0D              	LD	(IX+FCBUSR),A	; ..and in FCB 13 byte
  E56E    DD E1                 	POP	IX		; Restore caller's IX
  E570    C9                    	RET
                                
                                ; Select Disk Error Exit - The stack is off by one level here, but
                                ;  this is a one way trip anyway.
                                
  E571    2A E00B               SELDK3:	LD	HL,(STSEL)	; Load error message address
  E574    06 04                 	LD	B,4		; Select error
  E576    11 E315               	LD	DE,MSEL		; Load select error message
  E579    E9                    	JP	(HL)		; And display error
                                
                                ; Select Disk from E register
                                
  E57A    3A E02B               CMND14:	LD	A,(DEFDRV)	; Get current drive
  E57D    32 E02C               	LD	(DRIVE),A	; Save it in memory
  E580    7B                    	LD	A,E		; Copy drive number
                                
                                ; Select Disk
                                ;  Call w/ A = Drive Number (0..15 = A..P)
                                
  E581    2A EDFA               SELDK:	LD	HL,(LOGIN)	; Get login vector
  E584    E6 0F                 	AND	0FH		; Mask drive number
  E586    47                    	LD	B,A		; Save counter
  E587    C4 E661               	CALL	NZ,SHRHLB	; ..and rotate into position
  E58A    EB                    SELDK0:	EX	DE,HL		; Put drive bit mask in DE
  E58B    21 E02B               	LD	HL,DEFDRV	; Get pointer last drive
  E58E    CB 43                 	BIT	0,E		; Test if drive logged in
  E590    28 02                 	JR	Z,SELDK2	; No, login drive
  E592    BE                    	CP	(HL)		; Test same drive
  E593    C8                    	RET	Z		; Yes then exit
                                
                                ; NOTE: A long standing DOS bug concerns the SELECT function.  If a
                                ;  function 14 call is made and the drive doesn't exist, the default
                                ;  will still point to the bad drive unless we fix it in the error
                                ;  routine.  It is for this reason that drive is saved above.  We must
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-33


                                ;  allow default to assume the illegal drive value long enough for the
                                ;  error handler to print it, then re-select the old default.
                                
  E594    77                    SELDK2:	LD	(HL),A		; Save new current drive
  E595    D5                    	PUSH	DE		; Save drive logged in flag
  E596    4F                    	LD	C,A		; Copy drive number
  E597    CD EE1B               	CALL	SELDSK		; Do BIOS select
  E59A    7C                    	LD	A,H		; Test if error
  E59B    B5                    	OR	L
  E59C    28 D3                 	JR	Z,SELDK3	; Yes, illegal drive number
  E59E    11 E030               	LD	DE,TRANS	; Point to local translation store
  E5A1    01 0002               	LD	BC,2		; ..and move 2-byte ptr in
  E5A4    ED B0                 	LDIR
  E5A6    22 E032               	LD	(TEMP0),HL	; Save address temp0
  E5A9    0E 06                 	LD	C,6		; Advance to dirbuf part of DPH
  E5AB    09                    	ADD	HL,BC		; As TEMP1 and TEMP2 unused in P?DOS
  E5AC    11 E034               	LD	DE,DIRBUF	; Load DIRBUF pointer
  E5AF    0E 08                 	LD	C,8		; Copy 8 bytes
  E5B1    ED B0                 	LDIR
  E5B3    2A E036               	LD	HL,(IXP)	; Get drive parameter address
  E5B6    0E 0F                 	LD	C,15		; Copy 15 bytes
  E5B8    ED B0                 	LDIR
  E5BA    D1                    	POP	DE		; Get drive logged in flag
  E5BB    CB 43                 	BIT	0,E		; Test it
  E5BD    C0                    	RET	NZ		; Drive logged in so return
  E5BE    CD E647               	CALL	GETCDM
  E5C1    EB                    	EX	DE,HL		; Drive mask in DE
  E5C2    2A EDFA               	LD	HL,(LOGIN)	; Get login vector
  E5C5    CD E658               	CALL	HLORDE		; Set drive bit in login vector
  E5C8    22 EDFA               	LD	(LOGIN),HL	; Save login vector
  E5CB    3A E015               	LD	A,(FLAGS)	; Get flags
  E5CE    CB 5F                 	BIT	3,A		; Fast relog enabled?
  E5D0    28 2A                 	JR	Z,INITDR	; Skip if disabled
                                
                                ; The following code checks the WACD size to determine if the drive
                                ;  being selected is a fixed disk.  If the WACD size is 0, the disk
                                ;  is Non-Removable.  However, several BIOSes support remapping of
                                ;  logical drives.  This complicates matters because BDOS must catch
                                ;  the swap and clear the Hard Disk Allocation Vector and allow the
                                ;  allocation bitmaps to be rebuilt.  Thus, every disk that is being
                                ;  selected for the first time traverses this code.  If a disk was
                                ;  logged as a fixed disk and all of the sudden has a WACD buffer,
                                ;  the Fixed Disk Login Vector is cleared.  Thus, for Bug-free
                                ;  operation of Fast Fixed Disk Logging, if drives are swapped
                                ;  NEVER SWAP TWO FIXED DRIVES!
                                
  E5D2    2A E047               	LD	HL,(NCHECK)	; Is this a fixed drive?
  E5D5    7C                    	LD	A,H
  E5D6    B5                    	OR	L
  E5D7    4F                    	LD	C,A		; Save fixed disk flag (Z=true)
  E5D8    2A EDFE               	LD	HL,(HDLOG)
  E5DB    7B                    	LD	A,E		; See if logged as fixed disk
  E5DC    A5                    	AND	L
  E5DD    6F                    	LD	L,A
  E5DE    7A                    	LD	A,D
  E5DF    A4                    	AND	H		; MSB
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-34


  E5E0    B5                    	OR	L		; Z flag set if HL and DE = 0
  E5E1    3E FF                 	LD	A,0FFH		; Don't alter flags
  E5E3    28 01                 	JR	Z,SELDK4	; If not logged as fixed disk
  E5E5    3C                    	INC	A		; Else flag as logged
  E5E6    47                    SELDK4:	LD	B,A		; Save logged as fixed disk flag (Z=true)
  E5E7    B1                    	OR	C		; Test if still fixed disk
  E5E8    C8                    	RET	Z		; Skip re-map if logged and not swapped
  E5E9    AF                    	XOR	A
  E5EA    67                    	LD	H,A
  E5EB    6F                    	LD	L,A		; Null vector
  E5EC    B0                    	OR	B		; Was it logged as a fixed disk?
  E5ED    28 0A                 	JR	Z,SELDK5	; Invalidate HDLOG vector - drive no longer
                                				; Fixed disk
  E5EF    79                    	LD	A,C
  E5F0    B7                    	OR	A		; Wasn't fixed disk before - is it now?
  E5F1    20 09                 	JR	NZ,INITDR	; Skip vector update if it isn't
  E5F3    2A EDFE               	LD	HL,(HDLOG)
  E5F6    CD E658               	CALL	HLORDE		; Else add this drive to fixed disk vector
  E5F9    22 EDFE               SELDK5:	LD	(HDLOG),HL	; Update fixed disk vector
                                			;..fall thru to INITDR
                                
                                ; Init Drive
                                ;  Clear ALV Bit Buffer after Drive reset
                                
  E5FC    2A E041               INITDR:	LD	HL,(MAXLEN)	; Get length ALV buffer-1 (bits)
  E5FF    CD E65F               	CALL	SHRHL3		; Divide by 8 to get bytes
  E602    44                    	LD	B,H
  E603    4D                    	LD	C,L		; Counter to BC (will be count+1 cleared)
  E604    2A E03A               	LD	HL,(ALV)	; Get pointer ALV buffer
  E607    E5                    	PUSH	HL
  E608    54                    	LD	D,H
  E609    5D                    	LD	E,L
  E60A    13                    	INC	DE		; ALV buffer +1 in DE
  E60B    AF                    	XOR	A
  E60C    77                    	LD	(HL),A		; Clear first 8 bits
  E60D    ED B0                 	LDIR			; And remainder of buffer
  E60F    E1                    	POP	HL		; Get ALV pointer
  E610    ED 5B E045            	LD	DE,(NDIR0)	; Get first two bytes ALV buffer
  E614    73                    	LD	(HL),E		; Save LSB
  E615    23                    	INC	HL		; Increment pointer
  E616    72                    	LD	(HL),D		; Save MSB
  E617    2A E032               	LD	HL,(TEMP0)	; Clear number of files on this drive
  E61A    77                    	LD	(HL),A		; Clear LSB (A still has 0)
  E61B    23                    	INC	HL		; Increment pointer
  E61C    77                    	LD	(HL),A		; Clear MSB
                                
  E61D                          ZDPCH2	EQU	$		;<-- Intercept first scan (ZDS Patch)
  E61D    CD E6FC               	CALL	SETFCT		; Set file count
  E620    3E FF                 INITD2:	LD	A,0FFH		; Update directory checksum
  E622    CD E730               	CALL	RDDIR		; Read FCB's from directory
  E625    CD E71C               	CALL	TSTFCT		; Test last FCB
  E628    CA E44D               	JP	Z,SUBEXT	; Return subflg for strict CP/M compat (hfb)
  E62B    CD E6F1               	CALL	CALDIR		; Calculate entry point FCB
  E62E    7E                    	LD	A,(HL)		; Get first byte FCB
  E62F    FE E5                 	CP	0E5H		; Test empty directory entry
  E631    28 ED                 	JR	Z,INITD2	; Yes then get next FCB
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-35


  E633    FE 21                 	CP	021H		; Test time stamp
  E635    28 E9                 	JR	Z,INITD2	; Yes then get next FCB
                                
  E637                          ZDPCH3	EQU	$		;<-- Test for T&D if first time (ZDS Patch)
  E637    CD E452               	CALL	CKSUB		; Test for submit file
  E63A    0E 01                 	LD	C,1		; Set bit in ALV buffer
  E63C    CD E883               	CALL	FILLBB		; Set bits from FCB in ALV buffer
  E63F    CD E723               	CALL	TSTLF		; Test for last file
  E642    D4 E714               	CALL	NC,SETLF0	; ..and update the last file count if so
  E645    18 D9                 	JR	INITD2		; And get next FCB
                                
                                ; Return Mask for Current Drive in HL
                                
  E647    21 0000               GETCDM:	LD	HL,0		; No drives to Or
                                
                                ; Set Drive bit in HL
                                
  E64A    EB                    SDRVB:	EX	DE,HL		; Copy HL=>DE
  E64B    21 0001               	LD	HL,1		; Get mask drive "A"
  E64E    3A E02B               	LD	A,(DEFDRV)	; Get current drive
  E651    B7                    	OR	A		; Test if drive "A"
  E652    28 04                 	JR	Z,HLORDE	; Yes then done
  E654    29                    SDRVB0:	ADD	HL,HL		; Get next mask
  E655    3D                    	DEC	A		; Decrement drive counter
  E656    20 FC                 	JR	NZ,SDRVB0	; And test if done
  E658    7A                    HLORDE:	LD	A,D		; HL=HL or DE
  E659    B4                    	OR	H
  E65A    67                    	LD	H,A
  E65B    7B                    	LD	A,E
  E65C    B5                    	OR	L
  E65D    6F                    	LD	L,A
  E65E    C9                    	RET			; Exit
                                
  E65F    06 03                 SHRHL3:	LD	B,3		; Used in a few places
                                
                                ; Shift HL right logical B bits
                                
  E661    CB 3C                 SHRHLB:	SRL	H
  E663    CB 1D                 	RR	L		; Shift HL right one bit (divide by 2)
  E665    10 FA                 	DJNZ	SHRHLB
  E667    C9                    	RET
                                
                                ; Calculate Sector/Track Directory
                                
  E668    2A E054               STDIR:	LD	HL,(FILCNT)	; Get FCB counter directory
                                	  IF  UNROLL
  E66B    CB 3C                 	SRL	H
  E66D    CB 1D                 	RR	L
  E66F    CB 3C                 	SRL	H		; (net cost: 3)
  E671    CB 1D                 	RR	L		; Divide by 4 (inline for speed)
                                	  ELSE
                                	LD	B,2
                                	CALL	SHRHLB		; Divide by 4
                                	  ENDIF
  E673    22 E052               	LD	(RECDIR),HL	; Save value (used by checksum)
  E676    EB                    STDIR2:	EX	DE,HL		; Copy it to DE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-36


  E677    21 0000               STDIR1:	LD	HL,0		; Clear HL
                                
                                ; Calculate Sector/Track
                                ;  Entry: HL,DE=Sector Number (128 byte sector)
                                ;  Result Set Track  =HL,DE  /	MAXSEC
                                ;	  Set Sector =HL,DE MOD MAXSEC
                                
  E67A    ED 4B E03C            CALST:	LD	BC,(MAXSEC)	; Get sectors/track
  E67E    3E 11                 	LD	A,17		; Set up loop counter
  E680    B7                    CALST0:	OR	A
  E681    ED 42                 	SBC	HL,BC		; HL > BC?
  E683    3F                    	CCF
  E684    38 02                 	JR	C,CALST1	; Yes then jump
  E686    09                    	ADD	HL,BC		; No then restore HL
  E687    B7                    	OR	A		; Clear Carry
  E688    CB 13                 CALST1:	RL	E		; Shift result in DE
  E68A    CB 12                 	RL	D
  E68C    3D                    	DEC	A		; Test last bit done
  E68D    28 04                 	JR	Z,CALST2	; Yes then exit
  E68F    ED 6A                 	ADC	HL,HL		; Shift next bit in HL
  E691    18 ED                 	JR	CALST0		; Continue
                                
  E693    E5                    CALST2:	PUSH	HL		; Save sector number
  E694    2A E049               	LD	HL,(NFTRK)	; Get first track
  E697    19                    	ADD	HL,DE		; Add track number
  E698    44                    	LD	B,H		; Copy it to BC
  E699    4D                    	LD	C,L
  E69A    CD EE1E               	CALL	SETTRK		; CBIOS call Set Track
  E69D    C1                    	POP	BC		; Restore sector number
  E69E    ED 5B E030            	LD	DE,(TRANS)	; Get translation table address
  E6A2    CD EE30               	CALL	SECTRN		; CBIOS call sector translation
  E6A5    44                    	LD	B,H		; Copy result to BC
  E6A6    4D                    	LD	C,L
  E6A7    C3 EE21               	JP	SETSEC		; BIOS call Set Sector
                                
                                ; Get Disk Map Block Number from FCB   (Squeezed by Joe Wright)
                                ;  Exit HL=Address FCB
                                ;	DE=DM
                                ;	BC=Offset in DM
                                ;	Zero Flag Set (Z) if DM=0, Else reset (NZ)
                                
  E6AA    DD 6E 20              GETDM:	LD	L,(IX+NXTREC)	; Get record number in L
  E6AD    CB 15                 	RL	L		; Shift it left once
  E6AF    3A E040               	LD	A,(NEXTND)	; Get EXM
  E6B2    DD A6 0C              	AND	(IX+FCBEXT)	; And the extent number
  E6B5    67                    	LD	H,A		; To H
  E6B6    3A E03E               	LD	A,(NBLOCK)	; Get BSH
  E6B9    47                    	LD	B,A		; To B
  E6BA    04                    	INC	B		; +1
  E6BB    CD E661               	CALL	SHRHLB		; Shift HL right B times
  E6BE    50                    	LD	D,B		; Zero to D
  E6BF    7D                    	LD	A,L		; Result to A
                                
  E6C0    2A E05D               GETDM4:	LD	HL,(ARWORD)
  E6C3    0E 10                 	LD	C,16		; Add offset 16 to point to DM
  E6C5    09                    	ADD	HL,BC
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-37


  E6C6    4F                    	LD	C,A		; Add entry FCB
  E6C7    09                    	ADD	HL,BC
  E6C8    3A E042               	LD	A,(MAXLEN+1)	; Test 8 bits/16 bits FCB entry
  E6CB    B7                    	OR	A
  E6CC    5E                    	LD	E,(HL)		; Get 8 bit value
  E6CD    28 05                 	JR	Z,GETDMX	; ..and exit if 8-bit entries
                                
  E6CF    09                    	ADD	HL,BC		; Add twice (16 bit values)
  E6D0    5E                    	LD	E,(HL)		; Get LSB
  E6D1    23                    	INC	HL		; Increment pointer
  E6D2    56                    	LD	D,(HL)		; Get MSB
  E6D3    2B                    	DEC	HL		; Decrement pointer
  E6D4    7A                    GETDMX:	LD	A,D		; Check for zero DM value
  E6D5    B3                    	OR	E
  E6D6    C9                    	RET			; And exit
                                
                                ; Calculate Sector Number
                                ;  Entry: DE=Block Number from FCB
                                
  E6D7    21 0000               CALSEC:	LD	HL,0		; Clear MSB sector number
  E6DA    3A E03E               	LD	A,(NBLOCK)	; Get loop counter
  E6DD    47                    	LD	B,A		; Save it in B
  E6DE    EB                    	EX	DE,HL
  E6DF    29                    CALSC0:	ADD	HL,HL		; Shift L,D,E
  E6E0    CB 13                 	RL	E
  E6E2    10 FB                 	DJNZ	CALSC0		; B times
  E6E4    EB                    	EX	DE,HL
  E6E5    3A E03F               	LD	A,(NMASK)	; Get sector mask
  E6E8    DD A6 20              	AND	(IX+NXTREC)	; And with next record
  E6EB    B3                    	OR	E		; Set up LSB sector number
  E6EC    5F                    	LD	E,A
  E6ED    C9                    	RET			; And exit
                                
                                ; Check for File Read-Only status, then fall thru to CALDIR
                                
  E6EE    CD E8AC               CKRODI:	CALL	CHKFRO		; Abort if the file is R/O
                                				; ..fall thru..
                                
                                ; Calculate DIRBUF Entry Point
                                
  E6F1    3A E056               CALDIR:	LD	A,(SECPNT)	; Get sector pointer
  E6F4                          CALDIR1:			; New label for DS (crw)
  E6F4    2A E034               	LD	HL,(DIRBUF)	; Get start address dirbuf
  E6F7    85                    CALDI0:	ADD	A,L		; Add L=L+A
  E6F8    6F                    	LD	L,A
  E6F9    D0                    	RET	NC		; No carry exit
  E6FA    24                    	INC	H		; Increment H
  E6FB    C9                    	RET			; And exit
                                
                                ; Init File Count
                                
  E6FC    21 FFFF               SETFCT:	LD	HL,-1		; Set up file count
  E6FF    22 E054               	LD	(FILCNT),HL	; Save it
  E702    C9                    	RET			; And exit
                                
                                ; Set Write Protect Disk Command  (relocated & compressed hfb)
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-38


                                
  E703                          CMND28:				; Set read only disk
  E703    2A EDFC               	LD	HL,(DSKWP)	; Get disk W/P vector
  E706    CD E64A               	CALL	SDRVB		; Include drive bit
  E709    22 EDFC               	LD	(DSKWP),HL	; Save disk W/P vector
  E70C    ED 5B E043            	LD	DE,(NFILES)	; Get max number of files-1 (bumped below)
  E710    2A E032               	LD	HL,(TEMP0)	; Get pointer to disk parameter block
  E713    23                    	INC	HL		; Correct pointer..
                                				; Setlf0 relocated in-line here (hfb)
  E714    13                    SETLF0:	INC	DE		; Increment last file
  E715    72                    	LD	(HL),D		; Save it in TEMP0
  E716    2B                    	DEC	HL
  E717    73                    	LD	(HL),E
  E718    C9                    	RET			; And exit
                                
                                ; Search using first 15 bytes of FCB, test if found
                                
  E719    CD E8F1               SRCT15:	CALL	SEAR15		; Search on 15-bytes..(consolidated-hfb)
                                				; ..fall thru to test presence..
                                ; Test File Count
                                
  E71C    2A E054               TSTFCT:	LD	HL,(FILCNT)	; Test file count=0FFFFH
  E71F    7C                    	LD	A,H		; Get MSB
  E720    A5                    	AND	L		; And LSB
  E721    3C                    	INC	A		; Test if result=0FFH
  E722    C9                    	RET			; And exit
                                
                                ; Test Last File
                                
  E723    2A E032               TSTLF:	LD	HL,(TEMP0)	; Get pointer to last file
  E726    ED 5B E054            	LD	DE,(FILCNT)	; Get file counter
  E72A    7B                    	LD	A,E		; Subtract DE-(HL)
  E72B    96                    	SUB	(HL)
  E72C    23                    	INC	HL
  E72D    7A                    	LD	A,D
  E72E    9E                    	SBC	A,(HL)
  E72F    C9                    	RET			; Exit
                                
                                ; Get Next FCB from Drive
                                ; Entry A=0 Check Checksum, A=0FFH Update Checksum
                                
  E730    4F                    RDDIR:	LD	C,A		; Save checksum flag
  E731    2A E054               	LD	HL,(FILCNT)	; Get file counter
  E734    23                    	INC	HL		; Increment it
  E735    22 E054               	LD	(FILCNT),HL	; And save it
  E738    ED 5B E043            	LD	DE,(NFILES)	; Get maximum number of files
  E73C    7B                    	LD	A,E		; Is this the last file?
  E73D    95                    	SUB	L
  E73E    7A                    	LD	A,D
  E73F    9C                    	SBC	A,H
  E740    38 BA                 	JR	C,SETFCT	; ..set file count to 0FFFFH if so
  E742    7D                    	LD	A,L		; Get file count LSB
  E743    0F                    	RRCA			; *32 (bm/hfb-to save a byte)
  E744    0F                    	RRCA
  E745    0F                    	RRCA
  E746    E6 60                 	AND	060H		; Mask it
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-39


  E748    32 E056               	LD	(SECPNT),A	; Save it for later use
  E74B    C0                    	RET	NZ		; Return if not first FCB sector
  E74C    C5                    	PUSH	BC		; Save checksum flag
                                	  IF  NOT ZSDOS11	;  (* This was NOT in released package *)
                                	LD	A,H		; [1.2]
                                	OR	L		; [1.2] First dir entry?
                                	   IF  ZS
                                	JR	NZ,RdDir0	; [1.2] If not
                                	LD	HL,(NCHECK)	; [1.2] Is this a fixed disk?
                                	LD	A,H		; [1.2]
                                	OR	L		; [1.2]
                                	CALL	NZ,HOME		; [1.2] Home if media could change
                                	   ELSE		;~Zs
                                	CALL	Z,HOME		; [1.2] Home if first dir entry
                                	   ENDIF	;Zs
                                	  ENDIF		;~Zsdos11
  E74D    CD E668               RdDir0:	CALL	STDIR		; Calculate sector/track directory
                                	  IF  NOT ZS
                                	CALL	READDR		; Read into DIR buffer
                                
                                ; Check if !!!TIME&.DAT on disk, save temp. result in TDCHEK <crw>
                                
                                	LD	HL,(FILCNT)
                                	LD	A,H
                                	OR	L		; First file? (filcnt = 0)
                                	JR	NZ,RDDIR2	; ..jump if not
                                	LD	HL,(DIRBUF)	; Else look for !!!TIME&.DAT
                                	LD	B,11		; Test 11 bytes
                                RDDIR1:	INC	HL
                                	LD	C,(HL)		; Get Next Char
                                	RES	7,C		; Clear Attricute Bit
                                	ADD	A,C		; Add to Checksum
                                	DJNZ	RDDIR1		; Back for more...
                                	SUB	TDCKSM		; See it it's !!!TIME&.DAT
                                	LD	(TDCHEK),A	; Save result (0 = !!!TIME&.DAT found)
                                RDDIR2:			; <crw>
                                	  ELSE
                                				; READDR subroutine moved in-line here
  E750    CD E83D               	CALL	DMADIR		; Set up DMA directory
  E753    CD E795               	CALL	READR		; Read a record
  E756    CD E837               	CALL	STDMA		; ..and set up user's DMA
                                	  ENDIF
  E759    C1                    	POP	BC		; Restore checksum flag
                                
                                ; Update/Check Checksum Directory
                                ; Entry C=0 Check Checksum, C=0FFH update Checksum
                                
  E75A    2A E047               CHKDIR:	LD	HL,(NCHECK)	; Get number of checked records
  E75D    ED 5B E052            	LD	DE,(RECDIR)	; Get current record
  E761    AF                    	XOR	A		; Clear carry (bm)
  E762    ED 52                 	SBC	HL,DE		; Test current record
  E764    C8                    	RET	Z		; Exit if zero
  E765    D8                    	RET	C		; Exit if greater than ncheck
  E766    2A E034               	LD	HL,(DIRBUF)	; Get dirbuf
  E769    CD EDE0               	CALL	CKS127		; ..and checksum first 127 bytes..
  E76C    86                    	ADD	A,(HL)		; ...then 128th byte (hfb)
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-40


  E76D    2A E038               	LD	HL,(CSV)	; Get pointer checksum directory
  E770    19                    	ADD	HL,DE		; Add current record
  E771    0C                    	INC	C		; Test checksum flag
  E772    20 02                 	JR	NZ,CHKDR1	; 0FFH=> update checksum
  E774    77                    	LD	(HL),A		; Update checksum
  E775    C9                    	RET			; And exit
                                
  E776    BE                    CHKDR1:	CP	(HL)		; Test checksum
  E777    C8                    	RET	Z		; Exit if ok
                                
                                ; Checksum differs, So Disk has changed.  Relog it and continue
                                
  E778    3A E015               	LD	A,(FLAGS)
  E77B    CB 67                 	BIT	4,A		; Inform user?
  E77D    06 00                 	LD	B,0		; Disk change error code
  E77F    11 E302               	LD	DE,MDSKCH	; Disk changed message
  E782    C4 E34C               	CALL	NZ,ERROR	; Inform user
                                
                                ; Relog Current Drive after media change detected
                                
  E785    CD E647               	CALL	GETCDM		; Get current drive mask in HL
  E788    EB                    	EX	DE,HL		; Xfer mask to DE
  E789    CD E45D               	CALL	UNLOG		; Reset login vector for logged drive
  E78C    CD E435               	CALL	RELOG1		; Do the meat of relogging
                                				; Caveat emptor: this call is recursive...
  E78F    CD E6FC               	CALL	SETFCT		; Re-initialize search file count
  E792    AF                    	XOR	A		; We only get here by checking.. (bm)
  E793    18 9B                 	JR	RDDIR		; And all checking is done from rddir
                                
                                ; Read Sector from Drive
                                
  E795    CD EE27               READR:	CALL	READ		; CBIOS call read sector
  E798    18 03                 	JR	WRITE0
                                
                                ; Write Sector on Drive
                                
  E79A    CD EE2A               WRITER:	CALL	WRITE		; CBIOS call write sector
  E79D    B7                    WRITE0:	OR	A		; Test exit code
  E79E    C8                    	RET	Z		; Exit if ok
  E79F    06 01                 	LD	B,1		; Disk I/O error code
  E7A1    11 E30A               	LD	DE,MBADSC	; Load bad sector message
  E7A4    2A E009               	LD	HL,(STBDSC)	; Load bad sector vector
  E7A7    E9                    	JP	(HL)		; ZSDOS error on D: Bad Sector
                                
                                ; Close File Command (relocated hfb)
                                
  E7A9                          BGPTCH2	EQU	$+1		;<-- BGii patch point
                                
  E7A8    CD E52D               CMND16:	CALL	SELDR1		; Select drive from FCB
                                
                                ; Close File
                                
  E7AB    DD CB 0E 7E           CLOSE:	BIT	7,(IX+FCBMOD)	; Test FCB/file modified
  E7AF    C0                    	RET	NZ		; Not then no close required
  E7B0    CD E8D8               	CALL	CHKRO		; Test disk W/P
  E7B3    CD E719               	CALL	SRCT15		; Search file and test present
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-41


  E7B6    C8                    	RET	Z		; No then exit with error
  E7B7    CD E6EE               	CALL	CKRODI		; Check file W/P, get directory entry
  E7BA    01 0010               	LD	BC,16		; Offset to DM block
  E7BD    09                    	ADD	HL,BC		; Add offset
  E7BE    EB                    	EX	DE,HL		; Save DIR PTR in DE
  E7BF    2A E05D               	LD	HL,(ARWORD)	; Get FCB ptr
  E7C2    09                    	ADD	HL,BC		; Add offset
  E7C3    EB                    	EX	DE,HL
  E7C4    41                    	LD	B,C		; Xfer counter
                                
                                ; Copy FCB (DE) to DIR (HL) if and only if DIR=0 or DIR=FCB
                                
  E7C5    34                    CLOSE0:	INC	(HL)
  E7C6    35                    	DEC	(HL)		; Test DIR for 0
  E7C7    1A                    	LD	A,(DE)		; Get byte from FCB
  E7C8    28 04                 	JR	Z,CLOSE1	; OK to Copy if 0
  E7CA    BE                    	CP	(HL)		; Test if same as DIR
  E7CB    C2 EB7A               	JP	NZ,RETCFF	; ..if Not, abort Close and return error
  E7CE    77                    CLOSE1:	LD	(HL),A		; Else save in DIR
  E7CF    13                    	INC	DE
  E7D0    23                    	INC	HL
  E7D1    10 F2                 	DJNZ	CLOSE0		; Bump pointers and loop until done
  E7D3    11 FFEC               	LD	DE,-20		; Add -20 to get Extent Number from DIR
  E7D6    19                    	ADD	HL,DE		; HL contains pointer to extent number
  E7D7    DD 7E 0C              	LD	A,(IX+FCBEXT)	; Get extent number FCB
  E7DA    BE                    	CP	(HL)		; Compare with extent number directory
  E7DB    38 08                 	JR	C,CLOSE3	; FCB < directory then jump
  E7DD    77                    	LD	(HL),A		; Save extent number in directory
  E7DE    23                    	INC	HL		; Get pointer to next record
  E7DF    23                    	INC	HL
  E7E0    23                    	INC	HL
  E7E1    DD 7E 0F              	LD	A,(IX+FCBREC)	; Get next record FCB
  E7E4    77                    	LD	(HL),A		; Save next record in directory
  E7E5    CD E808               CLOSE3:	CALL	CLOSE6		; Clear Archive Bit and Write FCB
  E7E8    CD EBA6               	CALL	GETDME		; Get Data Module and Extent
                                	  IF  NOT ZSDOS11	;  (* NOT in Release version *)
                                	PUSH	BC		;[1.2] Save prior module and Extent
                                	JR	Z,CLOSE4	; ..jump to Stamp if they are both 0
                                	  ELSE		;Zsdos11   (* This was Release version *)
  E7EB    28 0D                 	JR	Z,CLOSE4	; ..jump to Stamp if they are both 0
  E7ED    C5                    	PUSH	BC		; Save prior module and Extent
                                	  ENDIF		;~Zsdos11
  E7EE    01 0000               	LD	BC,0
  E7F1    CD EB9E               	CALL	SETDME		; Set FCB Data Module and Extent to 0
  E7F4    CD E719               	CALL	SRCT15		; Find proper DIR Entry
                                	  IF  NOT ZSDOS11
                                	JR	Z,JSETDME	; ..Exit if Extent 0 Not Found
                                CLOSE4:
                                	  ELSE		;Zsdos11
  E7F7    C1                    	POP	BC
  E7F8    28 0B                 	JR	Z,JSETDME	; ..Exit if Extent 0 Not Found
  E7FA    C5                    CLOSE4:	PUSH	BC
                                	  ENDIF		;~Zsdos11
  E7FB    CD E808               	CALL	CLOSE6		; Clear Archive Bit and Write FCB
  E7FE    2A E01C               	LD	HL,(STUPDV)	; Get the update routine address
                                	  IF  ZS
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-42


  E801    CD EDB9               	CALL	STAMPT		; ..and stamp it
                                	  ELSE		;If not Zs (crw)
                                	LD	C,10		; Set Last Modify
                                	CALL	JPHL		; ..and Stamp if Enabled
                                	  ENDIF		;ZS
                                	  IF  NOT  ZSDOS11
                                JSETDME:
                                	POP	BC		; Get Original Module and Extent Back
                                	  ELSE		;Zsdos11
  E804    C1                    	POP	BC		; Get Original Module and Extent Back
  E805                          JSETDME:
                                	  ENDIF		;~Zsdos11
  E805    C3 EB9E               	JP	SETDME		; Restore to FCB and Exit
                                
  E808    CD E6F1               CLOSE6:	CALL	CALDIR		; Get directory entry
  E80B    01 000B               	LD	BC,11		; Point to archive byte
  E80E    09                    	ADD	HL,BC
  E80F    CB BE                 	RES	7,(HL)		; Reset archive bit
  E811    DD CB 0B BE           	RES	7,(IX+ARCATT)	; Reset bit in FCB
                                	  IF  ZSDOS11
  E815    18 00                 	JR	WRFCB		; Write FCB to Disk
                                
                                	   IF  NOT ZS
                                READDR:	CALL	DMADIR		; Set up DMA directory
                                	CALL	READR		; Read a record
                                	JR	STDMA		; ..and set up user's DMA
                                	   ENDIF	;NOT Zs
                                	  ENDIF		;Zsdos11
                                
  E817    CD E6F1               WRFCB:	CALL	CALDIR		; Point to dir entry to write
  E81A    3E 0D                 	LD	A,FCBUSR	; Offset to user byte in FCB
  E81C    CD E6F7               	CALL	CALDI0		; ..do the add here
  E81F    36 00                 	LD	(HL),0		; Prevent writing it to disk
  E821    CD E668               	CALL	STDIR		; Calculate sector/track directory
  E824    0E FF                 	LD	C,0FFH		; Update checksum directory
  E826    CD E75A               	CALL	CHKDIR
  E829    CD E83D               WRITD1:	CALL	DMADIR		; Set up dma directory (label for DS - crw)
  E82C    0E 01                 	LD	C,1		; Write directory flag
  E82E    CD E79A               	CALL	WRITER		; Write record
  E831    18 04                 	JR	STDMA		; Set up DMA user
                                
                                	  IF  NOT ZSDOS11
                                	   IF  NOT ZS
                                READDR:	CALL	DMADIR		; Set up DMA directory
                                	CALL	READR		; Read a record
                                	JR	STDMA		; ..and set up user's DMA
                                	   ENDIF	;NOT Zs
                                	  ENDIF		;~Zsdos11
                                
                                ; Set DMA Address Command
                                
  E833    ED 53 E02E            CMND26:	LD	(DMA),DE	; Save DMA address
                                
                                ; Set DMA Address
                                
  E837    ED 4B E02E            STDMA:	LD	BC,(DMA)	; Get DMA address
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-43


  E83B    18 04                 	JR	DMADR0		; And do BIOS call
                                
                                ; Set DMA Address Directory
                                
  E83D    ED 4B E034            DMADIR:	LD	BC,(DIRBUF)	; Get DMA address directory
  E841    C3 EE24               DMADR0:	JP	SETDMA		; Cbios call set DMA
                                
                                ; Get Bit from ALV Buffer
                                ;  Entry DE=Block Number
                                ;  Exit  A =Bit in LSB
                                ;	 B =Bit Number in A
                                ;	 HL=Pointer in ALV Buffer
                                
  E844    7B                    GETBIT:	LD	A,E		; Get bit number
  E845    E6 07                 	AND	7		; Mask it
  E847    3C                    	INC	A		; Add 1
  E848    4F                    	LD	C,A		; Save it
                                	  IF  UNROLL
  E849    CB 3A                 	SRL	D		; Get byte number
  E84B    CB 1B                 	RR	E		; DE=DE/8
  E84D    CB 3A                 	SRL	D
  E84F    CB 1B                 	RR	E
  E851    CB 3A                 	SRL	D
  E853    CB 1B                 	RR	E		; ..inline for speed (net cost: 4)
  E855    47                    	LD	B,A		; Re-save bit number for next shift
  E856    2A E03A               	LD	HL,(ALV)	; Get start address ALV buffer
                                	  ELSE
                                	EX	DE,HL
                                	CALL	SHRHL3		; Divide by 8
                                	LD	B,A		; Re-save bit number for next shift
                                	LD	DE,(ALV)	; Get start address ALV buffer
                                	  ENDIF		;Unroll
  E859    19                    	ADD	HL,DE		; Add byte number
  E85A    7E                    	LD	A,(HL)		; Get 8 bits
  E85B    07                    GETBT0:	RLCA			; Get correct bit
  E85C    10 FD                 	DJNZ	GETBT0
  E85E    41                    	LD	B,C		; Restore bit number
  E85F    C9                    	RET			; And return to caller
                                
                                ; Set/Reset bit in ALV Buffer
                                ;  Entry DE=Block Number
                                ;	 C =0 Reset Bit, C=1 Set Bit
                                
  E860    C5                    SETBIT:	PUSH	BC		; Save set/reset bit
  E861    CD E844               	CALL	GETBIT		; Get bit
  E864    E6 FE                 	AND	0FEH		; Mask it
  E866    D1                    	POP	DE		; Get set/reset bit
  E867    B3                    	OR	E		; Set/reset bit
  E868    0F                    SETBT0:	RRCA			; Rotate bit in correct position
  E869    10 FD                 	DJNZ	SETBT0
  E86B    77                    	LD	(HL),A		; Save 8 bits
  E86C    C9                    	RET			; And return to caller
                                
                                ; Delete File
                                
  E86D    CD E9BD               DELETE:	CALL	COMCOD		; Call common code w/VDEL on stack
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-44


                                
                                ; Delete Routine Core (relocated to save space) (hfb)
                                
  E870    CD E6EE               VDEL:	CALL	CKRODI		; Check file W/P, get directory entry
  E873    36 E5                 	LD	(HL),0E5H	; Remove file
  E875    23                    	INC	HL
  E876    7E                    	LD	A,(HL)		; Get first char
  E877    D6 24                 	SUB	'$'		; See if submit file
  E879    20 03                 	JR	NZ,VDEL1	; If not
  E87B    32 E057               	LD	(SUBFLG),A	; Clear subflg if $*.* erased
  E87E    23                    VDEL1:	INC	HL
  E87F    CB BE                 	RES	7,(HL)		; Insure erased files are not public
  E881    0E 00                 	LD	C,0		; Remove bits ALV buffer
                                				; ..fall thru and return to caller..
                                
                                ; Fill bit buffer from FCB in DIRBUF
                                ;  Entry C=0 Reset Bit, C=1 Set Bit
                                
  E883    CD E6F1               FILLBB:	CALL	CALDIR		; Get directory entry
  E886    11 0010               	LD	DE,16		; Get offset DM block
  E889    19                    	ADD	HL,DE		; Add offset
  E88A    43                    	LD	B,E		; Get block counter
  E88B    5E                    FILLB0:	LD	E,(HL)		; Get LSB block number
  E88C    23                    	INC	HL		; Increment pointer
  E88D    16 00                 	LD	D,0		; Reset MSB block number
  E88F    3A E042               	LD	A,(MAXLEN+1)	; Test >256 blocks present
  E892    B7                    	OR	A
  E893    28 03                 	JR	Z,FILLB1	; No then jump
  E895    05                    	DEC	B		; Decrement block counter
  E896    56                    	LD	D,(HL)		; Get correct MSB
  E897    23                    	INC	HL		; Increment pointer
  E898    7A                    FILLB1:	LD	A,D		; Test block number
  E899    B3                    	OR	E
  E89A    28 0D                 	JR	Z,FILLB2	; Zero then get next block
  E89C    E5                    	PUSH	HL		; Save pointer
  E89D    C5                    	PUSH	BC		; Save counter and set/reset bit
  E89E    2A E041               	LD	HL,(MAXLEN)	; Get maximum length ALV buffer
  E8A1    B7                    	OR	A		; Reset carry
  E8A2    ED 52                 	SBC	HL,DE		; Test DE<=maxlen ALV buffer
  E8A4    D4 E860               	CALL	NC,SETBIT	; Yes then insert bit
  E8A7    C1                    	POP	BC		; Get counter and set/reset bit
  E8A8    E1                    	POP	HL		; Get pointer
  E8A9    10 E0                 FILLB2:	DJNZ	FILLB0		; Repeat for all DM entries
  E8AB    C9                    	RET			; And return to caller
                                
                                ; Check File W/P Bit - SEARCH called first
                                
  E8AC    CD E6F1               CHKFRO:	CALL	CALDIR		; Get directory entry
  E8AF    11 0008               	LD	DE,WHLATT	; Offset to R/O bit
  E8B2    19                    	ADD	HL,DE		; Add offset
  E8B3    ED 5B E013            	LD	DE,(WHEEL)	; Get wheel byte address from header
  E8B7    1A                    	LD	A,(DE)		; ..and retrieve the actual byte
  E8B8    A7                    	AND	A		; ..and check the Wheel byte
  E8B9    20 04                 	JR	NZ,CHKFR4	; We have wheel, so allow writes anyway
  E8BB    CB 7E                 	BIT	7,(HL)		; Else check Wheel attribute
  E8BD    20 10                 	JR	NZ,CHKFR2	; Yes then error
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-45


  E8BF    23                    CHKFR4:	INC	HL		; Check W/P bit (hfb)
  E8C0    CB 7E                 	BIT	7,(HL)		; Test file W/P
  E8C2    20 0B                 	JR	NZ,CHKFR2	; If W/P
  E8C4    DD CB 07 7E           CHKFR3:	BIT	7,(IX+PSFATT)	; Was file accessed as Public or Path?
  E8C8    C8                    	RET	Z		; If normal access
  E8C9    3A E015               	LD	A,(FLAGS)	; Else test for writes allowed
  E8CC    E6 02                 	AND	0010B
  E8CE    C0                    	RET	NZ		; Go ahead, writes are allowed
  E8CF    2A E00F               CHKFR2:	LD	HL,(SFILRO)	; Get pointer to file W/P message
  E8D2    06 03                 	LD	B,3		; File W/P error code
  E8D4    11 E31E               	LD	DE,MFILRO	; Load file W/P message
  E8D7    E9                    	JP	(HL)		; Display message
                                
                                
                                ; Check Drive Write Protect
                                
  E8D8                          BGCKDRO:
  E8D8    CD E8E5               CHKRO:	CALL	CHKRO1		; Is the disk W/P?
  E8DB    C0                    	RET	NZ		; ..return if disk R/W
  E8DC    06 02                 	LD	B,2		; Else set disk W/P error code
  E8DE    11 E323               	LD	DE,MRO		; Load drive W/P message
  E8E1    2A E00D               	LD	HL,(STRO)	; Get pointer to drive W/P message
  E8E4    E9                    	JP	(HL)		; Display message
                                
  E8E5    2A EDFC               CHKRO1:	LD	HL,(DSKWP)	; Get the W/P drive vector
  E8E8    CD E64A               	CALL	SDRVB		; Set the bit for this drive
  E8EB    ED 52                 	SBC	HL,DE		; See if extra bit added (Cy is clear)
  E8ED    C9                    	RET
                                
                                ; Search using first 12 bytes of FCB (hfb)
                                
  E8EE    3E 0C                 SEAR12:	LD	A,12
  E8F0    21                    	DEFB	21H		; Trash HL and fall through
                                
                                ; Search using first 15 bytes of FCB
                                
  E8F1    3E 0F                 SEAR15:	LD	A,15
                                
                                ; Search for File Name
                                ;  Entry: A = Number of bytes for which to search
                                
  E8F3    32 E05B               SEARCH:	LD	(SEARNB),A	; Save number of bytes
  E8F6    3E FF                 	LD	A,0FFH		; Set exit code to 0FFH (not found)
  E8F8    32 E05A               	LD	(SEAREX),A
  E8FB    DD 22 E058            	LD	(DCOPY),IX	; Copy FCB pointer to RAM (search next)
  E8FF    CD E6FC               	CALL	SETFCT		; Initiate file counter
                                
                                ; Force directory read with a Call HOME (bh)   (Only if Floppys-hfb)
                                	  IF  ZSDOS11		; (* Logic moved to RDDIR if NOT Zsdos11 *)
  E902    2A E047               	LD	HL,(NCHECK)	; Is this a fixed media?
  E905    7C                    	LD	A,H
  E906    B5                    	OR	L
  E907    C4 EE18               	CALL	NZ,HOME		; Invoke CBIOS Home routine if removeable
                                	  ENDIF		;~Zsdos11
                                
                                ; Search Next File Name
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-46


                                
  E90A    AF                    SEARCN:	XOR	A		; Check checksum directory
  E90B    67                    	LD	H,A
  E90C    6F                    	LD	L,A
  E90D    22 E050               	LD	(SEARQU),HL	; Clear question mark & public detected flags
  E910    DD CB 07 BE           	RES	7,(IX+PSFATT)	; Reset public/system file flag
  E914    CD E730               	CALL	RDDIR		; Get FCB from directory
  E917    CD E71C               	CALL	TSTFCT		; Test if past last entry
  E91A    28 0E                 	JR	Z,JSEAR8	; Yes then jump (note carry always clear)
  E91C    ED 5B E058            	LD	DE,(DCOPY)	; Get FCB pointer
  E920    1A                    	LD	A,(DE)		; Get first byte
  E921    FE E5                 	CP	0E5H		; Test if searching empty directory
  E923    28 07                 	JR	Z,SEARC1	; Yes then jump
  E925    D5                    	PUSH	DE		; Save FCB pointer
  E926    CD E723               	CALL	TSTLF		; Test last file on this drive
  E929    D1                    	POP	DE		; Restore FCB pointer
  E92A    30 6B                 JSEAR8:	JR	NC,SEARC8	; Yes then jump
  E92C    CD E6F1               SEARC1:	CALL	CALDIR		; Get entry in directory
  E92F    7E                    	LD	A,(HL)		; Get first byte directory entry
  E930    FE 21                 	CP	21H		; Test time stamp
  E932    28 D6                 	JR	Z,SEARCN	; Yes then get next directory entry
  E934    0E 00                 	LD	C,0		; Clear counter
  E936    3A E05B               	LD	A,(SEARNB)	; Get number of bytes to search for
  E939    47                    	LD	B,A		; Save it in counter
  E93A    78                    SEARC2:	LD	A,B		; Test if counter is zero
  E93B    B7                    	OR	A
  E93C    28 5F                 	JR	Z,SEARC9	; Yes then jump
  E93E    1A                    	LD	A,(DE)		; Get byte from FCB
  E93F    EE 3F                 	XOR	'?'		; Test if question mark
  E941    E6 7F                 	AND	7FH		; Mask it
  E943    28 3B                 	JR	Z,SEARC6	; Yes then jump
  E945    79                    	LD	A,C		; Get FCB counter
  E946    B7                    	OR	A		; Test first byte
  E947    20 22                 	JR	NZ,SEARC3	; No then jump
  E949    3A E015               	LD	A,(FLAGS)	; Get flag byte
  E94C    1F                    	RRA			; Test public file enable
  E94D    30 1C                 	JR	NC,SEARC3	; ..jump if not
  E94F    23                    	INC	HL		; Get pointer to Public Bit
  E950    23                    	INC	HL
  E951    CB 7E                 	BIT	7,(HL)		; Test Public Bit directory
  E953    2B                    	DEC	HL		; Restore pointer
  E954    2B                    	DEC	HL
  E955    28 14                 	JR	Z,SEARC3	; No public file then jump
  E957    1A                    	LD	A,(DE)		; Get first byte FCB
  E958    FE E5                 	CP	0E5H		; Test if searching empty directory
  E95A    28 0F                 	JR	Z,SEARC3	; Yes then jump
                                
                                ; The following 3 lines of code represent a deviation from the description of
                                ; PUBLIC Files as given in DDJ Article by Bridger Mitchell and Derek McKay of
                                ; Plu*Perfect Systems.	The PUBLIC Specification states that Public Files will
                                ; NOT be found by any wildcard reference except when a "?" is in the FCB+0
                                ; byte.  The code here relaxes that requirement as follows:  If we are in the
                                ; same user area as the public file, then don't report the file as PUBLIC, but
                                ; find it.  This has a nasty side effect - it allows erasing of PUBLIC files
                                ; if we are in the same area.  However, these files also show up on the direc-
                                ; tory (they wouldn't otherwise), so at least we should know we're blasting
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-47


                                ; them.
                                
  E95C    AE                    	XOR	(HL)		; Test FCB = Directory Entry
  E95D    E6 7F                 	AND	7FH		; Mask it (setting Zero Flag)
  E95F    28 19                 	JR	Z,SEARC5	; Jump if user is same
  E961    3E FF                 	LD	A,0FFH
  E963    32 E051               	LD	(SEARPU),A	; Set Public file found
                                	  IF  UPATH
  E966    CD EAAF               	CALL	SETPSF		; Set Public/System file flag
                                	  ELSE
                                	SET	7,(IX+PSFATT)	; Set Public/System file flag
                                	  ENDIF
  E969    18 0F                 	JR	SEARC5		; Jump found
                                
  E96B    79                    SEARC3:	LD	A,C		; Get FCB counter
  E96C    FE 0D                 	CP	13		; Is it User Code?
  E96E    28 0A                 	JR	Z,SEARC5	; ..jump if so..don't test
  E970    FE 0C                 	CP	12		; Is it an Extent Number?
  E972    1A                    	LD	A,(DE)		; ..Get byte from FCB
  E973    28 11                 	JR	Z,SEARC7	; ..Jump if Extent Number
  E975    AE                    	XOR	(HL)		; Is FCB byte = Directory Entry byte?
  E976    E6 7F                 	AND	07FH		; ..Mask it
  E978    20 90                 SEARC4:	JR	NZ,SEARCN	; ..jump if not same and get next entry
  E97A    13                    SEARC5:	INC	DE		; Increment FCB pointer
  E97B    23                    	INC	HL		; Increment Directory Entry pointer
  E97C    0C                    	INC	C		; Increment counter
  E97D    05                    	DEC	B		; Decrement counter
  E97E    18 BA                 	JR	SEARC2		; Test next byte
                                
  E980    3D                    SEARC6:	DEC	A		; Set question mark found flag
  E981    32 E050               	LD	(SEARQU),A
  E984    18 F4                 	JR	SEARC5		; Jump found
                                
  E986                          SEARC7:
  E986    AE                    	XOR	(HL)		; Test extent
  E987    CD E98C               	CALL	SEARC7A		; Mask Extent
  E98A    18 EC                 	JR	SEARC4		; ..and test Result
                                
                                
  E98C    C5                    SEARC7A: PUSH	BC
  E98D    47                    	LD	B,A		; Save Extent
  E98E    3A E040               	LD	A,(NEXTND)	; Get extent mask
  E991    2F                    	CPL			; Complement it
  E992    E6 1F                 	AND	MAXEXT		; Mask it
  E994    A0                    	AND	B		; Mask extent
  E995    C1                    	POP	BC		; Restore counters
  E996    C9                    	RET
                                
  E997    CD E6FC               SEARC8:	CALL	SETFCT		; Error set file counter
  E99A    C3 EB7A               	JP	RETCFF		; Set return code to FF and exit
                                
  E99D    2A E050               SEARC9:	LD	HL,(SEARQU)	; Get question mark and public found flags
  E9A0    7C                    	LD	A,H
  E9A1    A5                    	AND	L
  E9A2    20 D4                 	JR	NZ,SEARC4	; Yes then search for next entry
  E9A4    CD E723               	CALL	TSTLF		; Test for last file
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-48


  E9A7    D4 E714               	CALL	NC,SETLF0	; And update if so
  E9AA    2A E052               	LD	HL,(RECDIR)	; Set DE return to directory record
  E9AD    22 E05F               	LD	(DEVAL),HL	; .. for DateStamper simulation
  E9B0    3A E054               	LD	A,(FILCNT)	; Get file counter
  E9B3    E6 03                 	AND	3		; Mask it
  E9B5    32 E04C               	LD	(PEXIT),A	; And set exit code
  E9B8    AF                    	XOR	A		; Clear exit code search
  E9B9    32 E05A               	LD	(SEAREX),A
  E9BC    C9                    	RET			; And return to caller
                                
                                ; The following code is common to DELETE, RENAME, and CSTAT.
                                ; It is coded in a manner that is compatable with the Z280
                                ; in protected Mode.
                                
  E9BD    CD E8D8               COMCOD:	CALL	CHKRO		; Check disk W/P
  E9C0    CD E8EE               	CALL	SEAR12		; Search file
  E9C3    CD E71C               COMCO1:	CALL	TSTFCT		; Test if file found
  E9C6    E1                    	POP	HL		; Routine addr to HL (in case not found)
  E9C7    C8                    	RET	Z		; Not then exit
  E9C8    E5                    	PUSH	HL		; ..found, so routine back to stack
  E9C9    E5                    	PUSH	HL		; Twice, as RET pops first push
  E9CA    21 E9CF               	LD	HL,COMCO2
  E9CD    E3                    	EX	(SP),HL		; COMCO2 to stack, routine addr to HL
  E9CE    E9                    	JP	(HL)		; ..branch to routine
                                
  E9CF    CD E817               COMCO2:	CALL	WRFCB		; Write directory buffer on disk
  E9D2    CD E90A               	CALL	SEARCN		; Search next entry
  E9D5    18 EC                 	JR	COMCO1		; And test it
                                
                                
                                ; Rename File - Note Wildcard Support
                                
  E9D7    CD E9BD               RENAM:	CALL	COMCOD		; Go to common code w/VRENAM on stack
                                
  E9DA    CD E8AC               VRENAM:	CALL	CHKFRO		; Check file W/P
  E9DD    2A E05D               	LD	HL,(ARWORD)
  E9E0    11 0010               	LD	DE,16		; Offset to new name
  E9E3    19                    	ADD	HL,DE		; Add offset
  E9E4    EB                    	EX	DE,HL		; Copy HL=>DE
  E9E5    CD E6F1               	CALL	CALDIR		; Get directory entry
  E9E8    23                    	INC	HL
  E9E9    23                    	INC	HL
  E9EA    CB BE                 	RES	7,(HL)		; Make any renamed file private
  E9EC    2B                    	DEC	HL
  E9ED    2B                    	DEC	HL
  E9EE    06 0B                 	LD	B,11		; Set up loop counter
  E9F0    23                    RENAM1:	INC	HL		; Increment directory pointer
  E9F1    13                    	INC	DE		; Increment FCB pointer
  E9F2    1A                    	LD	A,(DE)		; Get character from FCB
  E9F3    E6 7F                 	AND	7FH		; Mask it
  E9F5    FE 3F                 	CP	'?'		; Test if question mark
  E9F7    20 01                 	JR	NZ,RENAM2	; no, then change character on disk
  E9F9    7E                    	LD	A,(HL)		; Else get what's there as there is no change
  E9FA    17                    RENAM2:	RLA			; Clear MSB
  E9FB    CB 16                 	RL	(HL)		; Get MSB from directory
  E9FD    1F                    	RRA			; And move to FCB
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-49


  E9FE    77                    	LD	(HL),A		; Save in directory
  E9FF    10 EF                 	DJNZ	RENAM1		; Loop until done
  EA01    C9                    	RET
                                
                                ; Change Status Bits for File
                                
  EA02    CD E9BD               CSTAT:	CALL	COMCOD		; Go to common code w/VCSTAT on stack
                                
  EA05    DD E5                 VCSTAT:	PUSH	IX
  EA07    D1                    	POP	DE		; FCB pointer in DE
  EA08    CD E6F1               	CALL	CALDIR		; Get directory entry
  EA0B    06 0B                 	LD	B,11		; Set up loop counter
  EA0D    23                    CSTAT1:	INC	HL		; Increment directory pointer
  EA0E    13                    	INC	DE		; Increment FCB pointer
  EA0F    3E 04                 	LD	A,4		; Are we pointing to Wheel Attribute?
  EA11    B8                    	CP	B
  EA12    20 0E                 	JR	NZ,CSTAT2	; ..jump if not
  EA14    E5                    	PUSH	HL
  EA15    2A E013               	LD	HL,(WHEEL)	; Else do we have Wheel privileges?
  EA18    7E                    	LD	A,(HL)
  EA19    E1                    	POP	HL
  EA1A    A7                    	AND	A		; ..set flags to show
  EA1B    20 05                 	JR	NZ,CSTAT2	; Jump if we have Wheel
  EA1D    CB 7E                 	BIT	7,(HL)		; Is file Wheel protected?
  EA1F    C2 E8CF               	JP	NZ,CHKFR2	; ..jump if so
  EA22    1A                    CSTAT2:	LD	A,(DE)		; Get status bit from FCB
  EA23    CB 16                 	RL	(HL)		; Remove MSB of directory
  EA25    17                    	RLA			; Get msb from FCB
  EA26    CB 1E                 	RR	(HL)		; And move into directory char
  EA28    10 E3                 	DJNZ	CSTAT1		; Loop until done
  EA2A    C9                    	RET
                                
                                ; Compute File Size
                                
  EA2B    01 0000               FILSZ:	LD	BC,0		; Reset file size length
  EA2E    51                    	LD	D,C
  EA2F    CD E515               	CALL	LDRRC		; Save it in FCB+33,34,35
  EA32    CD E8EE               	CALL	SEAR12		; Search file (hfb)
  EA35    CD E71C               FILSZ0:	CALL	TSTFCT		; Test if file found
  EA38    C8                    	RET	Z		; Not then exit
  EA39    CD E6F1               	CALL	CALDIR		; Get directory entry
  EA3C    EB                    	EX	DE,HL		; Copy to DE
  EA3D    21 000F               	LD	HL,15		; Offset to next record
  EA40    CD ED7F               	CALL	CALRRC		; Calculate random record count
  EA43    7A                    	LD	A,D		; Test LSB < (ix+33)
  EA44    DD 96 21              	SUB	(IX+33)
  EA47    79                    	LD	A,C		; Test ISB < (ix+34)
  EA48    DD 9E 22              	SBC	A,(IX+34)
  EA4B    78                    	LD	A,B		; Test MSB < (ix+35)
  EA4C    DD 9E 23              	SBC	A,(IX+35)
  EA4F    D4 E515               	CALL	NC,LDRRC	; Write new maximum
  EA52    CD E90A               	CALL	SEARCN		; Search next file
  EA55    18 DE                 	JR	FILSZ0		; And test it
                                
                                ; Find File
                                	  IF  UPATH
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-50


  EA57    CD E719               FINDF:	CALL	SRCT15		; Search file
  EA5A    C0                    	RET	NZ		; Yes then exit
  EA5B    3A E015               	LD	A,(FLAGS)
  EA5E    CB 6F                 	BIT	5,A		; Test if Path enabled
  EA60    C8                    	RET	Z		; Exit if not
  EA61    2A E011               	LD	HL,(PATH)	; Get Path address
  EA64    7C                    	LD	A,H		; Test if zero (no path)
  EA65    B5                    	OR	L
  EA66    C8                    	RET	Z		; Yes then exit
  EA67    7E                    FINDF0:	LD	A,(HL)		; Get first entry path name
  EA68    23                    	INC	HL		; Increment pointer
  EA69    B7                    	OR	A		; Test if last entry
  EA6A    CA E997               	JP	Z,SEARC8	; Yes then error exit
  EA6D    E6 7F                 	AND	7FH		; Mask drive number
  EA6F    FE 24                 	CP	'$'		; Test if current drive
  EA71    20 04                 	JR	NZ,FINDF1	; No then jump
  EA73    3A E02C               	LD	A,(DRIVE)	; Get current drive
  EA76    3C                    	INC	A		; Increment drive number
  EA77    3D                    FINDF1:	DEC	A		; Decrement drive number
  EA78    E5                    	PUSH	HL		; Save path pointer
  EA79    CD E581               	CALL	SELDK		; Select drive
  EA7C    E1                    	POP	HL		; Restore path pointer
  EA7D    7E                    	LD	A,(HL)		; Get user number
  EA7E    23                    	INC	HL		; Advance pointer
  EA7F    E6 7F                 	AND	7FH		; Mask user number
  EA81    FE 24                 	CP	'$'		; Test if current user
  EA83    20 03                 	JR	NZ,FINDF2	; No then jump
  EA85    3A E02A               	LD	A,(USER)	; Get current user
  EA88    E6 1F                 FINDF2:	AND	1FH		; Mask user number
  EA8A    E5                    	PUSH	HL		; Save path pointer
  EA8B    CD E55E               	CALL	RESUSR		; Add new user number in FCB+0 and FCB+13
  EA8E    CD E719               	CALL	SRCT15		; Search file and test if present
  EA91    E1                    	POP	HL		; Restore path pointer
  EA92    28 D3                 	JR	Z,FINDF0	; No then test next path entry
  EA94    E5                    	PUSH	HL		; Save path pointer
  EA95    CD E6F1               	CALL	CALDIR		; Get directory entry
  EA98    11 000A               	LD	DE,10		; Add offset system bit
  EA9B    19                    	ADD	HL,DE
  EA9C    CB 7E                 	BIT	7,(HL)		; Test system file
  EA9E    3A E015               	LD	A,(FLAGS)	; Test for relaxed path definition
  EAA1    17                    	RLA			; ..by rotating bit..
  EAA2    17                    	RLA			; ..into carry flag
  EAA3    E1                    	POP	HL		; Restore path pointer
  EAA4    38 02                 	JR	C,FINDF3	; If carry, system attrib not required
  EAA6    28 BF                 	JR	Z,FINDF0	; No system file then test next path entry
  EAA8    3A E02B               FINDF3:	LD	A,(DEFDRV)	; Get current drive
  EAAB    3C                    	INC	A		; Increment drive number
  EAAC    32 E02D               	LD	(FCB0),A	; Save it in exit FCB0
  EAAF    DD CB 07 FE           SETPSF:	SET	7,(IX+PSFATT)	; set Public/System file flag
  EAB3    C9                    	RET			; And return to caller
                                	  ENDIF		;Upath
                                
                                ; Open File Command
                                
  EAB4    CD E51F               CMND15:	CALL	SELDRV		; Select drive from FCB
  EAB7    DD 36 0E 00           	LD	(IX+FCBMOD),0	; Clear data module number
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-51


                                
                                ; Open File
                                	  IF  UPATH
  EABB    CD EA57               	CALL	FINDF		; Find file (use path name)
  EABE    CD E71C               	CALL	TSTFCT		; Test file found
                                	  ELSE
                                	CALL	SRCT15		; Find file W/O path
                                	  ENDIF		;Upath
  EAC1    C8                    	RET	Z		; No then exit
  EAC2    DD 7E 07              OPENF0:	LD	A,(IX+PSFATT)	; Get Public/System file bit
  EAC5    F5                    	PUSH	AF		; Save it
  EAC6    DD 7E 0C              	LD	A,(IX+FCBEXT)	; Get extent number from FCB
  EAC9    F5                    	PUSH	AF		; Save it
  EACA    CD E6F1               	CALL	CALDIR		; Get directory entry
  EACD    7E                    	LD	A,(HL)		; Find real user number file is in
  EACE    F6 80                 	OR	80H		; Set user valid flag
  EAD0    DD E5                 	PUSH	IX		; Save FCB entry
  EAD2    D1                    	POP	DE		; Get in in DE
  EAD3    01 0020               	LD	BC,32		; Number of bytes to move
  EAD6    ED B0                 	LDIR			; Move directory to FCB
  EAD8    DD 77 0D              	LD	(IX+FCBUSR),A	; And put user byte back
  EADB    CD ED7A               	CALL	SETB14		; Set FCB/File Not Modified
  EADE    DD 46 0C              	LD	B,(IX+FCBEXT)	; Get extent number
  EAE1    DD 4E 0F              	LD	C,(IX+FCBREC)	; Get next record number
  EAE4    F1                    	POP	AF		; Get old extent number
  EAE5    DD 77 0C              	LD	(IX+FCBEXT),A	; Save it
  EAE8    B8                    	CP	B		; Compare old and new extent number
  EAE9    28 04                 	JR	Z,OPENF1	; Same then jump
  EAEB    0E 00                 	LD	C,0		; Set next record count to 0
  EAED    CB 19                 	RR	C		; Record count to Max (80H) if need new extent
  EAEF    DD 71 0F              OPENF1:	LD	(IX+FCBREC),C	; Save next record count
  EAF2    F1                    	POP	AF		; Get Public/System file bit
  EAF3    DD CB 07 16           	RL	(IX+PSFATT)	; Remove MSB from IX+8
  EAF7    17                    	RLA			; Set new MSB in carry
  EAF8    DD CB 07 1E           	RR	(IX+PSFATT)	; Save Carry in IX+8
                                	  IF  ZS
  EAFC    2A E018               	LD	HL,(STLAV)	; Get address of last accessed routine
  EAFF    C3 EDB9               	JP	STAMPT
                                	  ELSE
                                	LD	C,5		; Set access stamp
                                	LD	HL,(STLAV)	; Get address of last accessed routine
                                JPHL:	JP	(HL)		; ..and Jump to it (or DOTDER)
                                	  ENDIF		;Zs
                                
                                ; Make File Command
                                
  EB02    CD E51F               CMND22:	CALL	SELDRV		; Select drive from FCB
  EB05    DD 36 0E 00           	LD	(IX+FCBMOD),0	; Clear data module number
                                
                                ; Make File
                                
  EB09    CD E8D8               MAKES:	CALL	CHKRO		; Check drive W/P
  EB0C    2A E05D               	LD	HL,(ARWORD)
  EB0F    7E                    	LD	A,(HL)		; Get first byte FCB
  EB10    F5                    	PUSH	AF		; Save it
  EB11    36 E5                 	LD	(HL),0E5H	; Set first byte to empty file
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-52


  EB13    3E 01                 	LD	A,1		; Search for 1 byte
  EB15    CD E8F3               	CALL	SEARCH		; Search empty file
  EB18    F1                    	POP	AF		; Get first byte FCB
  EB19    DD 77 00              	LD	(IX+0),A	; Restore it
  EB1C    CD E71C               	CALL	TSTFCT		; Test empty file found
  EB1F    C8                    	RET	Z		; No then return error
  EB20    2A E05D               	LD	HL,(ARWORD)	; Get FCB pointer
  EB23    CD E452               	CALL	CKSUB		; Check if this is a submit file
  EB26    11 000F               	LD	DE,15		; Prepare offset
  EB29    19                    	ADD	HL,DE		; Add it
  EB2A    06 11                 	LD	B,17		; Set loop counter
  EB2C    AF                    	XOR	A
  EB2D    77                    MAKE0:	LD	(HL),A		; Clear FCB+15 up to FCB+31
  EB2E    23                    	INC	HL		; Increment pointer
  EB2F    10 FC                 	DJNZ	MAKE0		; And clear all bytes
  EB31    DD CB 07 BE           	RES	7,(IX+PSFATT)	; Reset Public/System file bit
  EB35    DD CB 0B BE           	RES	7,(IX+ARCATT)	; Reset archive bit if present
  EB39    CD E6F1               	CALL	CALDIR		; Get directory entry
  EB3C    DD E5                 	PUSH	IX		; Save FCB entry
  EB3E    D1                    	POP	DE		; Get it in DE
  EB3F    EB                    	EX	DE,HL		; Exchange FCB and directory entry
  EB40    01 0020               	LD	BC,32		; Number of bytes to move
  EB43    ED B0                 	LDIR			; Move bytes
  EB45    CD E817               	CALL	WRFCB		; Write FCB on disk
  EB48    CD ED7A               	CALL	SETB14		; Set file not modified
                                	  IF  ZS
  EB4B    2A E01A               	LD	HL,(STCRV)	; Get address of Stamp Create routine
  EB4E    C3 EDB9               	JP	STAMPT		; ..and stamp it
                                	  ELSE
                                	LD	C,0		; Set Create Stamp
                                	JP	STIME		; And exit
                                	  ENDIF		;Zs
                                
                                ; Open Next Extent
                                
  EB51    DD CB 0E 7E           OPENEX:	BIT	7,(IX+FCBMOD)	; Test if FCB/File Modified (write)
  EB55    20 08                 	JR	NZ,OPENX2	; Not then jump
  EB57    CD E7AB               	CALL	CLOSE		; Close current FCB
  EB5A    3A E04C               	LD	A,(PEXIT)	; Get exit code
  EB5D    3C                    	INC	A		; Test if error
  EB5E    C8                    	RET	Z		; Yes then exit
  EB5F    CD EB85               OPENX2:	CALL	CALNEX		; Calculate next extent (LABEL MOVED)
  EB62    38 13                 	JR	C,OPENX3	; Error then jump
                                
  EB64    CD E719               OPENX0:	CALL	SRCT15		; Search for 15-char match & test presence
  EB67    20 16                 	JR	NZ,OPENX5	; Yes then jump
  EB69    3A E04F               	LD	A,(RDWR)	; Test Read/Write flag
  EB6C    B7                    	OR	A		; Test if read
  EB6D    28 08                 	JR	Z,OPENX3	; Yes then error
  EB6F    CD EB09               	CALL	MAKES		; Make new extent if write
  EB72    CD E71C               	CALL	TSTFCT		; Test if succesfull
  EB75    20 0B                 	JR	NZ,OPENX6	; Yes then exit
  EB77    CD ED7A               OPENX3:	CALL	SETB14		; Set FCB/File Not Modified
  EB7A    3E FF                 RETCFF:	LD	A,0FFH		; (hfb/cwc) set exit code
  EB7C    C3 E4BB               OPENX4:	JP	SAVEA		; And return to caller
                                
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-53


  EB7F    CD EAC2               OPENX5:	CALL	OPENF0		; Open file
  EB82    AF                    OPENX6:	XOR	A		; And clear exit code
  EB83    18 F7                 	JR	OPENX4		; Use same routine
                                
                                ;==OPENX2:	CALL	CALNEX		; Calculate next extent
                                ;==	JR	C,OPENX3	; Error then jump
                                ;==	JR	OPENX0		; Open next extent, FCB contains DU:
                                
                                ; Calculate Next Extent
                                ;  Exit: Carry=1 => Overflow Detected
                                
  EB85    CD EBA6               CALNEX:	CALL	GETDME		; Get extent number, data module number
  EB88    CB 70                 	BIT	6,B		; Test error bit random record
  EB8A    37                    	SCF			; Set error flag
  EB8B    C0                    	RET	NZ		; ..Error exit if Non-zero
  EB8C    0C                    	INC	C		; Increment extent number
  EB8D    79                    	LD	A,C		; Get extent number
  EB8E    E6 1F                 	AND	MAXEXT		; Mask it for max extent
  EB90    4F                    	LD	C,A		; Save it in C
                                ;==	JR	NZ,SETDME	; If new data module not required
  EB91    20 07                 	JR	NZ,CALNE1	;== IF NEW DATA MODULE NOT REQUIRED
  EB93    04                    	INC	B		; Set next data module
  EB94    78                    	LD	A,B		; Get it in A
  EB95    E6 3F                 	AND	MAXMOD		; Mask it for max module
  EB97    47                    	LD	B,A		; Save it in B
  EB98    37                    	SCF			; Set error flag
  EB99    C8                    	RET	Z		; And return if file overflow
  EB9A    DD 36 20 00           CALNE1:	LD	(IX+NXTREC),0	;== ZERO NEXT RECORD COUNT
  EB9E    DD 71 0C              SETDME:	LD	(IX+FCBEXT),C	; Save Extent number
  EBA1    DD 70 0E              	LD	(IX+FCBMOD),B	; Save Data Module number
                                	  IF  ZS
  EBA4    A7                    	AND	A		; Clear flag here if ZS
  EBA5    C9                    	RET
                                	  ENDIF			; ..else fall thru on ZD to do same thing
                                
  EBA6    DD 4E 0C              GETDME:	LD	C,(IX+FCBEXT)	; Get Extent number
  EBA9    DD 46 0E              	LD	B,(IX+FCBMOD)	; Get Data Module number
  EBAC    79                    	LD	A,C
  EBAD    CD E98C               	CALL	SEARC7A		; Mask Extent
  EBB0    CB B8                 	RES	7,B		; Clear Unmodified Flag
  EBB2    B0                    	OR	B		; Test for Module and Extent = 0
  EBB3    C9                    	RET			; ..and return to caller
                                
                                ; Read Random Record Command
                                
  EBB4    CD E52D               CMND33:	CALL	SELDR1		; Select drive from FCB
                                
                                ; Read Random Sector
                                
  EBB7    AF                    	XOR	A		; Set read/write flag
  EBB8    CD ECF6               	CALL	LDFCB		; Load random record in FCB
  EBBB    28 04                 	JR	Z,READS		; No error then read sector
  EBBD    C9                    	RET			; Return error
                                
                                ; Read Sequential
                                
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-54


  EBBE    CD E52D               CMND20:	CALL	SELDR1		; Select drive from FCB
                                
                                ; Read Sector
                                
  EBC1    AF                    READS:	XOR	A		; Set Read/Write flag
  EBC2    32 E04F               	LD	(RDWR),A	; Save it
  EBC5    DD 7E 20              	LD	A,(IX+NXTREC)	; Get record counter
  EBC8    FE 80                 	CP	80H		; Test if last record this extent
                                ;=	JR	NC,READS1	; Yes then open next extent
  EBCA    28 09                 	JR	Z,READS1	;= Yes then open next extent
  EBCC    DD BE 0F              	CP	(IX+FCBREC)	; Test if greater then current record
  EBCF    38 07                 	JR	C,READS2	; No then get record
  EBD1    3E 01                 READS0:	LD	A,1		; Set end of file flag
  EBD3    18 A7                 	JR	OPENX4		; And exit
                                
  EBD5    CD EBE9               READS1:	CALL	OPNXCK		; Open next extent
  EBD8    CD E6AA               READS2:	CALL	GETDM		; Get block number from DM in FCB
  EBDB    28 F4                 	JR	Z,READS0	; Jump if block number=0 to end file
  EBDD    CD E6D7               	CALL	CALSEC		; Calculate Sector Number (128 bytes)
  EBE0    CD E67A               	CALL	CALST		; Calculate Sector/Track number
  EBE3    CD E795               	CALL	READR		; Read data
  EBE6    C3 ECE4               	JP	WRITS7		; Increment elsewhere if necessary
                                
                                ; Consolidated Routine to Open Extent and check status
                                
  EBE9    CD EB51               OPNXCK:	CALL	OPENEX		; Open next extent
  EBEC    3A E04C               	LD	A,(PEXIT)	; Get exit code
  EBEF    B7                    	OR	A
  EBF0    C8                    	RET	Z		;== IF OPEN OK
  EBF1    E1                    	POP	HL		;== ELSE POP RETURN ADDRESS TO ABORT R/W
  EBF2    18 DD                 	JR	READS0		;== AND SET ERROR CODE TO EOF
                                ;==	JR	NZ,READS0	; Yes then end of file
                                ;==	LD	(IX+NXTREC),A	; Clear record counter (jww)
                                ;==	RET
                                
                                ; Write Random Record Command (with and without Zero Fill)
                                
  EBF4                          CMND40:				; (hfb/cwc)
  EBF4    CD E52D               CMND34:	CALL	SELDR1		; Select drive from FCB
                                
                                ; Write Random Sector and Write Random with Zero Fill
                                
  EBF7    3E FF                 	LD	A,0FFH		; Set Read/Write flag
  EBF9    CD ECF6               	CALL	LDFCB		; Load FCB from random record
  EBFC    28 04                 	JR	Z,WRITES	; No error then write record
  EBFE    C9                    	RET			; Return error
                                
                                ; Write Sequential
                                
  EBFF    CD E52D               CMND21:	CALL	SELDR1		; Select drive from FCB
                                
                                ; Write Sector.  Permitted to PUBlic files and those found along Path
                                
  EC02    3E FF                 WRITES:	LD	A,0FFH		; Set read/write flag
  EC04    32 E04F               	LD	(RDWR),A	; And save it
                                
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-55


  EC08                          BGPTCH1	EQU	$+1		;<-- Patched location for BGii
                                
  EC07    CD E8D8               	CALL	CHKRO		; Check disk W/P
  EC0A    DD CB 09 7E           	BIT	7,(IX+ROATT)	; Test if file W/P
  EC0E    20 0E                 	JR	NZ,WRITSA	; Yes then file W/P message
  EC10    CD E8C4               	CALL	CHKFR3		; Test W/P if path or Public used
  EC13    2A E013               	LD	HL,(WHEEL)	; Get address of Wheel byte
  EC16    7E                    	LD	A,(HL)		; Do we have it?
  EC17    A7                    	AND	A
  EC18    20 07                 	JR	NZ,WRITSB	; Yes - allow write
  EC1A    DD CB 08 7E           	BIT	7,(IX+WHLATT)	; Else test if Wheel Prot file
  EC1E    C2 E8CF               WRITSA:	JP	NZ,CHKFR2	; Yes then file W/P message
  EC21    DD CB 20 7E           WRITSB:	BIT	7,(IX+NXTREC)	; End of this extent?
  EC25    C4 EBE9               	CALL	NZ,OPNXCK	; Open next extent and check status (hfb)
  EC28    CD E6AA               	CALL	GETDM		; Get block number from FCB
  EC2B    C2 ECC3               	JP	NZ,WRITS5	; Jump to write sector if Block Number <> 0
  EC2E    E5                    	PUSH	HL		; Save pointer to Block Number
  EC2F    79                    	LD	A,C		; Test first Block Number in extent
  EC30    B7                    	OR	A
  EC31    28 04                 	JR	Z,WRITS1	; Yes then jump
  EC33    3D                    	DEC	A		; Decrement pointer to Block Number
  EC34    CD E6C0               	CALL	GETDM4		; Get previous Block Number
                                
                                ; Get Free Block from ALV Buffer
                                ;  Entry DE=Old Block Number
                                ;  Exit  DE=New Block Number (0 if No Free Block)
                                ;   HL counts Up,DE counts Down
                                				; GETFRE routine relocated here inline
  EC37    62                    WRITS1:	LD	H,D		; Copy old block to HL
  EC38    6B                    	LD	L,E
  EC39    7A                    GETFR0:	LD	A,D		; Test down counter is zero
  EC3A    B3                    	OR	E
  EC3B    28 0B                 	JR	Z,GETFR1	; Yes then jump
  EC3D    1B                    	DEC	DE		; Decrememt down counter
  EC3E    E5                    	PUSH	HL		; Save up/down counter
  EC3F    D5                    	PUSH	DE
  EC40    CD E844               	CALL	GETBIT		; Get bit from ALV buffer
  EC43    1F                    	RRA			; Test if zero
  EC44    30 20                 	JR	NC,GETFR3	; Yes then found empty block
  EC46    D1                    	POP	DE		; Get up/down counter
  EC47    E1                    	POP	HL
  EC48    ED 4B E041            GETFR1:	LD	BC,(MAXLEN)	; Get maximum ALV length-1 in BC
  EC4C    7D                    	LD	A,L		; Is HL >= length ALV-1?
  EC4D    91                    	SUB	C		; ..do while preserving HL
  EC4E    7C                    	LD	A,H
  EC4F    98                    	SBC	A,B
  EC50    30 0E                 	JR	NC,GETFR2	; End buffer then jump
  EC52    23                    	INC	HL		; Increment up counter
  EC53    D5                    	PUSH	DE		; Save down/up counter
  EC54    E5                    	PUSH	HL
  EC55    EB                    	EX	DE,HL		; Save up counter in DE
  EC56    CD E844               	CALL	GETBIT		; Get bit from ALV buffer
  EC59    1F                    	RRA			; Test if zero
  EC5A    30 0A                 	JR	NC,GETFR3	; Yes then found empty block
  EC5C    E1                    	POP	HL		; Get down/up counter
  EC5D    D1                    	POP	DE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-56


  EC5E    18 D9                 	JR	GETFR0		; And test next block
                                
  EC60    7A                    GETFR2:	LD	A,D		; Test if last block tested
  EC61    B3                    	OR	E
  EC62    20 D5                 	JR	NZ,GETFR0	; No then test next block
  EC64    18 07                 	JR	WRITSG		; Continue with DE=0
                                
  EC66    37                    GETFR3:	SCF			; Set block number used
  EC67    17                    	RLA			; Save bit
  EC68    CD E868               	CALL	SETBT0		; Put bit in ALV buffer
  EC6B    D1                    	POP	DE		; Get correct counter
  EC6C    E1                    	POP	HL		; Restore stack pointer
                                				; ..continue with (DE=block number)
                                
  EC6D    E1                    WRITSG:	POP	HL		; Get pointer to Block Number
  EC6E    7A                    	LD	A,D		; Test if blocknumber = 0
  EC6F    B3                    	OR	E
  EC70    28 7F                 	JR	Z,WRITS8	; Yes then disk full error
  EC72    DD CB 0E BE           	RES	7,(IX+FCBMOD)	; Reset FCB/File Modified
  EC76    73                    	LD	(HL),E		; Save blocknumber
  EC77    3A E042               	LD	A,(MAXLEN+1)	; Get number of blocks
  EC7A    B7                    	OR	A		; Is it < 256?
  EC7B    28 02                 	JR	Z,WRITS2	; ..Jump if so
  EC7D    23                    	INC	HL		; Increment to MSB Block Number
  EC7E    72                    	LD	(HL),D		; ..and save MSB block number
  EC7F    0E 02                 WRITS2:	LD	C,2		; Set write new block flag
  EC81    3A E03F               	LD	A,(NMASK)	; Get sector mask
  EC84    DD A6 20              	AND	(IX+NXTREC)	; Mask with record counter
  EC87    28 02                 	JR	Z,WRITSX	; Zero then Ok (at start new record)
  EC89    0E 00                 	LD	C,0		; Else clear new block flag
  EC8B    3A E04B               WRITSX:	LD	A,(FUNCT)	; Get function number
  EC8E    D6 28                 	SUB	40		; Test if Write RR with zero fill
  EC90    20 33                 	JR	NZ,WRITS6	; No then jump
  EC92    D5                    	PUSH	DE		; Save blocknumber
  EC93    2A E034               	LD	HL,(DIRBUF)	; Use directory buffer for zero fill
  EC96    06 80                 	LD	B,128		; 128 bytes to clear
  EC98    77                    WRITS3:	LD	(HL),A		; Clear directory buffer
  EC99    23                    	INC	HL		; Increment pointer
  EC9A    10 FC                 	DJNZ	WRITS3		; Clear all bytes
  EC9C    CD E6D7               	CALL	CALSEC		; Calculate sector number (128 bytes)
  EC9F    3A E03F               	LD	A,(NMASK)	; Get sector mask
  ECA2    47                    	LD	B,A		; Copy it
  ECA3    04                    	INC	B		; Increment it to get number of writes
  ECA4    2F                    	CPL			; Complement sector mask
  ECA5    A3                    	AND	E		; Mask sector number
  ECA6    5F                    	LD	E,A		; And save it
  ECA7    0E 02                 	LD	C,2		; Set write new block flag
  ECA9    E5                    WRITS4:	PUSH	HL		; Save registers
  ECAA    D5                    	PUSH	DE
  ECAB    C5                    	PUSH	BC
  ECAC    CD E67A               	CALL	CALST		; Calculate sector/track
  ECAF    CD E83D               	CALL	DMADIR		; Set DMA directory buffer
  ECB2    C1                    	POP	BC		; Get write new block flag
  ECB3    C5                    	PUSH	BC		; Save it again
  ECB4    CD E79A               	CALL	WRITER		; Write record on disk
  ECB7    C1                    	POP	BC		; Restore registers
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-57


  ECB8    D1                    	POP	DE
  ECB9    E1                    	POP	HL
  ECBA    0E 00                 	LD	C,0		; Clear write new block flag
  ECBC    1C                    	INC	E		; Increment sector number
  ECBD    10 EA                 	DJNZ	WRITS4		; Write all blocks
  ECBF    CD E837               	CALL	STDMA		; Set user DMA address
  ECC2    D1                    	POP	DE		; Get Block Number
  ECC3    0E 00                 WRITS5:	LD	C,0		; Clear write new block flag
  ECC5    DD CB 0E BE           WRITS6:	RES	7,(IX+FCBMOD)	; Reset FCB/File Modified flag
  ECC9    C5                    	PUSH	BC		; Save it
  ECCA    CD E6D7               	CALL	CALSEC		; Calculate sector number (128 bytes)
  ECCD    CD E67A               	CALL	CALST		; Calculate Sector/Track
  ECD0    C1                    	POP	BC		; Get write new block flag
  ECD1    CD E79A               	CALL	WRITER		; Write record on disk
  ECD4    DD 7E 20              	LD	A,(IX+NXTREC)	; Get record counter
  ECD7    DD BE 0F              	CP	(IX+FCBREC)	; Compare with next record
  ECDA    38 08                 	JR	C,WRITS7	; If less then jump
  ECDC    3C                    	INC	A		; Increment record count
  ECDD    DD 77 0F              	LD	(IX+FCBREC),A	; Save it on next record position
  ECE0    DD CB 0E BE           	RES	7,(IX+FCBMOD)	; Reset FCB/File Modified flag
  ECE4    3A E04B               WRITS7:	LD	A,(FUNCT)	; Get function number
  ECE7    FE 14                 	CP	20		; (hfb)
  ECE9    D8                    	RET	C		; Return if < 20 (hfb)
  ECEA    FE 16                 	CP	21+1		; (hfb)
  ECEC    D0                    	RET	NC		; Return if > 21 (hfb)
  ECED    DD 34 20              	INC	(IX+NXTREC)	; Increment record count
  ECF0    C9                    	RET			; And return to caller
                                
  ECF1    3E 02                 WRITS8:	LD	A,2		; Set disk full error
  ECF3    C3 E4BB               	JP	SAVEA		; And return to caller 
                                
                                
                                ; Load FCB for Random Read/Write
                                ;  Exit : Zero Flag = 1 No Error
                                ;		      0 Error Occured
                                
  ECF6    32 E04F               LDFCB:	LD	(RDWR),A	; Save Read/Write flag
  ECF9    DD 7E 21              	LD	A,(IX+33)	; Get first byte random record
  ECFC    57                    	LD	D,A		; Save it in D
  ECFD    CB BA                 	RES	7,D		; Reset MSB to get next record
  ECFF    17                    	RLA			; Shift MSB in carry
  ED00    DD 7E 22              	LD	A,(IX+34)	; Load next byte random record
  ED03    17                    	RLA			; Shift Carry
  ED04    F5                    	PUSH	AF		; Save it
  ED05    E6 1F                 	AND	MAXEXT		; Mask next extent
  ED07    4F                    	LD	C,A		; Save it in C
  ED08    F1                    	POP	AF		; Get byte
  ED09    17                    	RLA			; Shift 4 times
  ED0A    17                    	RLA
  ED0B    17                    	RLA
  ED0C    17                    	RLA
  ED0D    E6 0F                 	AND	0FH		; Mask it
  ED0F    47                    	LD	B,A		; Save data module number
  ED10    DD 7E 23              	LD	A,(IX+35)	; Get next byte random record
  ED13    1E 06                 	LD	E,6		; Set random record to large flag
  ED15    FE 04                 	CP	4		; Test random record to large
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-58


  ED17    30 5C                 	JR	NC,LDFCB8	; Yes then error
  ED19    07                    	RLCA			; Shift 4 times
  ED1A    07                    	RLCA
  ED1B    07                    	RLCA
  ED1C    07                    	RLCA
  ED1D    80                    	ADD	A,B		; Add byte
  ED1E    47                    	LD	B,A		; Save data module number in B
  ED1F    DD 72 20              	LD	(IX+NXTREC),D	; Set next record count
  ED22    DD 56 0E              	LD	D,(IX+FCBMOD)	; Get data module number
  ED25    CB 72                 	BIT	6,D		; Test error random record
  ED27    20 0E                 	JR	NZ,LDFCB0	; Yes then jump
  ED29    79                    	LD	A,C		; Get new extent number
  ED2A    DD BE 0C              	CP	(IX+FCBEXT)	; Compare with FCB
  ED2D    20 08                 	JR	NZ,LDFCB0	; Not equal then open next extent
  ED2F    78                    	LD	A,B		; Get new data module number
  ED30    DD AE 0E              	XOR	(IX+FCBMOD)	; Compare with data module number
  ED33    E6 3F                 	AND	MAXMOD		; Mask it
  ED35    28 37                 	JR	Z,LDFCB6	; Equal then return
  ED37    CB 7A                 LDFCB0:	BIT	7,D		; Test FCB modified (write)
  ED39    20 0F                 	JR	NZ,LDFCB1	; No then jump
  ED3B    D5                    	PUSH	DE		; Save registers
  ED3C    C5                    	PUSH	BC
  ED3D    CD E7AB               	CALL	CLOSE		; Close extent
  ED40    C1                    	POP	BC		; Restore registers
  ED41    D1                    	POP	DE
  ED42    1E 03                 	LD	E,3		; Set close error
  ED44    3A E04C               	LD	A,(PEXIT)	; Get exit code
  ED47    3C                    	INC	A
  ED48    28 27                 	JR	Z,LDFCB7	; Error then exit
  ED4A    CD EB9E               LDFCB1:	CALL	SETDME		; Save Data Module and Extent
  ED4D    CD E8F1               	CALL	SEAR15		; Search next FCB
  ED50    3A E04C               	LD	A,(PEXIT)	; Get error code
  ED53    3C                    	INC	A
  ED54    20 15                 	JR	NZ,LDFCB5	; No error then exit
  ED56    3A E04F               	LD	A,(RDWR)	; Get read/write flag
  ED59    1E 04                 	LD	E,4		; Set read empty record
  ED5B    3C                    	INC	A
  ED5C    20 13                 	JR	NZ,LDFCB7	; Read then error
  ED5E    CD EB09               	CALL	MAKES		; Make new FCB
  ED61    1E 05                 	LD	E,5		; Set make error
  ED63    3A E04C               	LD	A,(PEXIT)	; Get error code
  ED66    3C                    	INC	A
  ED67    28 08                 	JR	Z,LDFCB7	; Error then exit
  ED69    18 03                 	JR	LDFCB6		; No error exit (zero set)
                                
  ED6B    CD EAC2               LDFCB5:	CALL	OPENF0		; Open file
  ED6E    C3 EB82               LDFCB6:	JP	OPENX6		; Set zero flag and clear error code 
                                
  ED71    DD 36 0E C0           LDFCB7:	LD	(IX+FCBMOD),0C0H ; Set random record error
  ED75    7B                    LDFCB8:	LD	A,E		; Get error code
  ED76    32 E04C               	LD	(PEXIT),A	; And save it
  ED79    B7                    	OR	A		; Clear zero flag
  ED7A    DD CB 0E FE           SETB14:	SET	7,(IX+FCBMOD)	; (hfb) get FCB/File Not Modified
  ED7E    C9                    	RET			; And return to caller
                                
                                ; Calculate Random Record
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-59


                                ;  Entry HL=Offset in FCB
                                ;	 DE=FCB Pointer
                                ;  Exit  D=LSB Random Record
                                ;	 C=ISB Random Record
                                ;	 B=MSB Random Record
                                
  ED7F    19                    CALRRC:	ADD	HL,DE		; Pointer to FCB+15 or FCB+32
  ED80    7E                    	LD	A,(HL)		; Get record number
  ED81    21 000C               	LD	HL,12		; Offset to extent number
  ED84    19                    	ADD	HL,DE		; Get pointer to extent byte
  ED85    57                    	LD	D,A		; Save record number
  ED86    7E                    	LD	A,(HL)		; Get extent byte
  ED87    E6 1F                 	AND	MAXEXT		; Mask it 000eeeee
  ED89    CB 12                 	RL	D		; Shift MSB in Carry Cy=R, d=rrrrrrr0
  ED8B    CE 00                 	ADC	A,0		; Add Carry 00xeeeex
  ED8D    1F                    	RRA			; Shift 1 time (16 bits) 000xeeee
  ED8E    CB 1A                 	RR	D		; D=xrrrrrrr
  ED90    4F                    	LD	C,A		; Save ISB
  ED91    23                    	INC	HL		; Increment to data module number
  ED92    23                    	INC	HL
  ED93    7E                    	LD	A,(HL)		; Get data module number 00mmmmmm
  ED94    0F                    	RRCA			; Divide module by 16
  ED95    0F                    	RRCA
  ED96    0F                    	RRCA
  ED97    0F                    	RRCA
  ED98    F5                    	PUSH	AF		; Save it mmmm00mm
  ED99    E6 03                 	AND	03H		; Mask for maximum module
  ED9B    47                    	LD	B,A		; Save it 000000mm
  ED9C    F1                    	POP	AF		; Get LSB
  ED9D    E6 F0                 	AND	0F0H		; Mask it mmmm0000
  ED9F    81                    	ADD	A,C		; Add with ISB mmmxeeee
  EDA0    4F                    	LD	C,A		; Save ISB
  EDA1    D0                    	RET	NC		; No carry then return
  EDA2    04                    	INC	B		; Increment MSB 000000mm
  EDA3    C9                    	RET			; And return to caller
                                				; 000000mm mmmxeeee xrrrrrrr
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-60


                                
                                	  IF  ZS
                                ;************************************************************************
                                ;*	  U n i v e r s a l   T i m e / D a t e   S u p p o r t 	*
                                ;************************************************************************
                                
                                ; In order to provide time/date support for as many systems as possible,
                                ; a set of universal routines are used.  These routines do not do the
                                ; actual stamping, but provide all the data required to method specific
                                ; programs to perform the needed services.  To use the DOS services, the
                                ; external handler needs to tie itself into the Time/Date vector table
                                ; in the ZSDOS configuration area.  The Get Stamp, Put Stamp, Stamp Last
                                ; Access, Stamp Create, and Stamp Modify routines receive the following
                                ; parameters in the Z80 registers:
                                ;	A  = Offset to DIR entry [0,20H,40H,60H]
                                ;	BC = Address of ZSDOS WRFCB routine
                                ;	DE = Pointer to Directory Buffer
                                ;	HL = DMA address
                                ;	IX = Pointer to FCB passed to DOS
                                ; The directory buffer contains the dir entry for the FCB passed to DOS,
                                ; A contains the offset.  The disk has been tested for R/O on all calls
                                ; except get stamp and is R/W.	If a CP/M+ style stamping is used, a simple
                                ; call to the address passed in BC is used to update the disk after adding
                                ; the time as required.  This call is ALWAYS required.	The routines may
                                ; use AF,BC,DE, and HL without restoring them.	Four levels of stack are
                                ; available on the DOS stack for use by the functions.	All routines must
                                ; exit with a RET instruction, and A=1 if successful, A=0FFH if error.
                                
                                ; Get/put Timestamps
                                
  EDA4                          CMD102:
  EDA4    CD E51F               CMD103:	CALL	SELDRV		; Select DU: from FCB
  EDA7    CD E719               	CALL	SRCT15		; Find the FCB
  EDAA    28 31                 	JR	Z,DOTDER	; If not found
  EDAC    2A E01E               	LD	HL,(GETSTV)	; Get time stamp function address
  EDAF    3A E04B               	LD	A,(FUNCT)
  EDB2    FE 66                 	CP	102		; Get stamp?
  EDB4    28 0A                 	JR	Z,DOTDR3	; Yes
  EDB6    2A E020               	LD	HL,(PUTSTV)	; Get address of set stamp routine
                                				; ..fall thru to common code..
                                ; Enter here for Stamp Last Access, Stamp Create, Stamp Modify
                                
  EDB9    E5                    STAMPT:	PUSH	HL
  EDBA    CD E8E5               	CALL	CHKRO1		; Test for disk W/P but avoid error trap
  EDBD    E1                    	POP	HL
  EDBE    28 1D                 	JR	Z,DOTDER	; No stamp if disk is W/P
                                
  EDC0    CD EBA6               DOTDR3:	CALL	GETDME		; Get Data Module and Extent Number
  EDC3    20 18                 	JR	NZ,DOTDER	; ..Quit if Not Extent 0 of Module 0
  EDC5    3A E056               	LD	A,(SECPNT)	; Offset to FCB in dirbuf
  EDC8    ED 5B E034            	LD	DE,(DIRBUF)	; Dir buffer pointer
  EDCC    01 E817               	LD	BC,WRFCB	; Address of WRFCB routine
  EDCF    E5                    	PUSH	HL		; Save function vector
  EDD0    2A E02E               	LD	HL,(DMA)	; Put DMA in HL
  EDD3    C9                    	RET			; Then vector to routine
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-61


                                
                                ; Time and Date Routines.  Like the date stamping routines, the user must
                                ; supply the actual driver routines for time and date.	These routines are
                                ; attached to ZSDOS via the vector table in the configuration area.  The
                                ; routines are passed the address to Get/Put the Time and Date in the DE
                                ; and IX registers.  The routines may use AF,BC, and D without restor-
                                ; ing them.  Four levels of stack are available on the DOS stack for use
                                ; by the the functions.  All routines must exit with a RET instruction,
                                ; and A=1 if successful, A=0FFH if error.
                                ; In order to better provide for internal DateStamper, the clock routines
                                ; must save the value at DE+5 when called, and return this value to the
                                ; DOS in the E register.  In addition, the HL register must be returned
                                ; as the called DE value +5.
                                ; The Time/Date string consists of 6 packed BCD digits arrayed as:
                                ;	Byte	00 01 02 03 04 05
                                ;		YY MM DD HH MM SS
                                
                                ; Set Time/Date from user-supplied buffer string
                                
  EDD4    0E 01                 CMD99:	LD	C,1		; Set parameter to set time/date
  EDD6    21                    	DEFB	21H		; ..and fall thru to GSTD
                                
                                ; Get Time/Date to string whose address is supplied by the user
                                
  EDD7    0E 00                 CMD98:	LD	C,0		; Set parameter to get time/date
  EDD9    2A E016               GSTD:	LD	HL,(GSTIME)	; Get time/date get/set routine address
  EDDC    E5                    	PUSH	HL		; ..to stack for pseudo "Jump"
  EDDD    F6 FF                 DOTDER:	OR	0FFH		; Save 1 T state while setting flags
  EDDF    C9                    	RET			; Vector to service routine
                                	  ENDIF		;Zs
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-62


                                
                                	  IF  NOT ZS
                                ;---------------------------------------------------------------------
                                ;	   Z D D O S    T i m e    R o u t i n e s    <crw>
                                ;---------------------------------------------------------------------
                                ; STIME - Set file's time and date in !!!TIME&.DAT file
                                ;
                                ; Entry: SECPNT and RECDIR set by search for file.
                                ;	 BC = 10 - set Modify date/time
                                ;	 BC =  5 - set Last Access date/time
                                ;	 BC =  0 - set Create date/time, zero modify & access
                                ;
                                ; Exit : Zero Flag Set (Z) if Time Set in !!!TIME&.DAT file
                                ;	 Zero Flag Reset (NZ) if error or "No Stamp" attribute Set
                                ;
                                ; Note : Only the first extent's stamp is valid.
                                
                                STIME:	LD	A,(TDCHEK)	; See if !!!TIME&.DAT
                                RETNZ:	OR	A		; ..file on disk, clear Carry
                                	RET	NZ		; No.  (NZ) flags error
                                
                                	BIT	7,(IX+3)	; Datestamper (tm) "no stamp" bit
                                	RET	NZ		; Don't stamp this file
                                
                                	PUSH	BC
                                	CALL	GETDME		; See if this is Extent 0 of Module 0
                                	POP	BC
                                	RET	NZ		; Quit Now if it isn't
                                
                                	LD	B,A		; Zero B
                                	LD	A,(FUNCT)	; Get Current Function
                                	CP	102		; Is it Get Stamp?
                                	JR	Z,STIME0	; ..jump to skip R/O test if so
                                	CALL	CHKRO1		; Else test for Disk R/O w/o Error Exit
                                	JP	Z,DOTDER	; ..and Quit if Error
                                
                                STIME0:	PUSH	BC		; Save 0, 5, or 10
                                
                                ; 1. Get disk sector number of file's T&D record, save offset in T&D
                                ;	sector for later.
                                
                                				; Carry cleared from above
                                	LD	A,(SECPNT)	; 0-relative dir. sector offset
                                				; ..of file FCB (0, 32, 64, or 96)
                                	RRA			; Divide by 2 for !!!TIME&.DAT offset
                                				; ..a = 0, 16, 32, or 48
                                	LD	HL,(RECDIR)	; 0-relative directory sector of FCB
                                	SRL	H		; Divide by 2 to get 0-relative
                                				; ..sector of T&D file in HL
                                	RR	L		; Odd directory sector sets Carry
                                	JR	NC,STIME1
                                	ADD	A,64		; Point to 2nd half of record
                                STIME1:	PUSH	AF		; Save pointer for T&D record
                                	PUSH	HL		; Save !!!TIME&.DAT file sector
                                	LD	HL,(NDIR0)	; Get DIR Alloc Bitmap
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-63


                                	LD	A,(NMASK)	; Get Block Mask
                                	INC	A		; +1 = Number of Records/Block
                                	LD	E,A		; Save Records/Block in E
                                	LD	D,B		; Extent, B is 0 from above
                                	LD	B,16		; Iterate 16 times
                                STIME2:	ADD	HL,HL		; Shift next DIR Alloc bit out to Carry
                                	JR	NC,STIME2A	; No Add if No Alloc Bit
                                	EX	(SP),HL		; Alloc to Stack, Records into HL
                                	ADD	HL,DE		; Add another Alloc worth of records
                                	EX	(SP),HL		; Records back to stack, Alloc to HL
                                STIME2A: DJNZ	STIME2		; Loop until all 16 bits done 
                                	POP	HL		; Restore !!!TIME&.DATE Record Number
                                
                                ; 2. Read T&D sector from disk.
                                
                                	CALL	STDIR2		; Set track and sector of T&D file
                                	CALL	READDR		; Read it to DIRBUF
                                
                                ; 3. Check T&D sector.
                                
                                	CALL	STIME6		; Check checksum
                                	CP	(HL)
                                	JR	NZ,TDERR	; Report error
                                
                                ; 4. Get stamp (GetStp) or set stamp in dirbuf, using offset (tdpnt)
                                
                                	POP	AF		; Get record pointer
                                	CALL	CALDIR1		; Get HL = pointer to stamp in DIRBUF
                                	POP	BC		; C = 0, 5, or 10 (offset)
                                	LD	A,(FUNCT)
                                	CP	102		; Get stamp?
                                	RET	Z		; Yes, just point with HL
                                	CP	103		; Set stamp from DMA?
                                	JR	Z,STIME4
                                
                                	ADD	HL,BC		; Add offset (0, 5, 10)
                                	PUSH	BC		; Save 0, 5, 10
                                	CALL	CMD98A		; Load 6 bytes from clock to HL
                                	POP	BC		; Restore entry parm.
                                	INC	A		; 0FFH --> 0 on clock error
                                	JR	Z,DOTDER	; ..jump to set NZ status on error
                                	LD	(HL),E		; Restore HL+5 (restore only if clock)
                                	LD	A,C		; Test entry parameter
                                	OR	A		; Set create stamp?
                                	JR	NZ,STIME5	; No, write to disk as is
                                
                                	LD	B,10		; Yes,
                                STIME3:	LD	(HL),A		; Zero the
                                	INC	HL		; Access and
                                	DJNZ	STIME3		; Modify dates
                                	JR	STIME5		; And write to disk
                                
                                STIME4:	LD	DE,(DMA)	; Setstp get time from DMA
                                	EX	DE,HL		; HL points to DMA
                                				; DE points to stamp in DIRBUF
                                	LD	BC,15		; Copy 15 bytes to DIRBUF
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-64


                                	LDIR
                                			;..fall	thru
                                
                                ; 5. Reset T&D checksum and write stamped sector to disk.
                                
                                STIME5:	CALL	STIME6		; Get checksum in A, (HL) = chk byte
                                	LD	(HL),A		; Update checksum
                                	CALL	WRITD1		; Write DIRBUF to !!!TIME&.DAT file
                                	XOR	A		; Set to (Z), no errors
                                	RET			; Stime done.
                                
                                ; Don't crash pgm on T&D Err, just return with err
                                
                                TDERR:	POP	HL
                                	POP	HL		; Clean up the stack
                                ;=	JR	GSEXIT		; ..and return error
                                	jr	dotder		; ..and return error
                                
                                ; ------------------------------------------------------------------
                                ; CMND102 - Return file's 15 byte stamp at DMA
                                ;  Entry: DE --> FCB of file (wildcards allowed)
                                ;  Exit : (DMA) holds 10 byte file stamp
                                ;	  A = 1 if Ok, Else A = 0FFH if File or Datestamp not found
                                ;		DMA contents undefined if error.
                                ;
                                ; CMND103 - Set file's 10 byte stamp from DMA
                                ;  Entry: DE --> FCB of file (wildcards allowed)
                                ;	  (DMA) holds 10 byte file stamp
                                ;  Exit : A = 1 if File DateStamp updated (Only first extent is valid)
                                ;	  A = 0FFH if File/Datestamp not found or "No stamp" attribute set
                                
                                CMD102:
                                CMD103:	CALL	SELDRV		; Select drive from FCB
                                	CALL	SRCT15		; Search file, test found
                                	JR	Z,DOTDER	; ..jump error exit if File Not Found
                                	LD	A,(FUNCT)	; Get or set?
                                	CP	103		; Set?
                                	JR	Z,SETSTP	; ..jump if yes
                                
                                	RES	7,(IX+3)	; Get. clear "no stamp"
                                	CALL	STIME		; Point to start of stamp
                                	JR	NZ,GSEXIT	; ..Exit w/Error if No Stamping allowed
                                	LD	BC,15		; Load 15 bytes
                                	CALL	MV2DMA		; Move data to DMA address 
                                	JR	GSEXIT
                                
                                SETSTP:	CALL	STIME		; Set from DMA
                                
                                GSEXIT:	JP	Z,READS0	; Jump to set "1" success status if Ok..
                                	JP	RETCFF		; ..else set 0FFH Error status
                                
                                ; --------
                                ;  Label for DS version <crw>
                                
                                CMD98A: EX	DE,HL		; Prepare for STIME call <crw>
                                
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-65


                                ; Get Time/Date to string whose address is supplied by the user
                                
                                CMD98:	LD	C,0		; Set parameter to get time/date
                                	DEFB	21H		; ..set for fall thru to GSTD
                                
                                ; Set Time/Date from User-supplied Buffer string
                                
                                CMD99:	LD	C,1		; Set parameter to Set Time/Date
                                
                                ; Clock interface.  Clock module must be ZDS DateStamper compatible
                                ;  Modified to ZDS DateStamper parameter passing
                                
                                GSTD:	LD	HL,(GSTIME)	; Get time/date get/set routine address
                                	PUSH	HL
                                DOTDER:	OR	0FFH		; set error return
                                	RET			; Vector to service routine
                                
                                ;.....
                                ; Subroutine to Check/Update the !!!TIME&.DAT checksum
                                
                                ;  Entry: DIRBUF points to T&D record
                                ;  Exit :  A holds checksum
                                ;	  HL points to checksum byte in record
                                
                                STIME6:	XOR	A		; Clear A
                                	LD	HL,(DIRBUF)
                                			;..fall thru to do CheckSum..
                                ;****************************************************************
                                ;* NOTE: This routine must fall thru to the CKS127 routine just *
                                ;*  after the ENDIF, so this sequence must not be altered       *
                                ;****************************************************************
                                
                                ;------------------ End time routines <crw> ------------------------
                                	  ENDIF
                                
                                ; Calculate checksum of 127 bytes addressed by HL.  Return with HL
                                ; pointing to the 128th byte.
                                
  EDE0    06 7F                 CKS127:	LD	B,127		; Test 1st 127 bytes
  EDE2    86                    CKSLP:	ADD	A,(HL)		; Sum all bytes to A
  EDE3    23                    	INC	HL
  EDE4    10 FC                 	DJNZ	CKSLP
  EDE6    C9                    	RET
                                
                                	PAGE
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	1-66


                                
                                ;**************************************************************
                                ;*	 Z S D O S     H i g h	   R A M     D a t a	      *
                                ;**************************************************************
                                
                                ; High RAM area.  These locations are not stored by an IOP or
                                ; BackGrounder.
                                
  EDE7                          CODEND:
                                	  IF  ROM
                                	    IF  $-ZSDOS GT 0E00H
                                	*** ZSDOS TOO BIG !!!!!	***
                                	    ENDIF		;$-zsdos
                                	DSEG
                                	  ELSE
                                	    IF  ZS
                                	      IF  $-ZSDOS GT 0DF1H
                                	*** ZSDOS TOO BIG !!!!! ***
                                	      ENDIF		;$-zsdos
                                ;	ORG	ZSDOS+0DF1H		; Set here for Internal Path
  EDE7                          	DEFS	ZSDOS+0DF1H-CODEND	; added psco
                                	    ELSE
                                	      IF  $-ZSDOS GT 0DF9H
                                	*** ZDDOS TOO BIG !!!!! ***
                                	      ENDIF		;$-zsdos
                                	ORG	ZSDOS+0DF9H
                                	    ENDIF		;Zs
                                	  ENDIF			;Rom
  EDF1                          HIRAM:
                                	  IF  ZS
  EDF1    01 00                 IPATH:	DEFB	1,0		; Internal Path = Drive A, User 0
  EDF3    0000 0000             	DEFW	00,00		; ..two more blank entries
  EDF7    00                    	DEFB	0		; ...and ending Null
  EDF8    0000                  TDFVCT:	DEFW	00		; Time and date file vector
                                	  ELSE
                                TDCHEK:	DEFB	0		; used by ZDDOS for T&D present flag
                                	  ENDIF		;Zs
  EDFA    0000                  LOGIN:	DEFW	00		; Login vector
  EDFC    0000                  DSKWP:	DEFW	00		; Disk write protect vector
  EDFE    0000                  HDLOG:	DEFW	00		; Fixed disk login vector
                                
                                	  IF  ROM
                                FREEMEM	EQU	BIOS-CODEND
                                	  ELSE
  000A                          FREEMEM	EQU	HIRAM-CODEND
                                	  ENDIF		;Rom
                                
                                ; Variables for use with BGii
                                
  0008                          BGLOWL	EQU	BGHIRAM-BGLORAM	   ; Size of Low RAM save
  006D                          BGHIL	EQU	BGRAMTOP-BGHIRAM   ; Size of Hi RAM save
                                
                                	END			; End program
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	S


Macros:

Symbols:
E03A 	ALV             E466 	ANDDEM          000B 	ARCATT          
E05D 	ARWORD          0E00 	BDOSLEN         E000 	BDOSPH          
E8D8 	BGCKDRO         E2B7 	BGCONST         006D 	BGHIL           
E02E 	BGHIRAM         E026 	BGLORAM         0008 	BGLOWL          
E27C 	BGPTCH0         EC08 	BGPTCH1         E7A9 	BGPTCH2         
E09B 	BGRAMTOP        E51F 	BGSELDRV        A400 	BIAS            
EE00 	BIOS            0C00 	BIOSLEN         EE00 	BIOSPH          
EE00 	BOOT            E6F7 	CALDI0          E6F1 	CALDIR          
E6F4 	CALDIR1         EB9A 	CALNE1          EB85 	CALNEX          
ED7F 	CALRRC          E6DF 	CALSC0          E6D7 	CALSEC          
E67A 	CALST           E680 	CALST0          E688 	CALST1          
E693 	CALST2          0800 	CCPLEN          D800 	CCPPH           
E75A 	CHKDIR          E776 	CHKDR1          E8CF 	CHKFR2          
E8C4 	CHKFR3          E8BF 	CHKFR4          E8AC 	CHKFRO          
E8D8 	CHKRO           E8E5 	CHKRO1          E6EE 	CKRODI          
EDE0 	CKS127          EDE2 	CKSLP           E452 	CKSUB           
E7AB 	CLOSE           E7C5 	CLOSE0          E7CE 	CLOSE1          
E7E5 	CLOSE3          E7FA 	CLOSE4          E808 	CLOSE6          
E4C2 	CMD100          E4BF 	CMD101          EDA4 	CMD102          
EDA4 	CMD103          E483 	CMD17A          E485 	CMD17B          
E488 	CMD17C          E4AB 	CMD19A          EDD7 	CMD98           
EDD4 	CMD99           E150 	CMND01          E15A 	CMND06          
E191 	CMND07          E18E 	CMND08          E2D5 	CMND09          
E195 	CMND10          E2B7 	CMND11          E4CF 	CMND12          
E40A 	CMND13          E57A 	CMND14          EAB4 	CMND15          
E7A8 	CMND16          E46E 	CMND17          E495 	CMND18          
E4A5 	CMND19          EBBE 	CMND20          EBFF 	CMND21          
EB02 	CMND22          E4B0 	CMND23          E4E8 	CMND24          
E4B8 	CMND25          E833 	CMND26          E4E4 	CMND27          
E703 	CMND28          E4DC 	CMND29          E4C7 	CMND30          
E4EC 	CMND31          E4FB 	CMND32          EBB4 	CMND33          
EBF4 	CMND34          E507 	CMND35          E50F 	CMND36          
E41A 	CMND37          E4E0 	CMND39          EBF4 	CMND40          
E4F7 	CMND45          E4F0 	CMND47          E4D8 	CMND48          
EDE7 	CODEND          E9C3 	COMCO1          E9CF 	COMCO2          
E9BD 	COMCOD          EE09 	CONIN           EE0C 	CONOUT          
EE06 	CONST           0003 	CONTC           0008 	CONTH           
0010 	CONTP           0012 	CONTR           0013 	CONTS           
0015 	CONTU           0018 	CONTX           0009 	CPMLEN          
000D 	CR              E2D2 	CROUT           EA02 	CSTAT           
EA0D 	CSTAT1          EA22 	CSTAT2          E038 	CSV             
E0E2 	CTABLE          FFFF 	CTLREN          E171 	DCIO1           
E166 	DCIO2           E058 	DCOPY           E02B 	DEFDRV          
E86D 	DELETE          E05F 	DEVAL           E034 	DIRBUF          
E02E 	DMA             E83D 	DMADIR          E841 	DMADR0          
E1BE 	DOBACK          E1C1 	DOBAK0          E1D2 	DOBAK1          
E1D7 	DOBAK2          E1DF 	DOBAK5          E3E6 	DOSEXIT         
E3F8 	DOSEXT0         EDDD 	DOTDER          EDC0 	DOTDR3          
003C 	DPBOF           E02C 	DRIVE           EDFC 	DSKWP           
E4BE 	DUMMY           E09B 	ENTRY           E0D2 	ENTRY0          
E0D6 	ENTRY1          E1FC 	ERALIN          E05C 	ERMODE          
E34C 	ERROR           E391 	ERROR0          E39A 	ERROR1          
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	S-1


E3AB 	ERROR2          E3AF 	ERROR3          E3C1 	ERROR4          
E3CA 	ERROR5          E3CF 	ERROR6          E3DD 	ERROR7          
0000 	FALSE           E02D 	FCB0            000C 	FCBEXT          
000E 	FCBMOD          000F 	FCBREC          000D 	FCBUSR          
E028 	FCONTP          E054 	FILCNT          E88B 	FILLB0          
E898 	FILLB1          E8A9 	FILLB2          E883 	FILLBB          
EA2B 	FILSZ           EA35 	FILSZ0          EA57 	FINDF           
EA67 	FINDF0          EA77 	FINDF1          EA88 	FINDF2          
EAA8 	FINDF3          E015 	FLAGS           E04E 	FLDRV           
006D 	FLGBITS         000A 	FREEMEM         E04B 	FUNCT           
E2CC 	GCONS2          E844 	GETBIT          E85B 	GETBT0          
E647 	GETCDM          E175 	GETCH           E6AA 	GETDM           
E6C0 	GETDM4          EBA6 	GETDME          E6D4 	GETDMX          
EC39 	GETFR0          EC48 	GETFR1          EC60 	GETFR2          
EC66 	GETFR3          E01E 	GETSTV          EDD9 	GSTD            
E016 	GSTIME          EDFE 	HDLOG           EDF1 	HIRAM           
E658 	HLORDE          EE18 	HOME            E620 	INITD2          
E5FC 	INITDR          EDF1 	IPATH           E036 	IXP             
E099 	IXSAVE          E92A 	JSEAR8          E805 	JSETDME         
E1B3 	JZRBX           E029 	LASTCH          ECF6 	LDFCB           
ED37 	LDFCB0          ED4A 	LDFCB1          ED6B 	LDFCB5          
ED6E 	LDFCB6          ED71 	LDFCB7          ED75 	LDFCB8          
E515 	LDRRC           000A 	LF              EE0F 	LIST            
EE2D 	LISTST          EDFA 	LOGIN           EB2D 	MAKE0           
EB09 	MAKES           0031 	MAXCMD          001F 	MAXEXT          
E041 	MAXLEN          003F 	MAXMOD          E03C 	MAXSEC          
E30A 	MBADSC          E327 	MBERR           E337 	MBFUNC          
E349 	MCRLF           E33D 	MDRIVE          E302 	MDSKCH          
E340 	MFILE           E31E 	MFILRO          E323 	MRO             
E315 	MSEL            003D 	MSIZ            0040 	MSIZE           
E48E 	MV2DMA          E03E 	NBLOCK          E047 	NCHECK          
E045 	NDIR0           0001 	NEEDZ80         E040 	NEXTND          
E043 	NFILES          E049 	NFTRK           0000 	NHDISKS         
E03F 	NMASK           E2ED 	NUM             E2EF 	NUM1            
E300 	NUM2            0020 	NXTREC          EB51 	OPENEX          
EAC2 	OPENF0          EAEF 	OPENF1          EB64 	OPENX0          
EB5F 	OPENX2          EB77 	OPENX3          EB7C 	OPENX4          
EB7F 	OPENX5          EB82 	OPENX6          EBE9 	OPNXCK          
0001 	PATCHOS         E011 	PATH            EDF1 	PATHAD          
E04C 	PEXIT           0000 	PICKEY          E2DF 	PRDEC           
0007 	PSFATT          0002 	PUBATT          EE12 	PUNCH           
E154 	PUTCH           E020 	PUTSTV          0000 	RAMLOW          
E19F 	RDBUF1          E1B6 	RDBUF2          E1F4 	RDBUF3          
E206 	RDBUF4          E22E 	RDBUF5          E239 	RDBUF6          
E24E 	RDBUFX          E730 	RDDIR           E74D 	RDDIR0          
E04F 	RDWR            EE27 	READ            EE15 	READER          
E795 	READR           EBC1 	READS           EBD1 	READS0          
EBD5 	READS1          EBD8 	READS2          E052 	RECDIR          
E435 	RELOG1          E446 	RELOG2          E9D7 	RENAM           
E9F0 	RENAM1          E9FA 	RENAM2          0000 	RESDSK          
E560 	RESUS1          E55E 	RESUSR          EB7A 	RETCFF          
E21D 	RETY1A          E21A 	RETYP1          E226 	RETYP2          
E22B 	RETYP3          0009 	ROATT           0000 	ROM             
007F 	RUBOUT          E4BB 	SAVEA           E4F3 	SAVHL           
E64A 	SDRVB           E654 	SDRVB0          E8EE 	SEAR12          
E8F1 	SEAR15          E92C 	SEARC1          E93A 	SEARC2          
"ZSDOS 1.1 - Enhanced CP/M BDOS Replacement"	MACRO-80 3.44	09-Dec-81	PAGE	S-2


E96B 	SEARC3          E978 	SEARC4          E97A 	SEARC5          
E980 	SEARC6          E986 	SEARC7          E98C 	SEARC7A         
E997 	SEARC8          E99D 	SEARC9          E8F3 	SEARCH          
E90A 	SEARCN          E05A 	SEAREX          E05B 	SEARNB          
E051 	SEARPU          E050 	SEARQU          E056 	SECPNT          
EE30 	SECTRN          E581 	SELDK           E58A 	SELDK0          
E594 	SELDK2          E571 	SELDK3          E5E6 	SELDK4          
E5F9 	SELDK5          E54E 	SELDR0          E52D 	SELDR1          
E51F 	SELDRV          EE1B 	SELDSK          ED7A 	SETB14          
E860 	SETBIT          E868 	SETBT0          EE24 	SETDMA          
EB9E 	SETDME          E6FC 	SETFCT          E714 	SETLF0          
EAAF 	SETPSF          EE21 	SETSEC          EE1E 	SETTRK          
E00F 	SFILRO          E65F 	SHRHL3          E661 	SHRHLB          
FFFF 	SLR             E061 	SPSAVE          E719 	SRCT15          
EDB9 	STAMPT          E006 	START           E009 	STBDSC          
E01A 	STCRV           E668 	STDIR           E677 	STDIR1          
E676 	STDIR2          E837 	STDMA           E018 	STLAV           
E00D 	STRO            E00B 	STSEL           E01C 	STUPDV          
E44D 	SUBEXT          E057 	SUBFLG          000A 	SYSATT          
0009 	TAB             E026 	TABCNT          E027 	TABCX1          
0091 	TDCKSM          EDF8 	TDFVCT          E032 	TEMP0           
E030 	TRANS           FFFF 	TRUE            E71C 	TSTFCT          
E723 	TSTLF           E024 	UNLOAD          E45D 	UNLOG           
FFFF 	UNROLL          E42A 	UNWPT1          FFFF 	UPATH           
E02A 	USER            EA05 	VCSTAT          E870 	VDEL            
E87E 	VDEL1           0001 	VERMAJ          0001 	VERMIN          
0011 	VERS            E9DA 	VRENAM          EE03 	WBOOT           
E013 	WHEEL           0000 	WHLADR          0008 	WHLATT          
E264 	WRCON           E268 	WRCON0          E277 	WRCON1          
E293 	WRCON2          E2AD 	WRCON3          E2B0 	WRCON4          
E253 	WRCTL           E817 	WRFCB           E829 	WRITD1          
EE2A 	WRITE           E79D 	WRITE0          E79A 	WRITER          
EC02 	WRITES          EC37 	WRITS1          EC7F 	WRITS2          
EC98 	WRITS3          ECA9 	WRITS4          ECC3 	WRITS5          
ECC5 	WRITS6          ECE4 	WRITS7          ECF1 	WRITS8          
EC1E 	WRITSA          EC21 	WRITSB          EC6D 	WRITSG          
EC8B 	WRITSX          0000 	ZAS             E4CF 	ZDPCH1          
E61D 	ZDPCH2          E637 	ZDPCH3          0000 	ZRL             
FFFF 	ZS              E000 	ZSDOS           FFFF 	ZSDOS11         
E09B 	ZSDOSS          



No Fatal error(s)


