                ;
                ; TEST PROGRAM TO INTERACT WITH THE CPM3 TYPE BIOS FOR THE S100COMPUTERS IDE INTREFACE BOARD
                ; JOHN MONAHAN SAN RAMON CA 94583.  
                ;==============================================================================
                ;
                ;	V1.7	3/1/2010	;REMOVED Z80 CODE (SO IT CAN BE TRANSLATED TO 8086 CODE LATER)
                ;	V2.0	1/23/2011	;UPDATED TO ACCOMIDATE TWO CF CARDS (MASTER/SLAVE) & BETTER MENU OPTIONS
                ;				;NOTE I STILL HAVE MORE WORK TO DO WITH THIS BUT WHAT IS HERE SEEM OK.
                ;	V2.1	2/5/2011	;MENU DRIVEN, AND ADDED CODE TO COPY & RESTORE DISK DATA FROM ANOTHER
                ;				;"BACKUP" PARTITION ON DISK
                ;	V2.2	2/13/2011	;ADDED SEC++ & SEC--
                ;	V2.3	2/15/2011	;RE-DID DRIVE INITILIZATION (PULSE CF CARDS TWICE ON RESET LINE)
                ;	V2.4	2/16/2011	;CORRECT SMALL ERROR FOR END OF DRIVE TRACK CHECK
                ;	V2.5	3/14/2011	;ADDED BOOT CPM OPTION, CLEANED UP SOME AREAS.
                ;	V2.6	3/15/2011	;RE-DIS RESET LINE PULSE. CORRECT CPM BOOT TO TRACK 0 SECTOR 1
                ;	V2.7	4/26/2011	;ADD CODE FOR TWO DRIVE SYSTEM	
                ;	V2.8	4/27/2011	;FORMAT SECTORS WITH E5'S AND WARN "FORMATTING CURRENT DRIVE".
                ;	V2.9	3/28/2011	;FIXED INITILIZATION HANGING IF NO DRIVE PRESENT IN DRIVE #0 OR #1 POSITIONS
                ;	V2.91	12/23/2017	;FIXED (DOUBLE SHIFTING) ERROR IN ZBITS
                ;	V3.00	5/31/2019	;MOVED STACK BEFORE BUFFERS, SO THAT V AND X COMMANDS WORK PROPERLY
                ;				;FIX ISSUE IN VERIFY:  ANA => ORA IN VERIFY$AB: AT NEXTV:
                ;				;FIX ISSUE IN RAM CLEAR:  ANA => ORA, AND CLEAR A EACH TIME
                ;				;CHANGED DRIVE SELECTION CODE INTO SUBROUTINES
                ;				;MOVED CALL TO CLEAR$ID$BUFFER INTO ROUTINE DRIVEID
                ;				;DISPLAY DRIVE LETTERS AS THEY ARE INITIALIZED
                ;				;DISPLAY PARAMETER INFO FOR BOTH DRIVES, IF PRESENT (ABORT IF NO DRIVE 0)
                ;				;MADE MAX SECTOR A STORED VARIABLE, AND TREATED AS MAX "CPM" SECTOR
                ;				;FIXED ISSUE IN READ NEXT SECTOR ("I")  WHERE CONDITION CODE NOT SET 
                ;				;FIXED ISSUE WHERE OPERATIONS STOPPED ONE TRACK SHORT (AFTER FE, RATHER THAN FF)
                ;				;FIXED ISSUE WHERE AN INVALID COMMAND CHAR. TOOK AN UNPREDICTABLE FLYING LEAP
                ;				;ADDED HOLE/NO HOLE MODE, AND DISPLAY MODE
                ;				;ADDED ABILITY TO SET THE MAXIMUM TRACK, AND DISPLAY CURRENT VALUE
                ;				;ADDED REPORT OF LBA SUPPORT IN DRIVEID INFO PRINTOUT
                ;				;ADDED CHECK FOR BUSY IN IDEINIT - CF CARDS WERE NOT GOING INTO LBA MODE
                ;				;CHANGED BOOTCPM TO WORK PROPERLY IN NO HOLE MODE.
                ;				;ADDED / MOVED CHECKS FOR IDEWAITNOTBUSY INTO WRLBA
                ;	V3.1	2/19/2021	;WHOLE DISK COPY 0FFH SECTORS/TRACK (0FFH TRACKS).  CAN SET SEC/TRACK DYNAMICALLY, SECT
                ;	V3.11	3/5/2021	;CORRECTED 1ST SECTOR MESSAGE (O CMD)			
                ;
                ;	OPEN ISSUES / TODO
                ;
                ;	THE PROGRAM DOES NOT WRITE INTO THE TOP 2 DIGITS OF THE DISPLAY.  IT PROBABLY SHOULD.
                ;	   THIS WOULD REQUIRE A ROUTINE SIMILAR TO IDEWR8D, BUT TO PUT THE DATA OUT ON PORT B.
                ;	THERE ARE QUITE A FEW REDUNDANT CALLS TO WRLBA, SOME OF WHICH COULD BE REMOVED
                ;	CONSIDER DOING THE MENU PRINT IN TWO (OR MORE) PARTS, REMOVING THE EXTRA COPY OF THE CONSTANT
                ;	   INFORMATION, AND INTEGRATING THE CURRENT HOLE/NOHOLE STATUS THERE
                ;	CONSIDER BETTER ERROR HANDLING
                ;	THE CALLS TO IDEWAITNOTBUSY IN READSECTOR/WRITESECTOR COULD BE REMOVED
                ;	THE CODE IN MOST PLACES THAT ADVANCES TO THE NEXT SECTOR/TRACK COULD BE "FACTORED" OUT INTO
                ;	   A SUBROUTINE, WITH A COUPLE OF EXCEPTIONS.
                ;
                
                
                ;PORTS FOR 8255 CHIP. CHANGE THESE TO SPECIFY WHERE YOUR 8255 IS ADDRESSED,
                ;THE FIRST THREE CONTROL WHICH 8255 PORTS HAVE THE CONTROL SIGNALS,
                ;UPPER AND LOWER DATA BYTES.  THE LAST ONE (IDEPORTCTRL), IS FOR MODE SETTING FOR THE
                ;8255 TO CONFIGURE ITS ACTUAL I/O PORTS (A,B & C).  
                ;
                ;NOTE MOST DRIVES THESE DAYS DONT USE THE OLD HEAD,TRACK, SECTOR TERMINOLOGY. INSTEAD
                ;WE USE "LOGICAL BLOCK ADDRESSING" OR LBA. THIS IS WHAT WE USE BELOW. LBA TREATS THE DRIVE
                ; AS ONE CONTINOUS SET OF SECTORS, 0,1,2,3,... 3124,....ETC.  HOWEVER AS SEEN BELOW WE NEED TO 
                ;CONVERT THIS LBA TO HEADS,TRACKS AND SECTORS TO BE COMPATIBLE WITH CPM & MSDOS.
                
                ;NOTE: IF YOU HAVE ONLY ONE DRIVE/CF CARD, BE SURE IT IS IN DRIVE #0 (LHS OF BOARD). THE IDE HARDWARE GE
                ;CONFUSED IF THERE IS ONLY A DRIVE IN SLOT #1.
                
                	; INCLUDE Z-80 MACRO LIBRARY:
                	MACLIB	Z80			;FOR THE Z80 DJNZ OPCODE
                
                
 0030 =         IDEPORTA	EQU	030H	;LOWER 8 BITS OF IDE INTERFACE (8255)
 0031 =         IDEPORTB	EQU	031H	;UPPER 8 BITS OF IDE INTERFACE
 0032 =         IDEPORTC	EQU	032H	;CONTROL LINES FOR IDE INTERFACE
 0033 =         IDEPORTCTRL	EQU	033H	;8255 CONFIGURATION PORT
 0034 =         IDEDRIVE	EQU	034H	;BIT 0 = 0 DRIVE A, =1 DRIVE B
                
 0092 =         READCFG8255	EQU	10010010B ;SET 8255 IDEPORTC TO OUTPUT, IDEPORTA/B INPUT
 0080 =         WRITECFG8255	EQU	10000000B ;SET ALL THREE 8255 PORTS TO OUTPUT MODE
                
                ;IDE CONTROL LINES FOR USE WITH IDEPORTC.  
                
 0001 =         IDEA0LINE	EQU	01H	;DIRECT FROM 8255 TO IDE INTERFACE
 0002 =         IDEA1LINE	EQU	02H	;DIRECT FROM 8255 TO IDE INTERFACE
 0004 =         IDEA2LINE	EQU	04H	;DIRECT FROM 8255 TO IDE INTERFACE
 0008 =         IDECS0LINE	EQU	08H	;INVERTER BETWEEN 8255 AND IDE INTERFACE
 0010 =         IDECS1LINE	EQU	10H	;INVERTER BETWEEN 8255 AND IDE INTERFACE
 0020 =         IDEWRLINE	EQU	20H	;INVERTER BETWEEN 8255 AND IDE INTERFACE
 0040 =         IDERDLINE	EQU	40H	;INVERTER BETWEEN 8255 AND IDE INTERFACE
 0080 =         IDERSTLINE	EQU	80H	;INVERTER BETWEEN 8255 AND IDE INTERFACE
                
                ;SYMBOLIC CONSTANTS FOR THE IDE DRIVE REGISTERS, WHICH MAKES THE
                ;CODE MORE READABLE THAN ALWAYS SPECIFYING THE ADDRESS BITS
                
 0008 =         REGDATA		EQU	IDECS0LINE
 0009 =         REGERR		EQU	IDECS0LINE + IDEA0LINE
 000A =         REGSECCNT	EQU	IDECS0LINE + IDEA1LINE
 000B =         REGSECTOR	EQU	IDECS0LINE + IDEA1LINE + IDEA0LINE
 000C =         REGCYLINDERLSB	EQU	IDECS0LINE + IDEA2LINE
 000D =         REGCYLINDERMSB	EQU	IDECS0LINE + IDEA2LINE + IDEA0LINE
 000E =         REGSHD		EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE		;(0EH)
 000F =         REGCOMMAND	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE	;(0FH)
 000F =         REGSTATUS	EQU	IDECS0LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
 0016 =         REGCONTROL	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE
 0017 =         REGASTATUS	EQU	IDECS1LINE + IDEA2LINE + IDEA1LINE + IDEA0LINE
                
                ;IDE COMMAND CONSTANTS.  THESE SHOULD NEVER CHANGE.
                
 0010 =         COMMANDRECAL	EQU	10H
 0020 =         COMMANDREAD	EQU	20H
 0030 =         COMMANDWRITE	EQU	30H
 0091 =         COMMANDINIT	EQU	91H
 00EC =         COMMANDID	EQU	0ECH
 00E0 =         COMMANDSPINDOWN	EQU	0E0H
 00E1 =         COMMANDSPINUP	EQU	0E1H
                
                
                ; IDE STATUS REGISTER:
                ;  BIT 7: BUSY	1=BUSY, 0=NOT BUSY
                ;  BIT 6: READY 1=READY FOR COMMAND, 0=NOT READY YET
                ;  BIT 5: DF	1=FAULT OCCURED INSIDE DRIVE
                ;  BIT 4: DSC	1=SEEK COMPLETE
                ;  BIT 3: DRQ	1=DATA REQUEST READY, 0=NOT READY TO XFER YET
                ;  BIT 2: CORR	1=CORRECTABLE ERROR OCCURED
                ;  BIT 1: IDX	VENDOR SPECIFIC
                ;  BIT 0: ERR	1=ERROR OCCURED
                
                
                				;EQUATES FOR DISPLAY ON PROPELLER CONSOLE IO BOARD (USED IN CPM DEBUGGING MODE ONLY)
 0001 =         SCROLL		EQU	01H	;SET SCROOL DIRECTION UP.
 000A =         LF		EQU	0AH
 000D =         CR		EQU	0DH
 0008 =         BS		EQU	08H	;BACK SPACE (REQUIRED FOR SECTOR DISPLAY)
 0007 =         BELL		EQU	07H
 0020 =         SPACE		EQU	20H
 0010 =         FAST		EQU	10H	;HIGH SPEED SCROOL
 0009 =         TAB		EQU	09H	;TAB ACROSS (8 SPACES FOR SD-BOARD)
 001B =         ESC		EQU	1BH
 001C =         CLEAR		EQU	1CH	;<<< PROPELLER VIDEO BOARD, CLEAR TO EOL. (USE 80 SPACES IF EOL NOT AVAILABLE
                
                				
 0200 =         SEC$SIZE	EQU	512	;ASSUME SECTOR SIZE AS 512. (NOT TESTED FOR OTHER SIZES)
 003D =         MAXSEC		EQU	3DH	;DEFAULT MAXIMUM "CPM" SECTOR NUMBER (61, 3DH SEC/TRACK)
                				;IN "HOLE" MODE, THE "CPM" SECTOR BECOMES THE LAST 8 BITS OF THE LBA
                				;THIS DEFAULT SETTING ALLOWS "CPM" SECTORS OF 0-3DH				
                
                				;IN "NO HOLE" MODE, THE "CPM" SECTOR BECOMES THE LAST 6 BITS OF THE LBA
                				;AND WE HAVE 3F SECTORS/TRACK.
                				;
                				;HISTORY:-
                				;SECTORS PER TRACK FOR CF CARD DRIVES SUCH AS THE KINGSTON CF 4G FOR CPM USE 0-3DH.
                				;THIS TRANSLATES TO LBA FORMAT OF 0 TO 3D SECTORS, FOR A TOTAL OF 61 SECTORS/TRACK.
                				;THIS CF CARD ACTULLY HAS 3F SECTORS/TRACK. I USE 3D FOR MY CPM3 SYSTEM BECAUSE
                				;MY ORIGIONAL SEAGATE IDE DRIVE HAS 3D SECTORS/TRACK. I DON'T WANT DIFFERENT CPM3.SYS 
                				;FILES AROUND SO THIS PROGRAM WOLD ALSO WORK WITH A SEAGATE 6531 IDE DRIVE (A ONCE COMMON HD). 
                				;THAT WAS BACK IN 2007.  UNFORTUNATELY THIS WAS A MISTAKE. IT COMPLICATES SOFTWARE. 
                				;A BETTER CHOICE WOULD BE 0FFH SEC/TRACK BUT THIS GIVES RISE TO A DIFFERENT CPM.SYS
                				;FILE SPREAD THROUGH MY DISKS SO I STILL USE 3DH. IF YOU ARE STARTING OFF USE 0FFH OR 3F SEC/TRACK. 
                
 0000 =         INIT$FIRST$SEC	EQU	0	;INITIAL FIRST SECTOR NUMBER ON EACH TRACK
                
 00FF =         MAXTRK		EQU	0FFH	;CPM3 ALLOWS UP TO 8MG SO 0-256 "TRACKS"
 4000 =         BUFFER$ORG	EQU	4000H	;<----- WILL PLACE ALL SECTOR DATA HERE
                
 000C =         CPM$BOOT$COUNT	EQU	12		;ALLOW UP TO 12 CPM SECTORS FOR CPMLDR
 4000 =         CPMLDR$ADDRESS	EQU	BUFFER$ORG	;WE CANNOT LOAD THE CPMLDR AT 100H IN RAM SINCE THIS IS WHERE THIS PROGRAM
                
 0001 =         RDCON		EQU	1	;FOR CP/M I/O
 0002 =         WRCON		EQU	2
 000D =         RESET$DISK	EQU	0DH	;RESET ALL CPM DISKS
 0009 =         PRINT		EQU	9
 000B =         CONST		EQU	11	;CONSOLE STAT
 0005 =         BDOS		EQU	5
                
 0000 =         FALSE	EQU	0
 FFFF =         TRUE	EQU	NOT FALSE
                
 FFFF =         CPM		EQU	TRUE	;TRUE IF OUTPUT VIA CPM, FALSE IF DIRECT TO HARDWARE
 FFFF =         DEBUG		EQU	TRUE
 FFFF =         CPM$TRANSLATE	EQU	TRUE	;TRANSLATE TRK,SEC,HEAD TO CPM TRACK# & SEC# ON DISPLAY
 0000 =         SIMM$TEST	EQU	FALSE	;TRUE IF JUST TESTING MENU DISPLAY ETC (ONLY) IN ALTAIR SIMM/MSDOS)
                
                
                
                ;--------------------------------------------------------------------------------------------
 0100           	ORG	100H		;<--- FOR CPM
                
                BEGIN:
 0100 318D21    	LXI	SP,STACK
 0103 11C40E    	LXI     D,SIGN$ON	;PRINT A WELCOME MESSAGE
 0106 CD0B0A    	CALL	PSTRING
 0109 3E3D      	MVI	A,MAXSEC	;INITIALIZE DEFAULT MAX SECTOR (ASSUMING HOLE MODE)
 010B 328B20    	STA	@MAX$SEC
 010E 3E00      	MVI	A,INIT$FIRST$SEC
 0110 328C20    	STA	@FIRST$SEC	;INITILIZE FIRST SECTOR ON EACH TRACK NUMBER
 0113 C34A01    	JMP	OVER$TBL
                	
                				;COMMAND BRANCH TABLE
 0116 6303      TBL:	DW  DRIVE$A   ; "A"  SELECT DRIVE A
 0118 6F03      	DW  DRIVE$B   ; "B"  SELECT DRIVE B
 011A 9303      	DW  CPMBOOT   ; "C"  LOAD CPM (IF PRESENT)
 011C 5303      	DW  DISPLAY   ; "D"  SECTOR CONTENTS DISPLAY:- ON/OFF
 011E 7B03      	DW  RAMCLEAR  ; "E"  CLEAR RAM BUFFER
 0120 E504      	DW  FORMAT    ; "F"  FORMAT CURRENT DISK
 0122 5206      	DW  RESTORE   ; "G"  RESTORE BACKUP
 0124 7005      	DW  BACKUP    ; "H"  BACKUP PARTITION
 0126 3407      	DW  ERROR     ; "I"  
 0128 3407      	DW  ERROR     ; "J"  
 012A 3407      	DW  ERROR     ; "K"  
 012C CE02      	DW  SET$LBA   ; "L"  SET LBA VALUE (SET "CPM" TRACK,SECTOR)  
 012E 1603      	DW  SET$MAXS  ; "M"  SET MAXIMUM SECTOR
 0130 E302      	DW  NEXT$SECT ; "N"  NEXT SECTOR
 0132 2803      	DW  FIRST$SET ; "O"  FIRST SECTOR# 0 0R 1
 0134 0203      	DW  PREV$SEC  ; "P"  PREVIOUS SECTOR
 0136 3407      	DW  ERROR     ; "Q"  
 0138 7402      	DW  READ$SEC  ; "R"  READ SECTOR TO DATA BUFFER
 013A 5D03      	DW  SEQ$RD    ; "S"  SEQUENTAL SEC READ AND DISPLAY CONTENTS
 013C 4D03      	DW  POWER$DOWN; "T"  POWER DOWN HARD DISK COMMAND
 013E 4703      	DW  POWER$UP  ; "U"  POWER UP HARD DISK COMMAND
 0140 1404      	DW  N$RD$SEC  ; "V"  READ N SECTORS
 0142 9F02      	DW  WRITE$SEC ; "W"  WRITE DATA BUFFER TO CURRENT SECTOR
 0144 7404      	DW  N$WR$SEC  ; "X"  WRITE N SECTORS
 0146 3D07      	DW  COPY$AB   ; "Y"  COPY DRIVE A TO DRIVE B
 0148 E707      	DW  VERIFY$AB ; "Z"  VERIFY DRIVE A:= DRIVE B:
                	
                OVER$TBL:
 014A CD6F0C    	CALL	SELECTA		;INITIALIZE THE BOARD AND FIRST DRIVE. IF THERE IS NO DRIVE ABORT
 014D CD080C    	CALL	IDEINIT
 0150 CA5C01    	JZ	DRIVE$1OK	;RET WITH NZ FLAG SET IF ERROR (PROBABLY NO DRIVE)
 0153 114D0F    	LXI	D,INIT$1$ERROR	
 0156 CD0B0A    	CALL	PSTRING
                IF NOT SIMM$TEST
 0159 C37A01    	JMP	ABORT
                ENDIF
                
                DRIVE$1OK:		
 015C CD760C    	CALL	SELECTB		;INITIALIZE THE SECOND DRIVE.  IF THERE IS NO DRIVE, CONTINUE
 015F CD080C    	CALL	IDEINIT
 0162 CA7201    	JZ	DRIVE$2OK	;SECOND DRIVE INITIALIZED OK
 0165 11850F    	LXI	D,INIT$2$ERROR	;WARN ABOUT SECOND DRIVE INITILIZATION FAILURE, BUT CONTINUE
 0168 CD0B0A    	CALL	PSTRING
 016B AF        	XRA	A
 016C 328A20    	STA	@DRIVEBPRESENT
 016F C38501    	JMP	INIT$OK
                DRIVE$2OK:
 0172 3E01      	MVI	A,1
 0174 328A20    	STA	@DRIVEBPRESENT
 0177 C38501    	JMP	INIT$OK		;AND CONTINUE
                
                ABORT:
 017A CD6F0C    	CALL	SELECTA		;MAKE SURE DRIVE A IS SELECTED.
                  IF	CPM
 017D 0E0D      	MVI	C,RESET$DISK	;RESET ALL DISKS IN CPM
 017F CD0500    	CALL	BDOS		
 0182 C30000    	JMP	0H		;JUMP TO CP/M COLD START ADDRESS
                  ELSE
                	JMP	0F000H		;ELSE JUMP TO MONITOR	
                  ENDIF
                 
                INIT$OK:	
 0185 CD6F0C    	CALL	SELECTA		
 0188 CDC708    	CALL	DRIVEID		;GET THE DRIVE ID INFO FOR DRIVE 0. IF THERE IS NO DRIVE, ABORT
 018B CA9701    	JZ	INIT$OK1	
 018E 11C40F    	LXI	D,ID$ERROR
 0191 CD0B0A    	CALL	PSTRING
                 IF	NOT SIMM$TEST
 0194 C37A01    	JMP	ABORT
                 ENDIF
                
                INIT$OK1:
 0197 CDE90D    	CALL	ID$PRINT	;PRINT THE DRIVE ID INFO FOR DRIVE 0.  IF INVALID, ABORT
 019A D2A301    	JNC	INIT$OK2
 019D 114010    	LXI	D,DRIVE0$IDMSG
 01A0 CD0B0A    	CALL	PSTRING
                INIT$OK2:
 01A3 CDCA09    	CALL	ZCRLF
 01A6 3A8A20    	LDA	@DRIVEBPRESENT	;WAS THERE A SECOND DRIVE?
 01A9 B7        	ORA	A
 01AA CACB01    	JZ	MAINLOOP	;NOPE
 01AD CD760C    	CALL	SELECTB		;YES - SELECT IT.
 01B0 CDC708    	CALL	DRIVEID		;GET THE DRIVE ID INFO FOR DRIVE 1.  CONTINUE EVEN IF NONE.
 01B3 CAC201    	JZ	INIT$OK3
 01B6 11C40F    	LXI	D,ID$ERROR
 01B9 CD0B0A    	CALL	PSTRING
 01BC CD6F0C    	CALL	SELECTA
 01BF C3CB01    	JMP	MAINLOOP
                INIT$OK3:
 01C2 CDE90D    	CALL	ID$PRINT	;PRINT THE DRIVE ID INFO FOR DRIVE 1.  CONTINUE EVEN IF INVALID.
 01C5 CD6F0C    	CALL	SELECTA
 01C8 C3CB01    	JMP	MAINLOOP
                
                
                ;-------------------------- MAIN LOOP ------------------------------------------------------------
                
                MAINLOOP:			;PRINT MAIN MENU
 01CB 3A8920    	LDA	@CURRENT$DRIVE	;FIRST SHOW CURRENT DRIVE
 01CE B7        	ORA	A
 01CF C2FE01    	JNZ	DRIVE$B$MENU
                	
 01D2 11FE10    	LXI	D,SIGNON$STRING
 01D5 CD0B0A    	CALL	PSTRING
 01D8 111B11    	LXI	D,DRIVE$A$MSG
 01DB CD0B0A    	CALL	PSTRING
 01DE 3A8B20    	LDA	@MAX$SEC	;GET THE MAX SECTORS/TRACK
 01E1 CDBF0A    	CALL	PHEX		;PRINT SECTORS/TRACK
 01E4 110B1C    	LXI	D,H$MSG		;TERMINATING 'H'
 01E7 CD0B0A    	CALL	PSTRING
 01EA 113A20    	LXI	D,FIRST$STRING
 01ED CD0B0A    	CALL	PSTRING
 01F0 3A8C20    	LDA	@FIRST$SEC	;GET FIRST SECTOR NUMBER
 01F3 CDBF0A    	CALL	PHEX
 01F6 0E29      	MVI	C,')'
 01F8 CDF009    	CALL	ZCO
 01FB C32702    	JMP	DISPLAYMENU
                DRIVE$B$MENU:
 01FE 11FE10    	LXI	D,SIGNON$STRING
 0201 CD0B0A    	CALL	PSTRING
 0204 113811    	LXI	D,DRIVE$B$MSG
 0207 CD0B0A    	CALL	PSTRING
 020A 3A8B20    	LDA	@MAX$SEC	;GET THE MAX SECTORS/TRACK
 020D CDBF0A    	CALL	PHEX		;PRINT SECTORS/TRACK
 0210 110B1C    	LXI	D,H$MSG		;TERMINATING 'H'
 0213 CD0B0A    	CALL	PSTRING
 0216 113A20    	LXI	D,FIRST$STRING
 0219 CD0B0A    	CALL	PSTRING
 021C 3A8C20    	LDA	@FIRST$SEC	;GET FIRST SECTOR NUMBER
 021F CDBF0A    	CALL	PHEX
 0222 0E29      	MVI	C,')'
 0224 CDF009    	CALL	ZCO
                
                DISPLAYMENU:
 0227 CDCA09    	CALL	ZCRLF
 022A 3A7320    	LDA	@DISPLAYFLAG	;DO WE HAVE DETAIL SECTOR DATA DISPLAY FLAG ON OR OFF
 022D B7        	ORA	A		;NZ = ON (INITIALLY 0FFH SO DETAILED SECTOR DISPLAY ON)
 022E C23A02    	JNZ     DISPLAY1
 0231 CDCA09    	CALL	ZCRLF
 0234 115511    	LXI     D,CMD$STRING1	;LIST COMMAND OPTIONS (TURN DISPLAY OPTION TO ON)
 0237 F24002    	JP	DISPLAY2
                DISPLAY1:
 023A CDCA09    	CALL	ZCRLF
 023D 117813    	LXI     D,CMD$STRING2	;LIST COMMAND OPTIONS (TURN DISPLAY OPTION TO OFF)
                DISPLAY2:
 0240 CD0B0A    	CALL	PSTRING
                	
 0243 CD000D    	CALL	WRLBA		     ;UPDATE LBA ON DRIVE
 0246 CD7609    	CALL	DISPLAYPOSITION	     ;DISPLAY CURRENT TRACK,SECTOR,HEAD#
                	
 0249 119B15    	LXI	D,PROMPT	;'>'
 024C CD0B0A    	CALL	PSTRING
                	
 024F CD590B    	CALL	GETCMD		;SIMPLE UC CHARACTER INPUT (NOTE, NO FANCY CHECKING)
 0252 FE1B      	CPI	ESC		;ABORT IF ESC
 0254 CA7A01    	JZ	ABORT
                
 0257 CD630B    	CALL	UPPER
 025A FE41      	CPI	'A'		;MUST BE >= 'A" (OTHERWISE IT JUMPS OFF TABLE)
 025C DA3407    	JC	ERROR
 025F FE5B      	CPI	'Z'+1		;MUST BE <= 'Z'
 0261 D23407    	JNC	ERROR
 0264 CDCA09    	CALL	ZCRLF
                	
 0267 DE40      	SBI	'@'		;ADJUST TO 0,1AH
                	
 0269 87        	ADD	A		;X2
 026A 211601    	LXI	H,TBL		;GET MENU SELECTION
 026D 85        	ADD	L
 026E 6F        	MOV	L,A
 026F 7E        	MOV	A,M
 0270 23        	INX	HL
 0271 66        	MOV	H,M
 0272 6F        	MOV	L,A		;JUMP TO TABLE POINTER
 0273 E9        	PCHL			;JMP (HL)
                	
                	
                	
                ;----------------------------- MENU OPTIONS ------------------------------------------------------	
                
                READ$SEC:			;READ SECTOR @ LBA TO THE RAM BUFFER
 0274 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 0277 226E20    	SHLD	@DMA
                
 027A CD7E0C    	CALL	READSECTOR
                
 027D CA8602    	JZ	MAIN1B		;Z MEANS THE SECTOR READ WAS OK
 0280 CDCA09    	CALL	ZCRLF
 0283 C3CB01    	JMP	MAINLOOP
 0286 11FB15    MAIN1B:	LXI     D, MSGRD	;SECTOR READ OK
 0289 CD0B0A    	CALL	PSTRING
                
 028C 3A7320    	LDA	@DISPLAYFLAG	;DO WE HAVE DETAIL SECTOR DATA DISPLAY FLAG ON OR OFF
 028F B7        	ORA	A		;NZ = ON 
 0290 CACB01    	JZ	MAINLOOP
 0293 210040    	LXI	H,BUFFER	;POINT TO BUFFER. SHOW SECTOR DATA FLAG IS ON
 0296 226E20    	SHLD	@DMA
 0299 CD740B    	CALL	HEXDUMP		;SHOW SECTOR DATA
 029C C3CB01    	JMP	MAINLOOP
                
                WRITE$SEC:			;WRITE DATA IN RAM BUFFER TO SECTOR @ LBA
 029F 11B515    	LXI     D,MSGSURE	;ARE YOU SURE?
 02A2 CD0B0A    	CALL	PSTRING
 02A5 CDFF09    	CALL	ZCI
 02A8 CD630B    	CALL	UPPER
 02AB FE59      	CPI	'Y'
 02AD C2CB02    	JNZ	MAIN2C
 02B0 CDCA09    	CALL	ZCRLF
                
 02B3 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 02B6 226E20    	SHLD	@DMA
                
 02B9 CDBB0C    	CALL	WRITESECTOR
                
 02BC CAC502    	JZ	MAIN2B		;Z MEANS THE SECTOR WRITE WAS OK
 02BF CDCA09    	CALL	ZCRLF
 02C2 C3CB01    	JMP	MAINLOOP
 02C5 110E16    MAIN2B:	LXI     D, MSGWR	;SECTOR WRITTEN OK
 02C8 CD0B0A    	CALL	PSTRING
 02CB C3CB01    MAIN2C: JMP	MAINLOOP
                
                
                SET$LBA:			;SET THE LOGICAL BLOCK ADDRESS
 02CE 112216    	LXI     D,GET$LBA	
 02D1 CD0B0A    	CALL	PSTRING
 02D4 CDF20A    	CALL	GHEX32LBA	;GET NEW CPM STYLE TRACK & SECTOR NUMBER AND PUT THEM IN RAM AT @SEC & @TRK 
 02D7 DADD02    	JC	MAIN3B		;RET C SET IF ABORT/ERROR
 02DA CD000D    	CALL	WRLBA		;UPDATE LBA ON DRIVE
 02DD CDCA09    MAIN3B:	CALL	ZCRLF
 02E0 C3CB01    	JMP	MAINLOOP
                
                NEXT$SECT:
 02E3 3A7420    	LDA	@SEC
 02E6 CDFE0B    	CALL	CHK$SEC		;COMPARE CURRENT TO MAX CPM SECTOR
 02E9 CAF902    	JZ	RANGE$ERROR	;IF EQUAL, WE ARE AT MAX ALREADY
 02EC 3C        	INR	A		;OTHERWISE, ON TO THE NEXT SECTOR
 02ED 327420    	STA	@SEC
 02F0 CD000D    	CALL	WRLBA		;UPDATE LBA ON DRIVE
 02F3 CDCA09    	CALL	ZCRLF
 02F6 C3CB01    	JMP	MAINLOOP
                RANGE$ERROR:
 02F9 11CA1C    	LXI     D,RANGE$MSG	
 02FC CD0B0A    	CALL	PSTRING
 02FF C3CB01    	JMP	MAINLOOP
                	
                PREV$SEC:
 0302 3A7420    	LDA	@SEC
 0305 B7        	ORA	A		;ALREADY AT 0?  CANNOT GO NEGATIVE.
 0306 CAF902    	JZ	RANGE$ERROR
 0309 3D        	DCR	A
 030A 327420    	STA	@SEC
 030D CD000D    	CALL	WRLBA		;UPDATE LBA ON DRIVE
 0310 CDCA09    	CALL	ZCRLF
 0313 C3CB01    	JMP	MAINLOOP
                
                SET$MAXS:
 0316 11961F    	LXI	D,GET$MAX$SEC$MSG  ;MESSAGE TO SET THE MAXIMUM SECTOR
 0319 CD0B0A    	CALL	PSTRING
 031C CD250B    	CALL	GETHEX		;GET THE MAX SECTOR	
 031F DA3407    	JC	ERROR
                ;	ANI	03FH		;SET LIMITS
 0322 328B20    	STA	@MAX$SEC	;SET THE MAX SECTORS/TRACK
 0325 C3CB01    	JMP	MAINLOOP
                
                FIRST$SET:
 0328 11BF1F    	LXI	D,GET$FIRST$SEC$MSG  ;MESSAGE TO GET THE FIRST SECTOR NUMBER
 032B CD0B0A    	CALL	PSTRING
 032E CD250B    	CALL	GETHEX		;GET THE MAX SECTOR	
 0331 DA3407    	JC	ERROR
 0334 FE01      	CPI	1		;ONLY 0 OR 1 ALLOWED
 0336 CA4103    	JZ	FIRST$SET1
 0339 FE00      	CPI	0
 033B CA4103    	JZ	FIRST$SET1
 033E CA3407    	JZ	ERROR
                FIRST$SET1:
 0341 328C20    	STA	@FIRST$SEC	;SET SECTOR NUMBER
 0344 C3CB01    	JMP	MAINLOOP
                	
                POWER$UP:			;SET THE DRIVE TO SPIN UP (FOR HARD DISK CONNECTIONS)
 0347 CDE408    	CALL	SPINUP
 034A C3CB01    	JMP	MAINLOOP
                
                POWER$DOWN:			;SET THE DRIVE TO SPIN DOWN (FOR HARD DISK CONNECTIONS)
 034D CDF308    	CALL	SPINDOWN
 0350 C3CB01    	JMP	MAINLOOP
                
                DISPLAY:			;DO WE HAVE DETAIL SECTOR DATA DISPLAY FLAG ON OR OFF
 0353 3A7320    	LDA	@DISPLAYFLAG	
 0356 2F        	CMA			;FLIP IT
 0357 327320    	STA	@DISPLAYFLAG
 035A C3CB01    	JMP	MAINLOOP	;UPDATE DISPLAY AND BACK TO NEXT MENU COMMAND
                
                SEQ$RD:				;DO SEQUENTIAL READS
 035D CDFE08    	CALL	SEQUENTIALREADS
 0360 C3CB01    	JMP	MAINLOOP
                
                DRIVE$A:
 0363 CD6F0C    	CALL	SELECTA		;SELECT DRIVE A
 0366 11CE1D    	LXI     D,SETA$MSG	
 0369 CD0B0A    	CALL	PSTRING
 036C C3CB01    	JMP	MAINLOOP
                
                DRIVE$B:
 036F CD760C    	CALL	SELECTB		;SELECT DRIVE B
 0372 11F51D    	LXI     D,SETB$MSG	
 0375 CD0B0A    	CALL	PSTRING
 0378 C3CB01    	JMP	MAINLOOP
                	
                
                RAMCLEAR:			;FILL RAN BUFFER WITH 0'S
 037B 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 037E 110002    	LXI	D,512
                CLEAR1:
 0381 AF        	XRA	A		;FILL AREA WITH 0'S
 0382 77        	MOV	M,A
 0383 23        	INX	H
 0384 1B        	DCX	D
 0385 7B        	MOV	A,E
 0386 B2        	ORA	D
 0387 C28103    	JNZ	CLEAR1
 038A 111B1E    	LXI     D,FILL$MSG	
 038D CD0B0A    	CALL	PSTRING
 0390 C3CB01    	JMP	MAINLOOP
                
                	
                CPMBOOT:			;BOOT CPM FROM IDE SYSTEM TRACKS -- IF PRESENT
 0393 AF        	XRA	A		;LOAD FROM TRACK 0,SEC 1, HEAD 0 (ALWAYS)
 0394 327720    	STA	@TRK+1
 0397 327620    	STA	@TRK
 039A 3E01      	MVI	A,1		;BOOT FROM TRACK 0, SEC 1
 039C 327420    	STA	@SEC
                
 039F 3E0C      	MVI	A,CPM$BOOT$COUNT ;COUNT OF CPMLDR SECTORS  (12)
 03A1 328620    	STA	@SECTOR$COUNT
 03A4 210040    	LXI	H,CPMLDR$ADDRESS ;DMA ADDRESS WHERE THE CPMLDR RESIDES IN RAM (100H)
 03A7 226E20    	SHLD	@DMA
                
                NEXTRCPM:
 03AA CD000D    	CALL	WRLBA		;UPDATE LBA ON DRIVE
 03AD CD7609    	CALL	DISPLAYPOSITION	;DISPLAY CURRENT TRACK,SECTOR,HEAD#
 03B0 CDCA09    	CALL	ZCRLF
                	
 03B3 2A6E20    	LHLD	@DMA
 03B6 CD7E0C    	CALL	READSECTOR	;READ A SECTOR
 03B9 226E20    	SHLD	@DMA
                
 03BC 3A8620    	LDA	@SECTOR$COUNT
 03BF 3D        	DCR	A
 03C0 328620    	STA	@SECTOR$COUNT
 03C3 CAD003    	JZ	LOAD$DONE
                
 03C6 2A7420    	LHLD	@SEC
 03C9 23        	INX	H
 03CA 227420    	SHLD	@SEC		;NOTE WE ASSUME WE ALWAY WILL STAY ON TARCK 0 IN THIS SPECIAL CASE
 03CD C3AA03    	JMP	NEXTRCPM
                
                LOAD$DONE:
 03D0 1E0F      	MVI	E,REGSTATUS	;CHECK THE R/W STATUS WHEN DONE
 03D2 CD8C0E    	CALL	IDERD8D
                	BIT	0,D
 03D5+CB42      	DB	0CBH,0*8+D+40H
 03D7 C20B04    	JNZ	CPMLOADERR	;Z IF NO ERRORS
 03DA 210040    	LXI	H,CPMLDR$ADDRESS
 03DD 7E        	MOV	A,M
 03DE FE31      	CPI	31H		;EXPECT TO HAVE 31H @80H IE. LD SP,80H
 03E0 C20204    	JNZ	CPMLOADERR1	;Z IF NO ERRORS
                	
 03E3 11471D    	LXI	D,MOVE$REQUEST	;ASK IF WE CAN MOVE DATA TO 100H OVERWRITING THIS PROGRAM
 03E6 CD0B0A    	CALL	PSTRING
 03E9 CDFF09    	CALL	ZCI
 03EC CD630B    	CALL	UPPER
 03EF FE59      	CPI	'Y'
 03F1 C2CB01    	JNZ	MAINLOOP
                	
 03F4 21B60E    	LXI	H,CPM$MOVE$CODE	;NEED TO PUT MEMORY MOVE CODE OUT OF THE WAY.
 03F7 110000    	LXI	D,0H
 03FA 010E00    	LXI	B,(CPM$MOVE$CODE$END-CPM$MOVE$CODE)
                	LDIR
 03FD+EDB0      	DB	0EDH,0B0H
 03FF C30000    	JMP	0H		;NOW JUMP HERE WHERE THE CODE WILL MOVE THE CPMLDR (@3000H) TO 100H
                	
                CPMLOADERR1:
 0402 11031D    	LXI	D,CPM$ERROR1	;DRIVE DATA ERROR
 0405 CD0B0A    	CALL	PSTRING
 0408 C3CB01    	JMP	MAINLOOP
                	
                CPMLOADERR:
 040B 11E91C    	LXI	D,CPM$ERROR	;DRIVE READ ERROR
 040E CD0B0A    	CALL	PSTRING
 0411 C3CB01    	JMP	MAINLOOP
                
                
                N$RD$SEC:			;READ N SECTORS >>>> NOTE NO CHECK IS MADE TO NOT OVERWRITE 
 0414 114219    	LXI	D,READN$MSG	;CPM ETC. IN HIGH RAM
 0417 CD0B0A    	CALL	PSTRING
 041A CD250B    	CALL	GETHEX
 041D DACB01    	JC	MAINLOOP	;ABORT IF ESC (C FLAG SET)
                	
 0420 328620    	STA	@SECTOR$COUNT	;STORE SECTOR COUNT
 0423 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 0426 226E20    	SHLD	@DMA
                
                NEXTRSEC:	
 0429 11091A    	LXI	D,READINGN$MSG
 042C CD0B0A    	CALL	PSTRING
 042F CD000D    	CALL	WRLBA		;UPDATE LBA ON DRIVE
 0432 CD7609    	CALL	DISPLAYPOSITION	;DISPLAY CURRENT TRACK,SECTOR,HEAD#
                	
 0435 2A6E20    	LHLD	@DMA
 0438 CD7E0C    	CALL	READSECTOR
 043B 226E20    	SHLD	@DMA
                
 043E 3A8620    	LDA	@SECTOR$COUNT
 0441 3D        	DCR	A
 0442 328620    	STA	@SECTOR$COUNT
 0445 CACB01    	JZ	MAINLOOP
                	
 0448 2A7420    	LHLD	@SEC
 044B 7D        	MOV	A,L
 044C CDFE0B    	CALL	CHK$SEC		;COMPARE A TO @MAX$SEC
 044F CA5904    	JZ	NEXTRZERO	;ALREADY AT MAX, RESET TO 0
 0452 23        	INX	H		;OTHERWISE, ON TO NEXT SECTOR
 0453 227420    	SHLD	@SEC	
 0456 C32904    	JMP	NEXTRSEC
                
                NEXTRZERO:
 0459 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 045C 227420    	SHLD	@SEC
 045F 2A7620    	LHLD	@TRK		;BUMP TO NEXT TRACK
 0462 23        	INX	H
 0463 227620    	SHLD	@TRK
 0466 7D        	MOV	A,L		;0-FFH TRACKS (ONLY)
 0467 B7        	ORA	A		;SET CONDITION CODE FOR A (LEAST 8 BITS OF TRACK)
 0468 C22904    	JNZ	NEXTRSEC
                	
 046B 11CA1B    	LXI	D,ATEND		;TELL US WE ARE AT END OF DISK
 046E CD0B0A    	CALL	PSTRING
 0471 C3CB01    	JMP	MAINLOOP
                
                
                N$WR$SEC:			;WRITE N SECTORS 
 0474 11B515    	LXI     D,MSGSURE	;ARE YOU SURE?
 0477 CD0B0A    	CALL	PSTRING
 047A CDFF09    	CALL	ZCI
 047D CD630B    	CALL	UPPER
 0480 FE59      	CPI	'Y'
 0482 C2CB02    	JNZ	MAIN2C
                
 0485 11A919    	LXI	D,WRITEN$MSG
 0488 CD0B0A    	CALL	PSTRING
 048B CD250B    	CALL	GETHEX
 048E DACB01    	JC	MAINLOOP	;ABORT IF ESC (C FLAG SET)
                
 0491 328620    	STA	@SECTOR$COUNT	;STORE SECTOR COUNT
 0494 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 0497 226E20    	SHLD	@DMA
                
                NEXTWSEC:	
 049A 11201A    	LXI	D,WRITINGN$MSG
 049D CD0B0A    	CALL	PSTRING
 04A0 CD000D    	CALL	WRLBA		;UPDATE LBA ON DRIVE
 04A3 CD7609    	CALL	DISPLAYPOSITION	;DISPLAY CURRENT TRACK,SECTOR,HEAD#
                	
 04A6 2A6E20    	LHLD	@DMA
 04A9 CDBB0C    	CALL	WRITESECTOR	;ACTULLY, SECTOR/TRACK VALUES ARE ALREADY UPDATED
 04AC 226E20    	SHLD	@DMA		;ABOVE IN WRLBA, BUT WRITESECTOR IS USED IN MULTIPLE PLACES.
                				;A REPEAT DOES NO HARM -- SPEED IS NOT AN ISSUE HERE
 04AF 3A8620    	LDA	@SECTOR$COUNT
 04B2 3D        	DCR	A
 04B3 328620    	STA	@SECTOR$COUNT
 04B6 CACB01    	JZ	MAINLOOP
                	
 04B9 2A7420    	LHLD	@SEC
 04BC 7D        	MOV	A,L
 04BD CDFE0B    	CALL	CHK$SEC		;COMPARE SECTOR TO @MAX$SEC
 04C0 CACA04    	JZ	NEXTWZERO	;ALREADY AT MAX SECTOR - RESET TO 0
 04C3 23        	INX	H
 04C4 227420    	SHLD	@SEC	
 04C7 C39A04    	JMP	NEXTWSEC
                
                NEXTWZERO:
 04CA 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 04CD 227420    	SHLD	@SEC
 04D0 2A7620    	LHLD	@TRK		;BUMP TO NEXT TRACK
 04D3 23        	INX	H
 04D4 227620    	SHLD	@TRK
 04D7 7D        	MOV	A,L		;0-FFH TRACKS (ONLY)
 04D8 B7        	ORA	A
 04D9 C29A04    	JNZ	NEXTWSEC
                	
 04DC 11CA1B    	LXI	D,ATEND		;TELL US WE ARE AT END OF DISK
 04DF CD0B0A    	CALL	PSTRING
 04E2 C3CB01    	JMP	MAINLOOP
                
                
                FORMAT:				;FORMAT (FILL SECTORS WITH E5'S FOR CPM DIRECTORY EMPTY)
 04E5 11FC18    	LXI	D,FORMAT$MSG
 04E8 CD0B0A    	CALL	PSTRING
 04EB 11B515    	LXI     D,MSGSURE	;ARE YOU SURE?
 04EE CD0B0A    	CALL	PSTRING
 04F1 CDFF09    	CALL	ZCI
 04F4 CD630B    	CALL	UPPER
 04F7 FE59      	CPI	'Y'
 04F9 C2CB01    	JNZ	MAINLOOP
 04FC 210040    	LXI	H,BUFFER	;FILL BUFFER WITH 0E5'S (512 OF THEM)
 04FF 0600      	MVI	B,0
 0501 3EE5      FILL0:	MVI	A,0E5H		;<-- SECTOR FILL CHARACTER (0E5'S FOR CPM)
 0503 77        	MOV	M,A
 0504 23        	INX	H
 0505 77        	MOV	M,A
 0506 23        	INX	H
                	DJNZ	FILL0
 0507+10        	DB	10H
 0508+F8        	DB	FILL0-$-1
 0509 CDCA09    	CALL	ZCRLF
                
                NEXT$FORMAT:
 050C 210040    	LXI	H,BUFFER
 050F 226E20    	SHLD	@DMA
 0512 CDBB0C    	CALL	WRITESECTOR	;WILL RETURN ERROR IF THERE WAS ONE
 0515 CA1E05    	JZ	MAIN9B		;Z MEANS THE SECTOR WRITE WAS OK
 0518 CDCA09    	CALL	ZCRLF
 051B C3CB01    	JMP	MAINLOOP
 051E CDD709    MAIN9B:	CALL	ZEOL		;CLEAR LINE CURSOR IS ON
 0521 CD7609    	CALL	DISPLAYPOSITION	;DISPLAY ACTUAL CURRENT TRACK,SECTOR,HEAD#
 0524 CDE209    	CALL	ZCSTS		;ANY KEYBOARD CHARACTER WILL STOP DISPLAY
 0527 FE01      	CPI	01H		;CPM SAYS SOMETHING THERE
 0529 C24005    	JNZ	WRNEXTSEC1
 052C CDFF09    	CALL	ZCI		;FLUSH CHARACTER
 052F 11CA18    	LXI	D,CONTINUE$MSG
 0532 CD0B0A    	CALL	PSTRING
 0535 CDFF09    	CALL	ZCI
 0538 FE1B      	CPI	ESC
 053A CACB01    	JZ	MAINLOOP
 053D CDCA09    	CALL	ZCRLF
                WRNEXTSEC1:
 0540 2A7420    	LHLD	@SEC
 0543 7D        	MOV	A,L		;CURRENT SECTOR TO A
 0544 CDFE0B    	CALL	CHK$SEC		;ARE WE ALREADY AT MAX SECTOR?
 0547 CA5105    	JZ	NEXTFORMATZERO	;YES - SET BACK TO 0
 054A 23        	INX	H		;NO - BUMP THE SECTOR
 054B 227420    	SHLD	@SEC		;0 TO MAXSEC CPM SECTORS
 054E C30C05    	JMP	NEXT$FORMAT
                
                NEXTFORMATZERO:
 0551 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 0554 227420    	SHLD	@SEC
 0557 2A7620    	LHLD	@TRK		;GET CURRENT TRACK
 055A 7D        	MOV	A,L		;CURRENT TRACK TO A
 055B FEFF      	CPI	MAXTRK		;IS IT ALREADY AT MAX?
 055D CA6705    	JZ	NEXTFORMATDONE	;YES - ALL DONE
 0560 23        	INX	H		;BUMP TO NEXT TRACK
 0561 227620    	SHLD	@TRK
 0564 C30C05    	JMP	NEXT$FORMAT
                
                NEXTFORMATDONE:
 0567 11621A    	LXI	D,FORMATDONE	;TELL US WE ARE ALL DONE.
 056A CD0B0A    	CALL	PSTRING
 056D C3CB01    	JMP	MAINLOOP
                
                				
                BACKUP:				;BACKUP THE CPM PARTITION TO ANOTHER AREA ON THE SAME CF-CARD/DISK
 0570 119E1A    	LXI	D,COPYMSG
 0573 CD0B0A    	CALL	PSTRING
 0576 CDFF09    	CALL	ZCI
 0579 CD630B    	CALL	UPPER
 057C FE59      	CPI	'Y'
 057E C2CB01    	JNZ	MAINLOOP
                	
 0581 210000    	LXI	H,0		;START WITH CPM SECTOR 0
 0584 227420    	SHLD	@SEC
 0587 227820    	SHLD	@SEC1
 058A 227C20    	SHLD	@SEC2		;AND ON SECOND PARTITION
 058D 227620    	SHLD	@TRK		;AND TRACK 0
 0590 227A20    	SHLD	@TRK1
 0593 210003    	LXI	H,MAXTRK+0200H+1 ;<<<<< VIP THIS ASSUMES CPM3 IS ON TRACKS 0-MAXTRK. (0-FFH) >>>>
 0596 227E20    	SHLD	@TRK2		 ;IT SKIPS AN AREA TO BE SAFE. HOWEVER IF YOU HAVE OTHER STUFF ON THIS 
                				 ;CF CARD AT THAT LOCATION (EG DOS PARTITION) CHANGE THIS VALUE
 0599 CDCA09    	CALL	ZCRLF
 059C CDCA09    	CALL	ZCRLF
                	
                NEXTCOPY1:	
 059F CDD709    	CALL	ZEOL		;CLEAR LINE CURSOR IS ON
 05A2 11E81B    	LXI	D,RBACKUP$MSG	;FOR EACH TRACK UPDATE DISPLAY
 05A5 CD0B0A    	CALL	PSTRING
 05A8 3A7B20    	LDA	@TRK1+1		;HIGH TRK BYTE
 05AB CDBF0A    	CALL	PHEX
 05AE 3A7A20    	LDA	@TRK1		;LOW TRK BYTE
 05B1 CDBF0A    	CALL	PHEX
 05B4 11F81B    	LXI	D,WBACKUP$MSG
 05B7 CD0B0A    	CALL	PSTRING
 05BA 3A7F20    	LDA	@TRK2+1		;HIGH TRK BYTE
 05BD CDBF0A    	CALL	PHEX
 05C0 3A7E20    	LDA	@TRK2		;LOW TRK BYTE
 05C3 CDBF0A    	CALL	PHEX
 05C6 110B1C    	LXI	D,H$MSG
 05C9 CD0B0A    	CALL	PSTRING
                
                NEXTCOPY:	
 05CC 3A7820    	LDA	@SEC1
 05CF 327420    	STA	@SEC
 05D2 2A7A20    	LHLD	@TRK1
 05D5 227620    	SHLD	@TRK
 05D8 CD000D    	CALL	WRLBA		;UPDATE LBA ON SOURCE AREA
                
 05DB 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 05DE 226E20    	SHLD	@DMA
 05E1 CD7E0C    	CALL	READSECTOR	;GET SECTOR DATA TO BUFFER
                	
 05E4 3A7C20    	LDA	@SEC2
 05E7 327420    	STA	@SEC
 05EA 2A7E20    	LHLD	@TRK2
 05ED 227620    	SHLD	@TRK
 05F0 CD000D    	CALL	WRLBA		;UPDATE LBA ON TARGET AREA
                	
 05F3 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 05F6 226E20    	SHLD	@DMA
 05F9 CDBB0C    	CALL	WRITESECTOR	;WRITE BUFFER DATA TO SECTOR
                	
 05FC CDE209    	CALL	ZCSTS		;ANY KEYBOARD CHARACTER WILL STOP DISPLAY
 05FF FE01      	CPI	01H		;CPM SAYS SOMETHING THERE
 0601 C21506    	JNZ	BKNEXTSEC1
 0604 CDFF09    	CALL	ZCI		;FLUSH CHARACTER
 0607 11CA18    	LXI	D,CONTINUE$MSG
 060A CD0B0A    	CALL	PSTRING
 060D CDFF09    	CALL	ZCI
 0610 FE1B      	CPI	ESC
 0612 CACB01    	JZ	MAINLOOP
                
                BKNEXTSEC1:
 0615 2A7420    	LHLD	@SEC
 0618 7D        	MOV	A,L		;SECTOR NUMBER IN A
 0619 CDFE0B    	CALL	CHK$SEC		;CHECK SECTOR IS NOT AT MAX
 061C CA2906    	JZ	BKNEXTZERO	;IT IS AT MAX ALREADY
 061F 23        	INX	H		;OTHERWISE, BUMP SECTOR
 0620 227820    	SHLD	@SEC1
 0623 227C20    	SHLD	@SEC2	
 0626 C3CC05    	JMP	NEXTCOPY
                
                BKNEXTZERO:
 0629 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 062C 227820    	SHLD	@SEC1
 062F 227C20    	SHLD	@SEC2
                	
 0632 2A7A20    	LHLD	@TRK1		;GET CURRENT TRACK
 0635 7D        	MOV	A,L		;INTO A
 0636 FEFF      	CPI	MAXTRK		;ALREADY AT MAX?
 0638 CA4906    	JZ	BKNEXTDONE	;IF SO, WE ARE DONE
 063B 23        	INX	H
 063C 227A20    	SHLD	@TRK1
                	
 063F 2A7E20    	LHLD	@TRK2		;BUMP TO NEXT TRACK
 0642 23        	INX	H
 0643 227E20    	SHLD	@TRK2
 0646 C39F05    	JMP	NEXTCOPY1
                	
                BKNEXTDONE:
 0649 117C1A    	LXI	D,BACKUPDONE	;TELL US WE ARE ALL DONE.
 064C CD0B0A    	CALL	PSTRING
 064F C3CB01    	JMP	MAINLOOP
                	
                
                
                RESTORE:			;RESTORE DISK FROM BACKUP PARTITION
 0652 110D1C    	LXI	D,RESTOREMSG
 0655 CD0B0A    	CALL	PSTRING
 0658 CDFF09    	CALL	ZCI
 065B CD630B    	CALL	UPPER
 065E FE59      	CPI	'Y'
 0660 C2CB01    	JNZ	MAINLOOP
                	
 0663 210000    	LXI	H,0		;START WITH CPM SECTOR 0
 0666 227420    	SHLD	@SEC
 0669 227820    	SHLD	@SEC1
 066C 227C20    	SHLD	@SEC2		;AND ON SECOND PARTITION
 066F 227620    	SHLD	@TRK		;AND TRACK 0
 0672 227A20    	SHLD	@TRK1
 0675 210003    	LXI	H,MAXTRK+0200H+1 ;<<<<< VIP THIS ASSUMES CPM3 IS ON TRACKS 0-MAXTRK. (0-FFH) >>>>
 0678 227E20    	SHLD	@TRK2		 ;IT SKIPS AN AREA TO BE SAFE. HOWEVER IF YOU HAVE OTHER STUFF ON THIS 
                				 ;CF CARD AT THAT LOCATION (EG DOS PARTITION) CHANGE THIS VALUE
 067B CDCA09    	CALL	ZCRLF
 067E CDCA09    	CALL	ZCRLF
                	
                NEXTRESTORE1:	
 0681 CDD709    	CALL	ZEOL		;CLEAR LINE CURSOR IS ON
 0684 11E81B    	LXI	D,RBACKUP$MSG	;FOR EACH TRACK UPDATE DISPLAY
 0687 CD0B0A    	CALL	PSTRING
 068A 3A7F20    	LDA	@TRK2+1		;HIGH TRK BYTE
 068D CDBF0A    	CALL	PHEX
 0690 3A7E20    	LDA	@TRK2		;LOW TRK BYTE
 0693 CDBF0A    	CALL	PHEX
 0696 11F81B    	LXI	D,WBACKUP$MSG
 0699 CD0B0A    	CALL	PSTRING
 069C 3A7B20    	LDA	@TRK1+1		;HIGH TRK BYTE
 069F CDBF0A    	CALL	PHEX
 06A2 3A7A20    	LDA	@TRK1		;LOW TRK BYTE
 06A5 CDBF0A    	CALL	PHEX
 06A8 110B1C    	LXI	D,H$MSG
 06AB CD0B0A    	CALL	PSTRING
                
                NEXTRESTORE:	
 06AE 3A7C20    	LDA	@SEC2		;POINT TO BACKUP PARTITION
 06B1 327420    	STA	@SEC
 06B4 2A7E20    	LHLD	@TRK2
 06B7 227620    	SHLD	@TRK
 06BA CD000D    	CALL	WRLBA		;UPDATE LBA ON SOURCE AREA
                
 06BD 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 06C0 226E20    	SHLD	@DMA
 06C3 CD7E0C    	CALL	READSECTOR	;GET SECTOR DATA TO BUFFER
                	
 06C6 3A7820    	LDA	@SEC1
 06C9 327420    	STA	@SEC
 06CC 2A7A20    	LHLD	@TRK1
 06CF 227620    	SHLD	@TRK
 06D2 CD000D    	CALL	WRLBA		;UPDATE LBA ON TARGET
                	
 06D5 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 06D8 226E20    	SHLD	@DMA
 06DB CDBB0C    	CALL	WRITESECTOR	;WRITE BUFFER DATA TO SECTOR
                	
 06DE CDE209    	CALL	ZCSTS		;ANY KEYBOARD CHARACTER WILL STOP DISPLAY
 06E1 FE01      	CPI	01H		;CPM SAYS SOMETHING THERE
 06E3 C2F706    	JNZ	RESNEXTSEC1
 06E6 CDFF09    	CALL	ZCI		;FLUSH CHARACTER
 06E9 11CA18    	LXI	D,CONTINUE$MSG
 06EC CD0B0A    	CALL	PSTRING
 06EF CDFF09    	CALL	ZCI
 06F2 FE1B      	CPI	ESC
 06F4 CACB01    	JZ	MAINLOOP
                
                RESNEXTSEC1:
 06F7 2A7420    	LHLD	@SEC
 06FA 7D        	MOV	A,L		;CURRENT SECTOR IN A
 06FB CDFE0B    	CALL	CHK$SEC		;IS SECTOR ALREADY AT MAX?
 06FE CA0B07    	JZ	RESNEXTZERO	;YES - GO TO SECTOR 0
 0701 23        	INX	H		;NO - BUMP TO NEXT SECTOR
 0702 227820    	SHLD	@SEC1
 0705 227C20    	SHLD	@SEC2	
 0708 C3AE06    	JMP	NEXTRESTORE
                
                RESNEXTZERO:
 070B 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 070E 227820    	SHLD	@SEC1
 0711 227C20    	SHLD	@SEC2
                	
 0714 2A7A20    	LHLD	@TRK1		;GET CURRENT TRACK
 0717 7D        	MOV	A,L		;INTO A
 0718 FEFF      	CPI	MAXTRK		;ARE WE ALREADY AT MAX?
 071A CA2B07    	JZ	RESNEXTDONE	;IF SO, WE ARE DONE
 071D 23        	INX	H		;BUMP TO NEXT TRACK
 071E 227A20    	SHLD	@TRK1
                	
 0721 2A7E20    	LHLD	@TRK2		;BUMP TO NEXT TRACK
 0724 23        	INX	H
 0725 227E20    	SHLD	@TRK2
                	
 0728 C38106    	JMP	NEXTRESTORE1
                
                RESNEXTDONE:	
 072B 11911C    	LXI	D,RESTOREDONE	;TELL US WE ARE ALL DONE.
 072E CD0B0A    	CALL	PSTRING
 0731 C3CB01    	JMP	MAINLOOP
                	
                
 0734 11371A    ERROR:	LXI     D, MSGERR	;CMD ERROR MSG
 0737 CD0B0A    	CALL	PSTRING
 073A C3CB01    	JMP	MAINLOOP
                 
                
                COPY$AB:			;<<<<<<<<< COPY DRIVE A: TO DRIVE B: >>>>>>>>>>>>
 073D 11421E    	LXI	D,DISKCOPYMSG	; NOTE THIS COPIES THE WHOLE DISK/CF CARD ACROSS
 0740 CD0B0A    	CALL	PSTRING		; NOT JUST A PARTITION
 0743 CDFF09    	CALL	ZCI
 0746 CD630B    	CALL	UPPER
 0749 FE59      	CPI	'Y'
 074B C2CB01    	JNZ	MAINLOOP
                	
 074E 210000    	LXI	H,0		;START WITH CPM SECTOR 0
 0751 227420    	SHLD	@SEC
 0754 227620    	SHLD	@TRK		;AND TRACK 0
                	
 0757 CDCA09    	CALL	ZCRLF
 075A CDCA09    	CALL	ZCRLF
                	
                NEXTDCOPY1:	
 075D CDD709    	CALL	ZEOL		;CLEAR LINE CURSOR IS ON
 0760 11F21E    	LXI	D,COPYTRK$MSG	;FOR EACH TRACK UPDATE DISPLAY
 0763 CD0B0A    	CALL	PSTRING
 0766 3A7720    	LDA	@TRK+1		;HIGH TRK BYTE
 0769 CDBF0A    	CALL	PHEX
 076C 3A7620    	LDA	@TRK		;LOW TRK BYTE
 076F CDBF0A    	CALL	PHEX
 0772 110B1C    	LXI	D,H$MSG
 0775 CD0B0A    	CALL	PSTRING
                
                NEXTDCOPY:	
 0778 CD6F0C    	CALL	SELECTA		;SELECT 1ST DRIVE
 077B CD000D    	CALL	WRLBA		;UPDATE LBA ON "A:" DRIVE
 077E 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 0781 226E20    	SHLD	@DMA
 0784 CD7E0C    	CALL	READSECTOR	;GET SECTOR DATA FROM A: DRIVE TO BUFFER
 0787 CD760C    	CALL	SELECTB		;SELECT SECOND DRIVE
 078A CD000D    	CALL	WRLBA		;UPDATE LBA ON "B:" DRIVE	
 078D 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 0790 226E20    	SHLD	@DMA
 0793 CDBB0C    	CALL	WRITESECTOR	;WRITE BUFFER DATA TO SECTOR ON B: DRIVE
                	
 0796 CDE209    	CALL	ZCSTS		;ANY KEYBOARD CHARACTER WILL STOP DISPLAY
 0799 FE01      	CPI	01H		;CPM SAYS SOMETHING THERE
 079B C2B507    	JNZ	BK$D$NEXTSEC1
 079E CDFF09    	CALL	ZCI		;FLUSH CHARACTER
 07A1 11CA18    	LXI	D,CONTINUE$MSG
 07A4 CD0B0A    	CALL	PSTRING
 07A7 CDFF09    	CALL	ZCI
 07AA FE1B      	CPI	ESC
 07AC C2B507    	JNZ	BK$D$NEXTSEC1
 07AF CD6F0C    	CALL	SELECTA		;SELECT 1ST DRIVE EVEN IF TERMINATING EARLY
 07B2 C3CB01    	JMP	MAINLOOP
                
                BK$D$NEXTSEC1:
 07B5 2A7420    	LHLD	@SEC
 07B8 7D        	MOV	A,L		;CURRENT SECTOR TO A
 07B9 FEFF      	CPI	0FFH		;ALLOW 0FFH SECTORS/TRACK
                ;	CALL	CHK$SEC		;ARE WE ALREADY AT MAX? - NOT USED IN V3.1 ONWARDS 
 07BB CAC507    	JZ	BK$D$NEXTZERO	;YES - SET SECTOR TO 0
 07BE 23        	INX	H		;NO - CONTINUE ON.
 07BF 227420    	SHLD	@SEC
 07C2 C37807    	JMP	NEXTDCOPY
                
                BK$D$NEXTZERO:
 07C5 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 07C8 227420    	SHLD	@SEC
                	
 07CB 2A7620    	LHLD	@TRK		;GET CURRENT TRACK
 07CE 7D        	MOV	A,L		;INTO A
 07CF FEFF      	CPI	MAXTRK		;ARE WE ALREADY AT MAX TRACK?
 07D1 CADB07    	JZ	BK$D$NEXTDONE	;YES - DONE
 07D4 23        	INX	H		;NO - BUMP TO NEXT TRACK
 07D5 227620    	SHLD	@TRK
                				;CHECK IF WE ARE DONE
 07D8 C35D07    	JMP	NEXTDCOPY1
                
                BK$D$NEXTDONE:	
 07DB 11C51E    	LXI	D,COPYDONE	;TELL US WE ARE ALL DONE.
 07DE CD0B0A    	CALL	PSTRING
 07E1 CD6F0C    	CALL	SELECTA		;SELECT 1ST DRIVE AT THE END
 07E4 C3CB01    	JMP	MAINLOOP
                	
                
                
                VERIFY$AB:			;VERIFY DRIVE A: = B:
 07E7 11021F    	LXI	D,DISKVERIFYMSG
 07EA CD0B0A    	CALL	PSTRING
                	
 07ED 210000    	LXI	H,0		;START WITH CPM SECTOR 0
 07F0 227420    	SHLD	@SEC
 07F3 227620    	SHLD	@TRK		;AND TRACK 0
                	
 07F6 CDCA09    	CALL	ZCRLF
 07F9 CDCA09    	CALL	ZCRLF
                	
                NEXTVCOPY1:	
 07FC CDD709    	CALL	ZEOL		;CLEAR LINE CURSOR IS ON
 07FF 11391F    	LXI	D,VERIFYTRK$MSG	;FOR EACH TRACK UPDATE DISPLAY
 0802 CD0B0A    	CALL	PSTRING
 0805 3A7720    	LDA	@TRK+1		;HIGH TRK BYTE
 0808 CDBF0A    	CALL	PHEX
 080B 3A7620    	LDA	@TRK		;LOW TRK BYTE
 080E CDBF0A    	CALL	PHEX
 0811 110B1C    	LXI	D,H$MSG
 0814 CD0B0A    	CALL	PSTRING
                
                NEXTVCOPY:	
 0817 CD6F0C    	CALL	SELECTA		;SELECT FIRST DRIVE
 081A CD000D    	CALL	WRLBA		;UPDATE LBA ON "A:" DRIVE
 081D 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 0820 226E20    	SHLD	@DMA
 0823 CD7E0C    	CALL	READSECTOR	;GET SECTOR DATA FROM BUFFER A: DRIVE
 0826 CD760C    	CALL	SELECTB		;SELECT 2ND DRIVE	
 0829 CD000D    	CALL	WRLBA		;UPDATE LBA ON "B:" DRIVE	
 082C 210142    	LXI	H,BUFFER2	;POINT TO BUFFER2
 082F 226E20    	SHLD	@DMA
 0832 CD7E0C    	CALL	READSECTOR	;READ BUFFER DATA FROM SECTOR OF B DRIVE
                	
 0835 010002    	LXI	BC,512		;NOW CHECK BOTH BUFFERS ARE IDENTICAL
 0838 210040    	LXI	H,BUFFER
 083B 110142    	LXI	D,BUFFER2
 083E 1A        NEXTV:	LDAX	D
 083F BE        	CMP	M		;IS [DE] = [HL]
 0840 C24E08    	JNZ	COMPARE$ERROR
 0843 23        	INX	H
 0844 13        	INX	D
 0845 0B        	DCX	B
 0846 79        	MOV	A,C
 0847 B0        	ORA	B
 0848 CA7508    	JZ	VERIFY$OK
 084B C33E08    	JMP	NEXTV
                
                COMPARE$ERROR:
 084E 11711F    	LXI	D,VERIFY$ERR	;INDICATE AN ERROR
 0851 CD0B0A    	CALL	PSTRING
 0854 3A7720    	LDA	@TRK+1		;HIGH TRK BYTE
 0857 CDBF0A    	CALL	PHEX
 085A 3A7620    	LDA	@TRK		;LOW TRK BYTE
 085D CDBF0A    	CALL	PHEX
 0860 118B1F    	LXI	D,SEC$MSG
 0863 CD0B0A    	CALL	PSTRING
 0866 3A7420    	LDA	@SEC		;SECTOR BYTE
 0869 CDBF0A    	CALL	PHEX
 086C 110B1C    	LXI	D,H$MSG
 086F CD0B0A    	CALL	PSTRING
 0872 C38008    	JMP	VER$OK1
                	
                VERIFY$OK:
 0875 CDE209    	CALL	ZCSTS		;ANY KEYBOARD CHARACTER WILL STOP DISPLAY
 0878 FE01      	CPI	01H		;CPM SAYS SOMETHING THERE
 087A C29408    	JNZ	BK$V$NEXTSEC1
 087D CDFF09    	CALL	ZCI		;FLUSH CHARACTER
                VER$OK1:
 0880 11CA18    	LXI	D,CONTINUE$MSG
 0883 CD0B0A    	CALL	PSTRING
 0886 CDFF09    	CALL	ZCI
 0889 FE1B      	CPI	ESC
 088B C29408    	JNZ	BK$V$NEXTSEC1
 088E CD6F0C    	CALL	SELECTA		;SELECT A EVEN IF TERMINATING EARLY.
 0891 C3CB01    	JMP	MAINLOOP
                
                BK$V$NEXTSEC1:
 0894 2A7420    	LHLD	@SEC
 0897 7D        	MOV	A,L		;CURRENT SECTOR TO A
 0898 CDFE0B    	CALL	CHK$SEC		;IS IT ALREADY AT MAX
 089B CAA508    	JZ	BK$V$NEXTZERO	;YUP - BACK TO SECTOR 0
 089E 23        	INX	H		;NO - BUMP TO NEXT SECTOR
 089F 227420    	SHLD	@SEC
 08A2 C31708    	JMP	NEXTVCOPY
                
                BK$V$NEXTZERO:
 08A5 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 08A8 227420    	SHLD	@SEC
                	
 08AB 2A7620    	LHLD	@TRK		;GET CURRENT TRACK
 08AE 7D        	MOV	A,L		;INTO A
 08AF FEFF      	CPI	0FFH		;ALLOW 0FFH SECTORS/TRACK
                ;	CALL	CHK$SEC		;ARE WE ALREADY AT MAX? - NOT USED IN V3.1 ONWARDS 
 08B1 CABB08    	JZ	BK$V$NEXTDONE	;YUP - ALL DONE
 08B4 23        	INX	H		;NO - BUMP TO NEXT TRACK
 08B5 227620    	SHLD	@TRK
 08B8 C3FC07    	JMP	NEXTVCOPY1
                
                BK$V$NEXTDONE:	
 08BB 114B1F    	LXI	D,VERIFYDONE	;TELL US WE ARE ALL DONE.
 08BE CD0B0A    	CALL	PSTRING
 08C1 CD6F0C    	CALL	SELECTA		;SELECT A WHEN DONE
 08C4 C3CB01    	JMP	MAINLOOP
                	
                
                ;---------------- SUPPORT ROUTINES -------------------------------------------
                				
 08C7 CD7C0D    DRIVEID:CALL	IDEWAITNOTBUSY	;DO THE IDENTIFY DRIVE COMMAND, AND RETURN WITH THE BUFFER
                				;FILLED WITH INFO ABOUT THE DRIVE
 08CA D8        	RC			;IF BUSY RETURN NZ
 08CB 16EC      	MVI	D,COMMANDID
 08CD 1E0F      	MVI	E,REGCOMMAND
 08CF CD9D0E    	CALL	IDEWR8D		;ISSUE THE COMMAND
                
 08D2 CDA20D    	CALL	IDEWAITDRQ	;WAIT FOR BUSY=0, DRQ=1
 08D5 DA100A    	JC	SHOWERRORS
 08D8 CDC80D    	CALL	CLEAR$ID$BUFFER	;CLEAR ID BUFFER
 08DB 0600      	MVI	B,0		;256 WORDS
 08DD 21AE21    	LXI     H,IDBUFFER	;STORE DATA HERE
 08E0 CD990C    	CALL	MORERD16	;GET 256 WORDS OF DATA FROM REGDATA PORT TO [HL]
 08E3 C9        	RET
                
                
                SPINUP:
 08E4 16E1      	MVI	D,COMMANDSPINUP
 08E6 1E0F      SPUP2:	MVI	E,REGCOMMAND
 08E8 CD9D0E    	CALL	IDEWR8D
 08EB CD7C0D    	CALL	IDEWAITNOTBUSY
 08EE DA100A    	JC	SHOWERRORS
 08F1 B7        	ORA	A		;CLEAR CARRY
 08F2 C9        	RET
                
                				
                SPINDOWN:			;TELL THE DRIVE TO SPIN DOWN
 08F3 CD7C0D    	CALL	IDEWAITNOTBUSY
 08F6 DA100A    	JC	SHOWERRORS
 08F9 16E0      	MVI	D,COMMANDSPINDOWN
 08FB C3E608    	JMP	SPUP2
                
                SEQUENTIALREADS:		
 08FE CD7C0D    	CALL	IDEWAITNOTBUSY	;SEQUENTIALLY READ SECTORS ONE AT A TIME FROM CURRENT POSITION
 0901 DA100A    	JC	SHOWERRORS
 0904 CDCA09    	CALL	ZCRLF
                NEXTSEC:
 0907 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 090A 226E20    	SHLD	@DMA
                
 090D CD7E0C    	CALL	READSECTOR	;IF THERE ARE ERRORS THEY WILL SHOW UP IN READSECTOR
 0910 CA1F09    	JZ	SEQOK
 0913 11CA18    	LXI	D,CONTINUE$MSG
 0916 CD0B0A    	CALL	PSTRING
 0919 CDFF09    	CALL	ZCI
 091C FE1B      	CPI	ESC		;ABORT IF ESC
 091E C8        	RZ
                	
 091F CDD709    SEQOK:	CALL	ZEOL		;CLEAR LINE CURSOR IS ON
 0922 CD7609    	CALL	DISPLAYPOSITION	;DISPLAY CURRENT TRACK,SECTOR,HEAD#
                
 0925 210040    	LXI	H,BUFFER	;POINT TO BUFFER
 0928 226E20    	SHLD	@DMA
                
 092B 3A7320    	LDA	@DISPLAYFLAG	;DO WE HAVE DETAIL SECTOR DATA DISPLAY FLAG ON OR OFF
 092E B7        	ORA	A		;NZ = ON 
 092F C4740B    	CNZ	HEXDUMP
 0932 CDCA09    	CALL	ZCRLF
 0935 CDCA09    	CALL	ZCRLF
 0938 CDCA09    	CALL	ZCRLF
                
 093B CDE209    	CALL	ZCSTS		;ANY KEYBOARD CHARACTER WILL STOP DISPLAY
 093E FE01      	CPI	01H		;CPM SAYS SOMETHING THERE
 0940 C25509    	JNZ	NEXTSEC1
 0943 CDFF09    	CALL	ZCI		;FLUSH CHARACTER
 0946 11CA18    	LXI	D,CONTINUE$MSG
 0949 CD0B0A    	CALL	PSTRING
 094C CDFF09    	CALL	ZCI
 094F FE1B      	CPI	ESC
 0951 C8        	RZ
 0952 CDCA09    	CALL	ZCRLF
                NEXTSEC1:
 0955 2A7420    	LHLD	@SEC
 0958 7D        	MOV	A,L		;CURRENT SECTOR TO A
 0959 CDFE0B    	CALL	CHK$SEC		;ARE WE ALREADY AT MAX SECTOR?
 095C CA6609    	JZ	NEXTSECZERO	;YES - BACK TO SECTOR 0
 095F 23        	INX	H		;NO - BUMP TO NEXT SECTOR
 0960 227420    	SHLD	@SEC	
 0963 C30709    	JMP	NEXTSEC
                
                NEXTSECZERO:
 0966 210000    	LXI	H,0		;BACK TO CPM SECTOR 0
 0969 227420    	SHLD	@SEC
 096C 2A7620    	LHLD	@TRK		;BUMP TO NEXT TRACK
 096F 23        	INX	H
 0970 227620    	SHLD	@TRK
 0973 C30709    	JMP	NEXTSEC		;NOTE WILL GO TO LAST TRACK ON DISK UNLESS STOPPED
                
                
                DISPLAYPOSITION:		;DISPLAY CURRENT TRACK,SECTOR & HEAD POSITION
 0976 11C010    	LXI     D,MSGCPMTRK	;DISPLAY IN LBA FORMAT
 0979 CD0B0A    	CALL	PSTRING		;---- CPM FORMAT ----
 097C 3A7720    	LDA	@TRK+1		;HIGH TRK BYTE
 097F CDBF0A    	CALL	PHEX
 0982 3A7620    	LDA	@TRK		;LOW TRK BYTE
 0985 CDBF0A    	CALL	PHEX
                		
 0988 11CB10    	LXI     D,MSGCPMSEC
 098B CD0B0A    	CALL	PSTRING		;SEC = (16 BITS)
 098E 3A7520    	LDA	@SEC+1		;HIGH SEC
 0991 CDBF0A    	CALL	PHEX
 0994 3A7420    	LDA	@SEC		;LOW SEC
 0997 CDBF0A    	CALL	PHEX
                				;---- LBA FORMAT ----
 099A 11D710    	LXI     D, MSGLBA
 099D CD0B0A    	CALL	PSTRING		;(LBA = 00 (<-- OLD "HEADS" = 0 FOR THESE DRIVES).
 09A0 3A7220    	LDA	@DRIVE$TRK+1	;HIGH "CYLINDER" BYTE
 09A3 CDBF0A    	CALL	PHEX
 09A6 3A7120    	LDA	@DRIVE$TRK	;LOW "CYLINDER" BYTE
 09A9 CDBF0A    	CALL	PHEX	
 09AC 3A7020    	LDA	@DRIVE$SEC
 09AF CDBF0A    	CALL	PHEX
 09B2 11E310    	LXI     D, MSGBRACKET	;)$
 09B5 CD0B0A    	CALL	PSTRING		
 09B8 C9        	RET
                
                
                PRINTNAME:			;SEND TEXT UP TO [B]	
 09B9 23        	INX	H		;TEXT IS LOW BYTE HIGH BYTE FORMAT
 09BA 4E        	MOV	C,M
 09BB CDF009    	CALL	ZCO	
 09BE 2B        	DCX	H
 09BF 4E        	MOV	C,M
 09C0 CDF009    	CALL	ZCO
 09C3 23        	INX	H
 09C4 23        	INX	H
 09C5 05        	DCR	B
 09C6 C2B909    	JNZ	PRINTNAME
 09C9 C9        	RET
                
                ZCRLF:
 09CA F5        	PUSH	PSW
 09CB 0E0D      	MVI	C,CR
 09CD CDF009    	CALL	ZCO
 09D0 0E0A      	MVI	C,LF
 09D2 CDF009    	CALL	ZCO
 09D5 F1        	POP	PSW
 09D6 C9        	RET
                
                ZEOL:				;CR AND CLEAR CURRENT LINE
 09D7 0E0D      	MVI	C,CR
 09D9 CDF009    	CALL	ZCO
 09DC 0E1C      	MVI	C,CLEAR		;NOTE HARDWARE DEPENDENT, (USE 80 SPACES IF NECESSARY)
 09DE CDF009    	CALL	ZCO
 09E1 C9        	RET
                
                ZCSTS:
                  IF  CPM
 09E2 C5        	PUSH	B
 09E3 D5        	PUSH	D
 09E4 E5        	PUSH	H
 09E5 0E0B      	MVI	C,CONST
 09E7 CD0500    	CALL	BDOS		;RETURNS WITH 1 IN [A] IF CHARACTER AT KEYBOARD
 09EA E1        	POP	H
 09EB D1        	POP	D
 09EC C1        	POP	B
 09ED FE01      	CPI	1
 09EF C9        	RET
                  ELSE	
                	IN	0H		;GET CHARACTER IN [A]
                	ANI	02H
                	RZ
                	MVI	A,01H
                	ORA	A
                	RET
                  ENDIF
                	
                 
                ZCO:				;WRITE CHARACTER THAT IS IN [C]
                  IF  CPM
 09F0 F5        	PUSH	PSW
 09F1 C5        	PUSH	B
 09F2 D5        	PUSH	D
 09F3 E5        	PUSH	H
 09F4 59        	MOV	E,C
 09F5 0E02      	MVI	C,WRCON
 09F7 CD0500    	CALL	BDOS
 09FA E1        	POP	H
 09FB D1        	POP	D
 09FC C1        	POP	B
 09FD F1        	POP	PSW
 09FE C9        	RET
                  ELSE	
                	PUSH	PSW	
                ZCO1:	IN   	0H		;SHOW CHARACTER
                	ANI	04H
                	JZ	ZCO1
                	MOV	A,C
                	OUT	1H
                	POP	PSW
                	RET
                  ENDIF
                
                ZCI:				;RETURN KEYBOARD CHARACTER IN [A]
                  IF CPM
 09FF C5        	PUSH	B
 0A00 D5        	PUSH	D
 0A01 E5        	PUSH	H
 0A02 0E01      	MVI	C,RDCON
 0A04 CD0500    	CALL	BDOS
 0A07 E1        	POP	H
 0A08 D1        	POP	D
 0A09 C1        	POP	B
 0A0A C9        	RET
                  ELSE
                ZCI1:	IN	0H		;GET CHARACTER IN [A]
                	ANI	02H
                	JZ	ZCI1
                	IN	01H
                	RET
                  ENDIF
                
                
                ;	PRINT A STRING IN [DE] UP TO '$'
                
                PSTRING:
                 IF CPM
 0A0B 0E09      	MVI	C,PRINT
 0A0D C30500    	JMP	BDOS		;PRINT MESSAGE, 
                 ELSE
                	PUSH	B
                	PUSH	D
                	PUSH	H
                	XCHG
                PSTRX:	MOV	A,M
                	CPI	'$'
                	JZ	DONEP
                	MOV	C,A
                	CALL	ZCO
                	INX	H
                	JMP	PSTRX
                DONEP:	POP	H
                	POP	D
                	POP	B
                	RET
                  ENDIF
                
                
                SHOWERRORS:
                   IF	NOT DEBUG
                	ORA	A		;SET NZ FLAG
                	STC			;SET CARRY FLAG
                	RET
                   ELSE
 0A10 CDCA09    	CALL	ZCRLF
 0A13 1E0F      	MVI	E,REGSTATUS	;GET STATUS IN STATUS REGISTER
 0A15 CD8C0E    	CALL	IDERD8D
 0A18 7A        	MOV	A,D
 0A19 E601      	ANI	1H
 0A1B C2520A    	JNZ	MOREERROR	;GO TO  REGERR REGISTER FOR MORE INFO
                				;ALL OK IF 01000000
 0A1E F5        	PUSH	PSW		;SAVE FOR RETURN BELOW
 0A1F E680      	ANI	80H
 0A21 CA2D0A    	JZ	NOT7
 0A24 112217    	LXI	D,DRIVE$BUSY	;DRIVE BUSY (BIT 7) STUCK HIGH.   STATUS = 
 0A27 CD0B0A    	CALL	PSTRING
 0A2A C3A80A    	JMP	DONEERR
 0A2D E640      NOT7:	ANI	40H
 0A2F C23B0A    	JNZ	NOT6
 0A32 114D17    	LXI	D,DRIVE$NOT$READY  ;DRIVE NOT READY (BIT 6) STUCK LOW.  STATUS = 
 0A35 CD0B0A    	CALL	PSTRING
 0A38 C3A80A    	JMP	DONEERR
 0A3B E620      NOT6:	ANI	20H
 0A3D C2490A    	JNZ	NOT5
 0A40 117717    	LXI	D,DRIVE$WR$FAULT  ;DRIVE WRITE FAULT.    STATUS =
 0A43 CD0B0A    	CALL	PSTRING
 0A46 C3A80A    	JMP	DONEERR
 0A49 119717    NOT5	LXI	D,UNKNOWN$ERROR
 0A4C CD0B0A    	CALL	PSTRING
 0A4F C3A80A    	JMP	DONEERR
                
                MOREERROR:			;GET HERE IF BIT 0 OF THE STATUS REGISTER INDICTED A PROBLEM
 0A52 1E09      	MVI	E,REGERR	;GET ERROR CODE IN REGERR
 0A54 CD8C0E    	CALL	IDERD8D
 0A57 7A        	MOV	A,D
 0A58 F5        	PUSH	PSW
                
 0A59 E610      	ANI	10H
 0A5B CA670A    	JZ	NOTE4
 0A5E 113A18    	LXI	D,SEC$NOT$FOUND
 0A61 CD0B0A    	CALL	PSTRING
 0A64 C3A80A    	JMP	DONEERR
                
 0A67 E680      NOTE4:	ANI	80H
 0A69 CA750A    	JZ	NOTE7
 0A6C 11C517    	LXI	D,BAD$BLOCK
 0A6F CD0B0A    	CALL	PSTRING
 0A72 C3A80A    	JMP	DONEERR
 0A75 E640      NOTE7:	ANI	40H
 0A77 CA830A    	JZ	NOTE6
 0A7A 11E917    	LXI	D,UNRECOVER$ERR
 0A7D CD0B0A    	CALL	PSTRING
 0A80 C3A80A    	JMP	DONEERR
 0A83 E604      NOTE6:	ANI	4H
 0A85 CA910A    	JZ	NOTE2
 0A88 115E18    	LXI	D,INVALID$CMD
 0A8B CD0B0A    	CALL	PSTRING
 0A8E C3A80A    	JMP	DONEERR
 0A91 E602      NOTE2:	ANI	2H
 0A93 CA9F0A    	JZ	NOTE1
 0A96 118118    	LXI	D,TRK0$ERR
 0A99 CD0B0A    	CALL	PSTRING
 0A9C C3A80A    	JMP	DONEERR
 0A9F 11A918    NOTE1:	LXI	D,UNKNOWN$ERROR1
 0AA2 CD0B0A    	CALL	PSTRING
 0AA5 C3A80A    	JMP	DONEERR
                
 0AA8 F1        DONEERR:POP	PSW
 0AA9 F5        	PUSH	PSW
 0AAA CDDD0A    	CALL	ZBITS
 0AAD CDCA09    	CALL	ZCRLF
 0AB0 F1        	POP	PSW
 0AB1 B7        	ORA	A		;SET Z FLAG
 0AB2 37        	STC			;SET CARRY FLAG
 0AB3 C9        	RET
                   ENDIF
                
                
                ;------------------------------------------------------------------
                ; PRINT A 16 BIT NUMBER IN RAM LOCATED @ [HL] 
                ; (NOTE SPECIAL LOW BYTE FIRST. USED ONLY FOR DRIVE ID)
                
                PRINTPARM:
 0AB4 23        	INX	H	;INDEX TO HIGH BYTE FIRST
 0AB5 7E        	MOV	A,M
 0AB6 CDBF0A    	CALL	PHEX
 0AB9 2B        	DCX	H	;NOW LOW BYTE
 0ABA 7E        	MOV	A,M
 0ABB CDBF0A    	CALL	PHEX
 0ABE C9        	RET
                
                
                ; PRINT AN 8 BIT NUMBER, LOCATED IN [A]
 0ABF F5        PHEX:	PUSH	PSW
 0AC0 C5        	PUSH	B
 0AC1 F5        	PUSH	PSW
 0AC2 0F        	RRC
 0AC3 0F        	RRC
 0AC4 0F        	RRC
 0AC5 0F        	RRC
 0AC6 CDD00A    	CALL	ZCONV
 0AC9 F1        	POP	PSW
 0ACA CDD00A    	CALL	ZCONV
 0ACD C1        	POP	B
 0ACE F1        	POP	PSW
 0ACF C9        	RET
                
 0AD0 E60F      ZCONV:	ANI	0FH		;HEX TO ASCII AND PRINT IT
 0AD2 C690      	ADI	90H
 0AD4 27        	DAA
 0AD5 CE40      	ACI	40H
 0AD7 27        	DAA
 0AD8 4F        	MOV	C,A
 0AD9 CDF009    	CALL	ZCO
 0ADC C9        	RET
                
                ;DISPLAY BIT PATTERN IN [A]
 0ADD F5        ZBITS:	PUSH	PSW
 0ADE C5        	PUSH	B
 0ADF D5        	PUSH	D
 0AE0 5F        	MOV	E,A		
 0AE1 0608      	MVI	B,8
 0AE3 CB23      BQ2:	DB	0CBH,23H	;Z80 OP CODE FOR SLA A,E
 0AE5 3E18      	MVI	A,18H
 0AE7 8F        	ADC	A
 0AE8 4F        	MOV	C,A
 0AE9 CDF009    	CALL	ZCO
                	DJNZ	BQ2
 0AEC+10        	DB	10H
 0AED+F5        	DB	BQ2-$-1
 0AEE D1        	POP	D
 0AEF C1        	POP	B
 0AF0 F1        	POP	PSW
 0AF1 C9        	RET
                
                GHEX32LBA:			;GET CPM STYLE TRACK# & SECTOR# DATA AND CONVERT TO LBA FORMAT
 0AF2 118E16    	LXI     D,ENTER$SECL	;ENTER SECTOR NUMBER
 0AF5 CD0B0A    	CALL	PSTRING
 0AF8 CD250B    	CALL	GETHEX		;GET 2 HEX DIGITS
 0AFB D8        	RC
 0AFC 327420    	STA	@SEC		;NOTE: NO CHECK DATA IS < MAXSEC, SECTORS START 0,1,2,3....
 0AFF CDCA09    	CALL	ZCRLF
                
 0B02 11CE16    	LXI	D,ENTER$TRKH	;ENTER HIGH BYTE TRACK NUMBER
 0B05 CD0B0A    	CALL	PSTRING
 0B08 CD250B    	CALL	GETHEX		;GET 2 HEX DIGITS
 0B0B D8        	RC
 0B0C 327720    	STA	@TRK+1
 0B0F CDCA09    	CALL	ZCRLF
                
 0B12 11AE16    	LXI     D,ENTER$TRKL	;ENTER LOW BYTE TRACK NUMBER
 0B15 CD0B0A    	CALL	PSTRING
 0B18 CD250B    	CALL	GETHEX		;GET 2 MORE HEX DIGITS
 0B1B D8        	RC
 0B1C 327620    	STA	@TRK
 0B1F CDCA09    	CALL	ZCRLF
 0B22 AF        	XRA	A
 0B23 B7        	ORA	A		;TO RETURN NC
 0B24 C9        	RET
                
                
                GETHEX:
 0B25 CD590B    	CALL	GETCMD		;GET A CHARACTER FROM KEYBOARD & ECHO
 0B28 FE1B      	CPI	ESC
 0B2A CA570B    	JZ	HEXABORT
 0B2D FE2F      	CPI	'/'		;CHECK 0-9, A-F
 0B2F DA570B    	JC	HEXABORT
 0B32 FE47      	CPI	'F'+1
 0B34 D2570B    	JNC	HEXABORT
 0B37 CD6C0B    	CALL	ASBIN		;CONVERT TO BINARY
 0B3A 07        	RLC			;SHIFT TO HIGH NIBBLE
 0B3B 07        	RLC
 0B3C 07        	RLC
 0B3D 07        	RLC
 0B3E 47        	MOV	B,A		;STORE IT
 0B3F CD590B    	CALL	GETCMD		;GET 2ND CHARACTER FROM KEYBOARD & ECHO
 0B42 FE1B      	CPI	ESC
 0B44 CA570B    	JZ	HEXABORT
 0B47 FE2F      	CPI	'/'		;CHECK 0-9, A-F
 0B49 DA570B    	JC	HEXABORT
 0B4C FE47      	CPI	'F'+1
 0B4E D2570B    	JNC	HEXABORT
 0B51 CD6C0B    	CALL	ASBIN		;CONVERT TO BINARY
 0B54 B0        	ORA	B		;ADD IN THE FIRST DIGIT
 0B55 B7        	ORA	A		;TO RETURN NC
 0B56 C9        	RET
                HEXABORT:
 0B57 37        	STC			;SET CARRY FLAG 
 0B58 C9        	RET
                
                
 0B59 CDFF09    GETCMD:	CALL	ZCI		;GET A CHARACTER, CONVERT TO UC, ECHO IT
 0B5C CD630B    	CALL	UPPER
 0B5F FE1B      	CPI	ESC
 0B61 C8        	RZ			;DON'T ECHO AN ESC
                  IF NOT CPM
                	PUSH	PSW		;SAVE IT
                	PUSH	B
                 	MOV	C,A
                	CALL	ZCO		;ECHO IT
                	POP	B
                	POP	PSW		;GET IT BACK
                 ENDIF
 0B62 C9        	RET
                
                				;CONVERT LC TO UC
 0B63 FE61      UPPER:	CPI	'a'		;MUST BE >= LOWERCASE A
 0B65 D8        	RC			; ELSE GO BACK...
 0B66 FE7B      	CPI	'z'+1		;MUST BE <= LOWERCASE Z
 0B68 D0        	RNC			; ELSE GO BACK...
 0B69 D620      	SUI	'a'-'A'		;SUBTRACT LOWERCASE BIAS
 0B6B C9        	RET
                
                				;ASCII TO BINARY CONVERSION ROUTINE
 0B6C D630      ASBIN:	SUI	30H 
 0B6E FE0A      	CPI	0AH 
 0B70 F8        	RM
 0B71 D607      	SUI	07H 
 0B73 C9        	RET
                
                
                HEXDUMP:			;PRINT A HEXDUMP OF THE DATA IN THE 512 BYTE BUFFER @[HL]
 0B74 F5        	PUSH	PSW		;SAVE EVERYTHING
 0B75 C5        	PUSH	B
 0B76 D5        	PUSH	D			 
 0B77 E5        	PUSH	H
                	
 0B78 CDCA09    	CALL	ZCRLF		;CR/LF FIRST
 0B7B 1620      	MVI	D,32		;PRINT 32 LINES TOTAL
 0B7D 0610      	MVI	B,16		;16 CHARACTERS ACROSS
 0B7F 228020    	SHLD	@STARTLINEHEX	;SAVE THE BUFFER LOCATION FOR ASCII DISPLAY BELOW
 0B82 210000    	LXI	H,0
 0B85 228420    	SHLD	@BYTE$COUNT
                	
 0B88 CDCA09    SF172:	CALL	ZCRLF
 0B8B 2A8420    	LHLD	@BYTE$COUNT
 0B8E 7C        	MOV	A,H
 0B8F CDBF0A    	CALL	PHEX		;PRINT BYTE COUNT IN SECTOR
 0B92 7D        	MOV	A,L
 0B93 CDBF0A    	CALL	PHEX		
 0B96 D5        	PUSH	D
 0B97 111000    	LXI	D,16
 0B9A 19        	DAD	D
 0B9B D1        	POP	D
 0B9C 228420    	SHLD	@BYTE$COUNT	;STORE FOR NEXT TIME
 0B9F CDE70B    	CALL	BLANK
 0BA2 2A8020    	LHLD	@STARTLINEHEX
 0BA5 228220    	SHLD	@STARTLINEASCII	;STORE FOR ASCII DISPLAY BELOW
 0BA8 7E        SF175:	MOV	A,M
 0BA9 CDF10B    	CALL	LBYTE		;DISPLAY [A] ON CRT/LCD
 0BAC 23        	INX	H
                	DJNZ	SF175
 0BAD+10        	DB	10H
 0BAE+F9        	DB	SF175-$-1
 0BAF 228020    	SHLD	@STARTLINEHEX	;SAVE FOR NEXT LINE LATER
 0BB2 CDC30B    	CALL	SHOWASCII	;NOW TRANSLATE TO ASCII AND DISPLAY
 0BB5 0610      	MVI	B,16		;16 CHARACTERS ACROSS FOR NEXT LINE
 0BB7 15        	DCR	D
 0BB8 C2880B    	JNZ	SF172		;HAVE WE DONE ALL 32 LINES
                ;
 0BBB CDCA09    	CALL	ZCRLF
 0BBE E1        	POP   H			;GET BACK ORIGIONAL REGISTERS
 0BBF D1        	POP   D
 0BC0 C1        	POP   B
 0BC1 F1        	POP   PSW
 0BC2 C9        	RET
                	
                SHOWASCII:			;NOW SHOW AS ASCII INFO
 0BC3 2A8220    	LHLD	@STARTLINEASCII
 0BC6 0610      	MVI	B,16		;16 ASCII CHARACTERS ACROSS
 0BC8 CDE70B    XF172:	CALL	BLANK		;SEND A SPACE CHARACTER
 0BCB CDE70B    	CALL	BLANK
 0BCE 7E        XF175:	MOV	A,M
 0BCF E67F      	ANI	7FH
 0BD1 FE20      	CPI	' ' 		;FILTER OUT CONTROL CHARACTERS
 0BD3 D2D80B    	JNC	XT33
 0BD6 3E2E      XT22:	MVI	A,'.'
 0BD8 FE7C      XT33:	CPI	07CH
 0BDA D2D60B    	JNC	XT22
 0BDD 4F        	MOV	C,A		;SET UP TO SEND
 0BDE C5        	PUSH	B
 0BDF CDF009    	CALL	ZCO
 0BE2 C1        	POP	B
 0BE3 23        	INX	H		;NEXT POSITION IN BUFFER
                	DJNZ	XF175
 0BE4+10        	DB	10H
 0BE5+E8        	DB	XF175-$-1
 0BE6 C9        	RET
                ;
 0BE7 C5        BLANK:	PUSH	B
 0BE8 E5        	PUSH	H
 0BE9 0E20      	MVI	C,' '
 0BEB CDF009    	CALL	ZCO
 0BEE E1        	POP	H
 0BEF C1        	POP	B
 0BF0 C9        	RET
                ;
 0BF1 F5        LBYTE:	PUSH	PSW
 0BF2 0F        	RRC
 0BF3 0F        	RRC
 0BF4 0F        	RRC
 0BF5 0F        	RRC
 0BF6 CDFA0B    	CALL	SF598
 0BF9 F1        	POP	PSW
 0BFA CDD00A    SF598:	CALL	ZCONV
 0BFD C9        	RET
                
                CHK$SEC:			;COMPARE CURRENT "CPM" SECTOR TO MAX "CPM" SECTOR
 0BFE C5        	PUSH	B		;SAVE
 0BFF 4F        	MOV	C,A		;C <- CURRENT SECTOR
 0C00 3A8B20    	LDA	@MAX$SEC	;RETRIEVE MAX SECTOR NUMBER
 0C03 47        	MOV	B,A		;B <- MAX SECTOR NUMBER
 0C04 79        	MOV	A,C		;GET CURRENT SECTOR BACK IN A FOR COMPARE (AND RETURN WITH IT IN A)
 0C05 B8        	CMP	B		;CURRENT : MAX
 0C06 C1        	POP	B
 0C07 C9        	RET			;RETURN WITH COMPARE STATUS. (CARRY => MAX > CURRENT)
                ;
                ;
                ;================================================================================================
                ;
                ;      IDE DRIVE BIOS ROUTINES WRITTEN IN A FORMAT THAT CAN BE USED DIRECTLY WITH CPM3 
                ;
                ;================================================================================================
                ;
                IDEINIT:
 0C08 C5        	PUSH	B		;SAVE USED REGISTERS
 0C09 D5        	PUSH	D
                				;INITIALZE THE 8255 AND DRIVE THEN DO A HARD RESET ON THE DRIVE, 
 0C0A 3E92      	MVI	A,READCFG8255	;CONFIG 8255 CHIP (10010010B), READ MODE ON RETURN
 0C0C D333      	OUT	IDEPORTCTRL	;CONFIG 8255 CHIP, READ MODE
                				
                				;HARD RESET THE DISK DRIVE 
                				;FOR SOME REASON SOME CF CARDS NEED TO THE RESET LINE 
                				;PULSED VERY CAREFULLY. YOU MAY NEED TO PLAY AROUND   
 0C0E 3E80      	MVI	A,IDERSTLINE	;WITH THE PULSE LENGTH. SYMPTOMS ARE: INCORRECT DATA COMMING
 0C10 D332      	OUT	IDEPORTC	;BACK FROM A SECTOR READ (OFTEN DUE TO THE WRONG SECTOR BEING READ)
                				;I HAVE A (NEGATIVE)PULSE OF 2.7USEC. (10MZ Z80, TWO IO WAIT STATES).
 0C12 0620      	MVI	B,20H		;WHICH SEEM TO WORK FOR THE 5 DIFFERENT CF CARDS I HAVE.
                RESETDELAY:
 0C14 05        	DCR	B
 0C15 C2140C    	JNZ	RESETDELAY	;DELAY (RESET PULSE WIDTH)
 0C18 AF        	XRA	A
 0C19 D332      	OUT	IDEPORTC	;NO IDE CONTROL LINES ASSERTED (JUST BIT 7 OF PORT C)
 0C1B CD640C    	CALL	DELAY$SHORT	;SHORT DELAY
 0C1E CD7C0D    	CALL	IDEWAITNOTBUSY	;WAIT FOR DRIVE
                
 0C21 DA490C    	JC	WAITINITERR
 0C24 16E0      	MVI	D,11100000B	;DATA FOR IDE SDH REG (512BYTES, LBA MODE,SINGLE DRIVE,HEAD 0000)
                				;FOR TRK,SEC,HEAD (NON LBA) USE 10100000
                				;NOTE. CANNOT GET LBA MODE TO WORK WITH AN OLD SEAGATE MEDALIST 6531 DRIVE.
                				;HAVE TO USE THE NON-LBA MODE. (COMMON FOR OLD HARD DISKS).
                
 0C26 1E0E      	MVI	E,REGSHD	;00001110,(0EH) FOR CS0,A2,A1,  
 0C28 CD9D0E    	CALL	IDEWR8D		;WRITE BYTE TO SELECT THE MASTER DEVICE
                
 0C2B 0602      	MVI	B,02H		;<<< ADJUST DELAY TIME FOR HARD DISKS TO GET UP TO SPEED (CURRENTLY ~ 2 SECONDS)
                				;<<< THIS DELAY NEED TO BE MUCH LONGER FOR ACTUAL HARD DISKS, OK FOR CF CARDS.
                WAITINIT:
 0C2D 1E0F      	MVI	E,REGSTATUS	;GET STATUS AFTER INITILIZATION
 0C2F CD8C0E    	CALL	IDERD8D		;CHECK STATUS (INFO IN [D])
 0C32 7A        	MOV	A,D
 0C33 E680      	ANI	80H
 0C35 C23B0C    	JNZ	WAITINITL	;NEED A LONGER WAIT...
 0C38 D1        	POP	D		;RESTORE REGISTERS
 0C39 C1        	POP	B
 0C3A C9        	RET			;RETURN. WELL CHECK FOR ERRORS WHEN WE GET BACK
                WAITINITL:
 0C3B 3E02      	MVI	A,2
 0C3D CD4E0C    	CALL	DELAY$LONG	;LONG DELAY, DRIVE HAS TO GET UP TO SPEED
 0C40 05        	DCR	B
 0C41 C22D0C    	JNZ	WAITINIT
 0C44 AF        	XRA	A
 0C45 3D        	DCR	A
 0C46 D1        	POP	D
 0C47 C1        	POP	B
 0C48 C9        	RET			;RETURN NZ. WELL CHECK FOR ERRORS WHEN WE GET BACK
                
                ;;;;;;
                WAITINITERR:
 0C49 AF        	XRA	A
 0C4A 3D        	DCR	A		;RETURN NZ (ERROR)
 0C4B D1        	POP	D		;RESTORE REGISTERS
 0C4C C1        	POP	B
 0C4D C9        	RET			;RETURN - CHECK FOR ERRORS THERE.
                	
                DELAY$LONG:			;LONG DELAY (SECONDS)
 0C4E 328820    	STA	@DELAYSTORE
 0C51 C5        	PUSH	B
 0C52 01FFFF    	LXI	B,0FFFFH	;<<< MAY NEED TO ADJUST DELAY TIME TO ALLOW COLD DRIVE TO
 0C55 3A8820    DELAY2:	LDA	@DELAYSTORE	;    GET UP TO SPEED.
 0C58 3D        DELAY1:	DCR	A
 0C59 C2580C    	JNZ	DELAY1
 0C5C 0B        	DCX	B
 0C5D 79        	MOV	A,C
 0C5E B0        	ORA	B
 0C5F C2550C    	JNZ	DELAY2
 0C62 C1        	POP	B
 0C63 C9        	RET
                
                
                DELAY$SHORT:			;DELAY ~32 MS (DOES NOT SEEM TO BE CRITICAL)
 0C64 3E28      	MVI	A,40
 0C66 0600      DELAY3:	MVI	B,0
                M0:	DJNZ	M0
 0C68+10        	DB	10H
 0C69+FE        	DB	M0-$-1
 0C6A 3D        	DCR	A
 0C6B C2660C    	JNZ     DELAY3 
 0C6E C9        	RET
                
                SELECTA:
 0C6F AF        	XRA	A		; SELECT DRIVE 0
 0C70 328920    	STA	@CURRENT$DRIVE
 0C73 D334      	OUT	IDEDRIVE	
 0C75 C9        	RET
                
                SELECTB:
 0C76 3E01      	MVI	A,1		; SELECT DRIVE 1
 0C78 328920    	STA	@CURRENT$DRIVE
 0C7B D334      	OUT	IDEDRIVE	
 0C7D C9        	RET
                
                				;READ A SECTOR, SPECIFIED BY THE 3 BYTES IN LBA
                				;Z ON SUCCESS, NZ CALL ERROR ROUTINE IF PROBLEM
                READSECTOR:
 0C7E CD000D    	CALL	WRLBA		;TELL WHICH SECTOR WE WANT TO READ FROM.
                				;NOTE: TRANSLATE FIRST IN CASE OF AN ERROR OTHEREWISE WE 
                				;WILL GET STUCK ON BAD SECTOR 
 0C81 CD7C0D    	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS READY
 0C84 DA100A    	JC	SHOWERRORS	;RETURNED WITH NZ SET IF ERROR
                
 0C87 1620      	MVI	D,COMMANDREAD
 0C89 1E0F      	MVI	E,REGCOMMAND
 0C8B CD9D0E    	CALL	IDEWR8D		;SEND SEC READ COMMAND TO DRIVE.
 0C8E CDA20D    	CALL	IDEWAITDRQ	;WAIT UNTIL IT'S GOT THE DATA
 0C91 DA100A    	JC	SHOWERRORS
                		
 0C94 2A6E20    	LHLD  	@DMA		;DMA ADDRESS
 0C97 0600      	MVI	B,0		;READ 512 BYTES TO [HL] (256X2 BYTES)
                MORERD16:
 0C99 3E08      	MVI	A,REGDATA	;REG REGSITER ADDRESS
 0C9B D332      	OUT	IDEPORTC	
                
 0C9D F640      	ORI	IDERDLINE	;08H+40H, PULSE RD LINE
 0C9F D332      	OUT	IDEPORTC	
                
 0CA1 DB30      	IN	IDEPORTA	;READ THE LOWER BYTE FIRST (NOTE VERY EARLY VERSIONS HAD HIGH BYTE THEN LOW BYTE
 0CA3 77        	MOV	M,A		;THIS MADE SECTOR DATA INCOMPATABLE WITH OTHER CONTROLLERS).
 0CA4 23        	INX	H
 0CA5 DB31      	IN	IDEPORTB	;THEN READ THE UPPER BYTE
 0CA7 77        	MOV	M,A
 0CA8 23        	INX	H
                	
 0CA9 3E08      	MVI	A,REGDATA	;DEASSERT RD LINE
 0CAB D332      	OUT	IDEPORTC
                	DJNZ	MORERD16
 0CAD+10        	DB	10H
 0CAE+EA        	DB	MORERD16-$-1
                
 0CAF 1E0F      	MVI	E,REGSTATUS
 0CB1 CD8C0E    	CALL	IDERD8D
 0CB4 7A        	MOV	A,D
 0CB5 E601      	ANI	1H
 0CB7 C4100A    	CNZ	SHOWERRORS	;IF ERROR DISPLAY STATUS
 0CBA C9        	RET
                
                				;WRITE A SECTOR, SPECIFIED BY THE 3 BYTES IN LBA 
                				;Z ON SUCCESS, NZ TO ERROR ROUTINE IF PROBLEM
                WRITESECTOR:
 0CBB CD000D    	CALL	WRLBA		;TELL WHICH SECTOR WE WANT TO READ FROM.
                				;NOTE: TRANSLATE FIRST IN CASE OF AN ERROR OTHEREWISE WE 
                				;WILL GET STUCK ON BAD SECTOR 
 0CBE CD7C0D    	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE IS READY
 0CC1 DA100A    	JC	SHOWERRORS
                
 0CC4 1630      	MVI	D,COMMANDWRITE
 0CC6 1E0F      	MVI	E,REGCOMMAND
 0CC8 CD9D0E    	CALL	IDEWR8D		;TELL DRIVE TO WRITE A SECTOR
 0CCB CDA20D    	CALL	IDEWAITDRQ	;WAIT UNIT IT WANTS THE DATA
 0CCE DA100A    	JC	SHOWERRORS
                
 0CD1 2A6E20    	LHLD    @DMA
 0CD4 0600      	MVI	B,0		;256X2 BYTES
                
 0CD6 3E80      	MVI	A,WRITECFG8255
 0CD8 D333      	OUT	IDEPORTCTRL
                	
 0CDA 7E        WRSEC1:	MOV	A,M
 0CDB 23        	INX	H
 0CDC D330      	OUT	IDEPORTA	;WRITE THE LOWER BYTE FIRST (NOTE EARLY VERSIONS HAD HIGH BYTE THEN LOW BYTE
 0CDE 7E        	MOV	A,M		;THIS MADE SECTOR DATA INCOMPATABLE WITH OTHER CONTROLLERS).
 0CDF 23        	INX	H
 0CE0 D331      	OUT	IDEPORTB	;THEN HIGH BYTE ON B
                
 0CE2 3E08      	MVI	A,REGDATA
 0CE4 F5        	PUSH	PSW
 0CE5 D332      	OUT	IDEPORTC	;SEND WRITE COMMAND
 0CE7 F620      	ORI	IDEWRLINE	;SEND WR PULSE
 0CE9 D332      	OUT	IDEPORTC
 0CEB F1        	POP	PSW
 0CEC D332      	OUT	IDEPORTC
                	DJNZ	WRSEC1
 0CEE+10        	DB	10H
 0CEF+EA        	DB	WRSEC1-$-1
                	
 0CF0 3E92      	MVI	A,READCFG8255	;SET 8255 BACK TO READ MODE
 0CF2 D333      	OUT	IDEPORTCTRL	
                
 0CF4 1E0F      	MVI	E,REGSTATUS
 0CF6 CD8C0E    	CALL	IDERD8D
 0CF9 7A        	MOV	A,D
 0CFA E601      	ANI	1H
 0CFC C4100A    	CNZ	SHOWERRORS	;IF ERROR DISPLAY STATUS
 0CFF C9        	RET
                
                
                WRLBA:
 0D00 CD7C0D    	CALL	IDEWAITNOTBUSY	;MAKE SURE DRIVE ISN'T BUSY...
 0D03 DA100A    	JC	SHOWERRORS	;IF ERROR, DISPLAY STATUS
 0D06 3A8B20    	LDA	@MAX$SEC	;ARE WE USING THE SPECIAL "NO HOLES" DISK FORMAT OR NOT?
 0D09 FE3F      	CPI	3FH
 0D0B CA390D    	JZ	WRLBANOHOLES	;SPECIAL CASE "NO HOLES"
                				;ELSE ANY OTHER FORMAT (3DH OR 3FFH)
                
                WRLBAHOLES:			;WRITE THE LOGICAL BLOCK ADDRESS TO THE DRIVE'S REGISTERS
                				;NOTE WE DO NOT NEED TO SET THE UPPER NIBBLE OF THE LBA
                				;IT WILL ALWAYS BE 0 FOR THESE SMALL DRIVES
 0D0E 3A7420    	LDA	@SEC		;LBA MODE LOW SECTORS GO DIRECTLY 
                	
                ;	INR	A		;SECTORS ARE NUMBERED 1 -- MAXSEC (EVEN IN LBA MODE)
                				;<<< NOTE THIS IS CHANGED IN VER 3.1 ONWARDS. NOW ALL SECTORS START AT SEC 0
                				
 0D11 327020    	STA	@DRIVE$SEC	;FOR DIAGNOSTIC DISPLAY ONLY
 0D14 57        	MOV	D,A
 0D15 1E0B      	MVI	E,REGSECTOR	;SEND INFO TO DRIVE
 0D17 CD9D0E    	CALL	IDEWR8D		;NOTE: FOR DRIVE WE WILL HAVE 0 - MAXSEC SECTORS ONLY
                				
 0D1A 2A7620    	LHLD	@TRK		
 0D1D 7D        	MOV	A,L
 0D1E 327120    	STA	@DRIVE$TRK
 0D21 55        	MOV	D,L		;SEND LOW TRK#
 0D22 1E0C      	MVI	E,REGCYLINDERLSB
 0D24 CD9D0E    	CALL	IDEWR8D
                
 0D27 7C        	MOV	A,H
 0D28 327220    	STA	@DRIVE$TRK+1
 0D2B 54        	MOV	D,H		;SEND HIGH TRK#
 0D2C 1E0D      	MVI	E,REGCYLINDERMSB
 0D2E CD9D0E    	CALL	IDEWR8D
                
 0D31 1601      	MVI	D,1		;FOR NOW, ONE SECTOR AT A TIME
 0D33 1E0A      	MVI	E,REGSECCNT
 0D35 CD9D0E    	CALL	IDEWR8D
 0D38 C9        	RET
                
                
                WRLBANOHOLES:
                				;SEE HTTP://S100COMPUTERS.COM/MY%20SYSTEM%20PAGES/IDE%20BOARD/MY%20IDE%20CARD.HTM
                				;SEE BOTTOM OF PAGE "CPM INSTALLATION INFO"
                				;STARTING WITH LBA 0 AND WITHOUT LEAVING AN "HOLES"
 0D39 2A7620    	LHLD	@TRK		;GET THE "CPM" REQUESTED TRACK HIGH & LOW
 0D3C 7D        	MOV	A,L		;GET LOW BYTE OF TRACK
 0D3D 0F        	RRC			;GET BOTTOM TWO BITS IN HIGH BITS OF A
 0D3E 0F        	RRC
 0D3F E6C0      	ANI	0C0H		;JUST WHAT WERE THE BOTTOM TWO BITS (NOW AT THE TOP)
 0D41 4F        	MOV	C,A		;SAVE IN C
 0D42 3A7420    	LDA	@SEC		;SECTOR NUMBER IN A
 0D45 E63F      	ANI	03FH		;TAKE ONLY BOTTOM 6 BITS, JUST IN CASE
 0D47 B1        	ORA	C		;ADD IN TOP 2 BITS OF TRACK
 0D48 327020    	STA	@DRIVE$SEC	;FOR DIAGNOSTIC DISPLAY ONLY
 0D4B 57        	MOV	D,A		;SEND INFO TO THE DRIVE
 0D4C 1E0B      	MVI	E,REGSECTOR
 0D4E CD9D0E    	CALL	IDEWR8D
                
 0D51 7D        	MOV	A,L		;GET LOW BYTE OF TRACK AGAIN
 0D52 0F        	RRC			;EXTRACT OUT JUST THE TOP 6 BITS
 0D53 0F        	RRC
 0D54 E63F      	ANI	03FH
 0D56 4F        	MOV	C,A		;SAVE IN C
 0D57 7C        	MOV	A,H		;GET HIGH BYTE OF TRACK.
 0D58 0F        	RRC			;ROTATE TWICE, LEAVING LOW 2 BITS
 0D59 0F        	RRC			;IN UPPER BITS OF A
 0D5A E6C0      	ANI	0C0H		;MASK ALL BUT THE TWO BITS WE WANT
 0D5C B1        	ORA	C		;ADD IN THE TOP 6 BITS OF THE FIRST TRACK BYTE
 0D5D 327120    	STA	@DRIVE$TRK
 0D60 57        	MOV	D,A		;SEND LOW TRK#
 0D61 1E0C      	MVI	E,REGCYLINDERLSB
 0D63 CD9D0E    	CALL	IDEWR8D
                	
 0D66 7C        	MOV	A,H		;GET HIGH BYTE OF TRACK
 0D67 0F        	RRC			;JUST THE TOP 6 BITS
 0D68 0F        	RRC
 0D69 E63F      	ANI	03FH
 0D6B 327220    	STA	@DRIVE$TRK+1
 0D6E 57        	MOV	D,A		;SEND HIGH TRK#
 0D6F 1E0D      	MVI	E,REGCYLINDERMSB
 0D71 CD9D0E    	CALL	IDEWR8D
                
 0D74 1601      	MVI	D,1		;FOR NOW, ONE SECTOR AT A TIME
 0D76 1E0A      	MVI	E,REGSECCNT
 0D78 CD9D0E    	CALL	IDEWR8D
 0D7B C9        	RET
                
                IDEWAITNOTBUSY:			;IE DRIVE READY IF 01000000
 0D7C 06FF      	MVI	B,0FFH
 0D7E 3EFF      	MVI	A,0FFH		;DELAY, MUST BE ABOVE 80H FOR 4MHZ Z80. LEAVE LONGER FOR SLOWER DRIVES
 0D80 328820    	STA	@DELAYSTORE
                
                MOREWAIT:
 0D83 1E0F      	MVI	E,REGSTATUS	;WAIT FOR RDY BIT TO BE SET
 0D85 CD8C0E    	CALL	IDERD8D
 0D88 7A        	MOV	A,D
 0D89 E6C0      	ANI	11000000B
 0D8B EE40      	XRI	01000000B
 0D8D CAA00D    	JZ	DONENOTBUSY
 0D90 05        	DCR	B	
 0D91 C2830D    	JNZ	MOREWAIT
 0D94 3A8820    	LDA	@DELAYSTORE	;CHECK TIMEOUT DELAY
 0D97 3D        	DCR	A
 0D98 328820    	STA	@DELAYSTORE
 0D9B C2830D    	JNZ	MOREWAIT
 0D9E 37        	STC			;SET CARRY TO INDICATE AN ERROR
 0D9F C9        	RET
                DONENOTBUSY:
 0DA0 B7        	ORA	A		;CLEAR CARRY IT INDICATE NO ERROR
 0DA1 C9        	RET
                
                				;WAIT FOR THE DRIVE TO BE READY TO TRANSFER DATA.
                				;RETURNS THE DRIVE'S STATUS IN ACC
                IDEWAITDRQ:
 0DA2 06FF      	MVI	B,0FFH
 0DA4 3EFF      	MVI	A,0FFH		;DELAY, MUST BE ABOVE 80H FOR 4MHZ Z80. LEAVE LONGER FOR SLOWER DRIVES
 0DA6 328820    	STA	@DELAYSTORE
                
                MOREDRQ:
 0DA9 1E0F      	MVI	E,REGSTATUS	;WAIT FOR DRQ BIT TO BE SET
 0DAB CD8C0E    	CALL	IDERD8D
 0DAE 7A        	MOV	A,D
 0DAF E688      	ANI	10001000B
 0DB1 FE08      	CPI	00001000B
 0DB3 CAC60D    	JZ	DONEDRQ
 0DB6 05        	DCR	B
 0DB7 C2A90D    	JNZ	MOREDRQ
 0DBA 3A8820    	LDA	@DELAYSTORE	;CHECK TIMEOUT DELAY
 0DBD 3D        	DCR	A
 0DBE 328820    	STA	@DELAYSTORE
 0DC1 C2A90D    	JNZ	MOREDRQ
 0DC4 37        	STC			;SET CARRY TO INDICATE ERROR
 0DC5 C9        	RET
                DONEDRQ:
 0DC6 B7        	ORA	A		;CLEAR CARRY
 0DC7 C9        	RET
                
                CLEAR$ID$BUFFER:		;CLEAR THE ID BUFFER AREA
 0DC8 21AE21    	LXI	H,IDBUFFER
 0DCB 010002    	LXI	B,512
 0DCE 3E20      CLEAR2:	MVI	A,' '
 0DD0 77        	MOV	M,A
 0DD1 23        	INX	H
 0DD2 0B        	DCX	B
 0DD3 79        	MOV	A,C
 0DD4 B0        	ORA	B
 0DD5 C2CE0D    	JNZ	CLEAR2
                	
 0DD8 21AE21    	LXI	H,IDBUFFER	;PUT IN 0'S FOR CYLINDER,HEADS,SECTORS ETC
 0DDB 010E00    	LXI	B,14
 0DDE 3E00      CLEAR3:	MVI	A,0
 0DE0 77        	MOV	M,A
 0DE1 23        	INX	H
 0DE2 0B        	DCX	B
 0DE3 79        	MOV	A,C
 0DE4 B0        	ORA	B
 0DE5 C2DE0D    	JNZ	CLEAR3
 0DE8 C9        	RET
                
                
                
                
                ;------------------------------------ DISPLAY CF CARD ID --------------------------------
                ;
                ID$PRINT:			;PRINT THE DRIVE MODEL NUMBER ETC.
 0DE9 21BA21    	LXI     H,IDBUFFER + 12
 0DEC 7E        	MOV	A,M		;IF THERE ARE ZERO SECTORS (HIGH BYTE) THEN SOMETHING WRONG
 0DED B7        	ORA	A
 0DEE C2FF0D    	JNZ	ID$PRINT2
 0DF1 23        	INX	H
 0DF2 7E        	MOV	A,M		;(LOW BYTE)
 0DF3 B7        	ORA	A
 0DF4 C2FF0D    	JNZ	ID$PRINT2	;LOOKS LIKE WE HAVE A VALID IDE DRIVE
                	
 0DF7 11F80F    	LXI	D,BAD$DRIVE
 0DFA CD0B0A    	CALL	PSTRING
 0DFD 37        	STC			;INDICATE ERROR
 0DFE C9        	RET
                ID$PRINT2:
 0DFF 116310    	LXI	D,DRIVE$INFO
 0E02 CD0B0A    	CALL	PSTRING
 0E05 118610    	LXI     D, MSGMDL	
 0E08 CD0B0A    	CALL	PSTRING
 0E0B 21E421    	LXI     H,IDBUFFER + 54
 0E0E 0614      	MVI	B,20		;CHARACTER COUNT IN WORDS
 0E10 CDB909    	CALL	PRINTNAME	;PRINT [HL], [B] X 2 CHARACTERS
 0E13 CDCA09    	CALL	ZCRLF
                				; PRINT THE DRIVE'S SERIAL NUMBER
 0E16 118E10    	LXI     D, MSGSN
 0E19 CD0B0A    	CALL	PSTRING
 0E1C 21C221    	LXI     H,IDBUFFER + 20
 0E1F 060A      	MVI	B,10		;CHARACTER COUNT IN WORDS
 0E21 CDB909    	CALL	PRINTNAME
 0E24 CDCA09    	CALL	ZCRLF
                				;PRINT THE DRIVE'S FIRMWARE REVISION STRING
 0E27 119610    	LXI     D, MSGREV
 0E2A CD0B0A    	CALL	PSTRING
 0E2D 21DC21    	LXI     H,IDBUFFER + 46
 0E30 0604      	MVI	B, 4
 0E32 CDB909    	CALL	PRINTNAME	;CHARACTER COUNT IN WORDS
 0E35 CDCA09    	CALL	ZCRLF
                
                				;TELL USER WHETHER OR NOT LBA IS SUPPORTED
 0E38 11E510    	LXI	D,MSGLBASUP1	;FIRST PART OF LBA SUPPORT MESSAGE
 0E3B CD0B0A    	CALL	PSTRING
 0E3E 3A1122    	LDA	IDBUFFER+98+1	;BITS 15-10 RESERVED, 9 LBA, 8 DMA
 0E41 E602      	ANI	02H
 0E43 C24C0E    	JNZ	ID$PRINT3	;LBA IS SUPPORTED
 0E46 11ED10    	LXI	D,MSGLBANOT	;LBA IS NOT SUPPORTED
 0E49 CD0B0A    	CALL	PSTRING
                ID$PRINT3:
 0E4C 11F210    	LXI	D,MSGLBASUP2
 0E4F CD0B0A    	CALL	PSTRING
                
                				;PRINT THE DRIVE'S CYLINDER, HEAD, AND SECTOR SPECS
 0E52 119E10    	LXI     D, MSGCY
 0E55 CD0B0A    	CALL	PSTRING
 0E58 21B021    	LXI     H,IDBUFFER + 2
 0E5B CDB40A    	CALL	PRINTPARM
 0E5E 11AA10    	LXI     D,MSGHD
 0E61 CD0B0A    	CALL	PSTRING
 0E64 21B421    	LXI     H,IDBUFFER + 6
 0E67 CDB40A    	CALL	PRINTPARM
 0E6A 11B410    	LXI     D, MSGSC
 0E6D CD0B0A    	CALL	PSTRING
 0E70 21BA21    	LXI     H,IDBUFFER + 12
 0E73 CDB40A    	CALL	PRINTPARM
 0E76 CDCA09    	CALL	ZCRLF
                				;DEFAULT POSITION WILL BE FIRST BLOCK 
 0E79 210000    	LXI	H,0
 0E7C 227420    	SHLD	@SEC		;DEFAULT TO TRACK 0, SEC 0
 0E7F 227620    	SHLD	@TRK
 0E82 210040    	LXI	H,BUFFER	;SET DMA ADDRESS TO BUFFER
 0E85 226E20    	SHLD	@DMA
                
 0E88 CD080C    	CALL	IDEINIT		;FOR SOME REASON THIS NEED TO BE HERE AFTER GETTING THE DRIVE ID.
                				;OTHERWISE SECTOR #'S ARE OFF BY ONE!
                				;COMMENT, PERHAPS THIS WAS BECAUSE THE CARD WASN'T REALLY IN LBA MODE?
 0E8B C9        	RET
                
                ;------------------------------------------------------------------
                ; LOW LEVEL 8 BIT R/W TO THE DRIVE CONTROLLER.  THESE ARE THE ROUTINES THAT TALK
                ; DIRECTLY TO THE DRIVE CONTROLLER REGISTERS, VIA THE 8255 CHIP.  
                ; NOTE THE 16 BIT I/O TO THE DRIVE (WHICH IS ONLY FOR SEC R/W) IS DONE DIRECTLY 
                ; IN THE ROUTINES READSECTOR & WRITESECTOR FOR SPEED REASONS.
                ;
                IDERD8D:				;READ 8 BITS FROM IDE REGISTER IN [E], RETURN INFO IN [D]
 0E8C 7B        	MOV	A,E
 0E8D D332      	OUT	IDEPORTC		;DRIVE ADDRESS ONTO CONTROL LINES
                
 0E8F F640      	ORI	IDERDLINE		;RD PULSE PIN (40H)
 0E91 D332      	OUT	IDEPORTC		;ASSERT READ PIN
                
 0E93 DB30      	IN	IDEPORTA
 0E95 57        	MOV	D,A			;RETURN WITH DATA IN [D]
                
 0E96 7B        	MOV	A,E			;<---KEN ROBBINS SUGGESTION
 0E97 D332      	OUT	IDEPORTC		;DEASSERT RD PIN
                
 0E99 AF        	XRA	A
 0E9A D332      	OUT	IDEPORTC		;ZERO ALL PORT C LINES
 0E9C C9        	RET
                
                
                IDEWR8D:				;WRITE DATA IN [D] TO IDE REGISTER IN [E]
 0E9D 3E80      	MVI	A,WRITECFG8255		;SET 8255 TO WRITE MODE
 0E9F D333      	OUT	IDEPORTCTRL
                
 0EA1 7A        	MOV	A,D			;GET DATA PUT IT IN 8255 A PORT
 0EA2 D330      	OUT	IDEPORTA
                
 0EA4 7B        	MOV	A,E			;SELECT IDE REGISTER
 0EA5 D332      	OUT	IDEPORTC
                
 0EA7 F620      	ORI	IDEWRLINE		;LOWER WR LINE
 0EA9 D332      	OUT	IDEPORTC
                	
 0EAB 7B        	MOV	A,E			;<-- KEN ROBBINS SUGGESTION, RAISE WR LINE
 0EAC D332      	OUT	IDEPORTC		;DEASSERT RD PIN
                
 0EAE AF        	XRA	A			;DESELECT ALL LINES INCLUDING WR LINE
 0EAF D332      	OUT	IDEPORTC
                
 0EB1 3E92      	MVI	A,READCFG8255		;CONFIG 8255 CHIP, READ MODE ON RETURN
 0EB3 D333      	OUT	IDEPORTCTRL
 0EB5 C9        	RET
                
                
                CPM$MOVE$CODE				;THIS CODE IS WRITTEN TO RESIDE AT 0H. WILL BE RELOCATED BY THIS
 0EB6 210040    	LXI	H,BUFFER		;THIS PROGRAM TO MOVE THE BOOT CPMLDR TO 100H IN RAM (OVERWRITING THIS PROGRAM)
 0EB9 110001    	LXI	D,100H
 0EBC 010018    	LXI	B,(12*512)
                	LDIR
 0EBF+EDB0      	DB	0EDH,0B0H
 0EC1 C30001    	JMP	100H
                CPM$MOVE$CODE$END:
                	
 0EC4 0D0A494445SIGN$ON:	DB	CR,LF,'IDE Disk Drive Test Program (V3.1) '
 0EE9 285573696E		DB	'(Using CPM3 Console BIOS Routines)',CR,LF,'$'
 0F0E 536563746FSEC$TRK$MSG	DB	'Sectors/Track = $'
                		
 0F1F 496E697469		DB	'Initilizing IDE Board, one moment please...',CR,LF,'$'
 0F4D 496E697469INIT$1$ERROR:	DB	'Initilizing of First Drive failed. Aborting Program.',BELL,CR,LF,'$'
 0F85 496E697469INIT$2$ERROR	DB	'Initilizing of Second Drive failed. (Possibly not present).',BELL,CR,LF,'$'
 0FC4 4572726F72ID$ERROR:	DB	'Error obtaining Drive ID.',CR,LF,'$'
 0FE0 4472697665INIT$DR$OK:	DB	'Drive Initilized OK.',CR,LF,LF,'$'
 0FF8 0D0A447269BAD$DRIVE:	DB	CR,LF,'Drive ID Information appears invalid. '
 1020 2844726976		DB	'(Drive possibly not present).',CR,LF,'$'
 1040 4472697665DRIVE0$IDMSG:	DB	'Drive #0 - Invalid ID - Aborting',CR,LF,'$'
 1063 4472697665DRIVE$INFO:	DB	'Drive ID Paramater Information:-',CR,LF,'$'
 1086 4D6F64656CMSGMDL:		DB	'Model: $'
 108E 532F4E3A20MSGSN:		DB	'S/N:   $'
 1096 5265763A20MSGREV:		DB	'Rev:   $'
 109E 43796C696EMSGCY:		DB	'Cylinders: $'
 10AA 2C20486561MSGHD:		DB	', Heads: $'
 10B4 2C20536563MSGSC:		DB	', Sectors: $'
 10C0 43504D2054MSGCPMTRK:	DB	'CPM TRK = $'
 10CB 2043504D20MSGCPMSEC:	DB	' CPM SEC = $'
 10D7 2020284C42MSGLBA:		DB	'  (LBA = 00$'
 10E3 2924      MSGBRACKET	DB	')$'
 10E5 4C42412069MSGLBASUP1:	DB	'LBA is $'
 10ED 4E4F542024MSGLBANOT:	DB	'NOT $'
 10F2 537570706FMSGLBASUP2	DB	'Supported',CR,LF,'$'
                
 10FE 0D0A0A4944SIGNON$STRING: DB	CR,LF,LF,'IDE Board Diagnostic MENU$'
 111B 2020284452DRIVE$A$MSG:	DB	'  (DRIVE A: Sectors/Track = $'
 1138 2020284452DRIVE$B$MSG:	DB	'  (DRIVE B: Sectors/Track = $'
                
 1155 2852292052CMD$STRING1:    DB      '(R) Read Sector        (W) Write to Sector'
 117F 2020202020                DB	'        (N) Next Sector',CR,LF
 1198 2841292053		DB	'(A) Select Drive A     (B) Select Drive B'
 11C1 2020202020		DB	'         (M) Set Sectors/Track',CR,LF
 11E1 2850292050		DB	'(P) Previous Sector    (S) Sequental Sec Read'
 120E 2020202020		DB	'     (V) Read N Sectors',CR,LF 
 1227 2858292057		DB	'(X) Write N Sectors    (E) Clear Sec Buffer'
 1252 2020202020		DB	'       (L) Set LBA value',CR,LF
 126C 2844292053		DB	'(D) Set Display ON     (Y) Copy Disk A: to B:'
 1299 2020202020		DB	'     (Z) Verify Disk A: = B:',CR,LF
 12B7 2846292046		DB	'(F) Format CPM Disk    (H) Backup disk'
 12DD 2020202020		DB	'            (G) Restore Backup',CR,LF
 12FD 2843292042		DB	'(C) Boot CPM           (U) Power Up'
 1320 2020202020		DB	'               (T) Power Down ',CR,LF
 1340 284F292046		DB	'(O) First Sec. Number  (ESC) Quit',CR,LF
 1363 0A43757272		DB	LF,'Current settings:- $'
                 	
                          	
 1378 2852292052CMD$STRING2: 	DB      '(R) Read Sector        (W) Write to Sector'
 13A2 2020202020                DB	'        (N) Next Sector',CR,LF
 13BB 2841292053		DB	'(A) Select Drive A     (B) Select Drive B'
 13E4 2020202020		DB	'         (M) Set Sectors/Track',CR,LF
 1404 2850292050		DB	'(P) Previous Sector    (S) Sequental Sec Read'
 1431 2020202020		DB	'     (V) Read N Sectors',CR,LF 
 144A 2858292057		DB	'(X) Write N Sectors    (E) Clear Sec Buffer'
 1475 2020202020		DB	'       (L) Set LBA value',CR,LF
 148F 2844292053		DB	'(D) Set Display OFF    (Y) Copy Disk A: to B:'
 14BC 2020202020		DB	'     (Z) Verify Disk A: = B:',CR,LF
 14DA 2846292046		DB	'(F) Format CPM Disk    (H) Backup disk'
 1500 2020202020		DB	'            (G) Restore Backup',CR,LF
 1520 2843292042		DB	'(C) Boot CPM           (U) Power Up'
 1543 2020202020		DB	'               (T) Power Down ',CR,LF
 1563 284F292046		DB	'(O) First Sec. Number  (ESC) Quit',CR,LF
 1586 0A43757272		DB	LF,'Current settings:- $'
                	
 159B 0D0A0A506CPROMPT:		DB	CR,LF,LF,'Please enter command >$'
 15B5 0D0A576172MSGSURE:	DB	CR,LF,'Warning: this will change data on the drive, '
 15E4 6172652079		DB	'are you sure? (Y/N)...$'
 15FB 0D0A536563MSGRD:		DB	CR,LF,'Sector Read OK',CR,LF,'$'
 160E 0D0A536563MSGWR:		DB	CR,LF,'Sector Write OK',CR,LF,'$'
 1622 456E746572GET$LBA:	DB	'Enter CPM style TRK & SEC values (in hex).',CR,LF,'$'
 164F 4472697665SEC$RW$ERROR	DB	'Drive Error, Status Register = $'
 166F 4472697665ERR$REG$DATA	DB	'Drive Error, Error Register = $'
 168E 5374617274ENTER$SECL	DB	'Starting sector number,(xxH) = $'
 16AE 547261636BENTER$TRKL	DB	'Track number (LOW byte, xxH) = $'
 16CE 547261636BENTER$TRKH	DB	'Track number (HIGH byte, xxH) = $'
 16EF 4865616420ENTER$HEAD	DB	'Head number (01-0f) = $'
 1706 4E756D6265ENTER$COUNT	DB	'Number of sectors to R/W = $'
 1722 4472697665DRIVE$BUSY	DB	'Drive Busy (bit 7) stuck high.   Status = $'
 174D 4472697665DRIVE$NOT$READY	DB	'Drive Ready (bit 6) stuck low.  Status = $'
 1777 4472697665DRIVE$WR$FAULT	DB	'Drive write fault.    Status = $'
 1797 556E6B6E6FUNKNOWN$ERROR	DB	'Unknown error in status register.   Status = $'
 17C5 4261642053BAD$BLOCK	DB	'Bad Sector ID.    Error Register = $'
 17E9 556E636F72UNRECOVER$ERR	DB	'Uncorrectable data error.  Error Register = $'
 1816 4572726F72READ$ID$ERROR	DB	'Error setting up to read Drive ID',CR,LF,'$'
 183A 536563746FSEC$NOT$FOUND	DB	'Sector not found. Error Register = $'
 185E 496E76616CINVALID$CMD	DB	'Invalid Command. Error Register = $'
 1881 547261636BTRK0$ERR	DB	'Track Zero not found. Error Register = $'
 18A9 556E6B6E6FUNKNOWN$ERROR1	DB	'Unknown Error. Error Register = $'
 18CA 0D0A546F20CONTINUE$MSG	DB	CR,LF,'To Abort enter ESC. Any other key to continue. $'
 18FC 464F524D41FORMAT$MSG	DB	'FORMAT DISK. Fill all sectors with E5'
 1921 6073206F6E		DB	60H,'s on the CURRENT drive/CF card.$'
 1942 0D0A526561READN$MSG	DB	CR,LF,'Read multiple sectors from current disk/CF card to RAM buffer.'
 1982 0D0A486F77		DB	CR,LF,'How many 512 byte sectores (xx HEX):$'
 19A9 0D0A577269WRITEN$MSG	DB	CR,LF,'Write multiple sectors RAM buffer CURRENT disk/CF card.'
 19E2 0D0A486F77		DB	CR,LF,'How many 512 byte sectores (xx HEX):$'
 1A09 0D0A526561READINGN$MSG	DB	CR,LF,'Reading Sector at:- $'
 1A20 0D0A577269WRITINGN$MSG	DB	CR,LF,'Writing Sector at:- $'
 1A37 0D0A536F72MSGERR		DB	CR,LF,'Sorry, that was not a valid menu option!$'
 1A62 0D0A446973FORMATDONE	DB	CR,LF,'Disk Format Complete.',CR,LF,'$'
 1A7C 0D0A446973BACKUPDONE	DB	CR,LF,'Disk partition copy complete.',CR,LF,'$'
 1A9E 0D0A436F70COPYMSG		DB	CR,LF,'Copy disk partition to a second area on disk (CF card).'
 1AD7 0D0A3E3E3E		DB	CR,LF,'>>> This assumes that tracks greater than MAXTRK '
 1B0A 28666F7220		DB	'(for CPM, 0FFH) are unused <<<'
 1B28 0D0A3E3E3E		DB	CR,LF,'>>> on this disk. Be sure you have nothing in this '
 1B5D 224261636B		DB	'"Backup partition area". <<<'
 1B79 0D0A075761		DB	CR,LF,BELL,'Warning: This will change data in the partition area, '
 1BB2 6172652079		DB	'are you sure? (Y/N)...$ '
 1BCA 0D0A417420ATEND		DB	CR,LF,'At end of disk partition!',CR,LF,'$'
 1BE8 5265616469RBACKUP$MSG	DB	'Reading track: $'
 1BF8 482E205772WBACKUP$MSG	DB	'H. Writing track: $'
 1C0B 4824      H$MSG		DB	'H$'
 1C0D 0D0A526573RESTOREMSG	DB	CR,LF,'Restore disk with data from backup partition on disk (CF card).'
 1C4E 0D0A075761		DB	CR,LF,BELL,'Warning: This will change data on disk, '
 1C79 6172652079		DB	'are you sure? (Y/N)...$ '
 1C91 0D0A526573RESTOREDONE	DB	CR,LF,'Restore of disk data from backup partition complete.',CR,LF,'$'
 1CCA 0D0A536563RANGE$MSG	DB	CR,LF,'Sector value out of range.',CR,LF,'$'
 1CE9 0D0A457272CPM$ERROR	DB	CR,LF,'Error reading CPMLDR.',CR,LF,'$'
 1D03 0D0A446174CPM$ERROR1	DB	CR,LF,'Data error reading CPMLDR. (The first byte loaded was not 31H).',CR,LF,'$'
 1D47 0D0A546865MOVE$REQUEST	DB	CR,LF,'The CPMLDR image is now at 3000H in RAM. '
 1D72 546F20626F		DB	'To boot CPM you will have to'
 1D8E 0D0A6F7665		DB	CR,LF,'overwrite this program at 100H. Do you wish to do so (Y/N)...$'
 1DCE 0D0A437572SETA$MSG	DB	CR,LF,'Current Drive is now A: (Yellow LED)$'
 1DF5 0D0A437572SETB$MSG	DB	CR,LF,'Current Drive is now B: (Green LED)$'
 1E1B 0D0A536563FILL$MSG	DB	CR,LF,'Sector buffer in RAM filled with 0',27H,'s$'		
 1E42 0D0A436F70DISKCOPYMSG	DB	CR,LF,'Copy disk partition of Drive A: to Drive B: (CF card).'
 1E7A 0D0A075761		DB	CR,LF,BELL,'Warning: This will delete all data on Drive B:, '
 1EAD 6172652079		DB	'are you sure? (Y/N)...$ '
 1EC5 0D0A446973COPYDONE	DB	CR,LF,'Disk copy of CPM disk A: to B: complete.',CR,LF,'$'
 1EF2 436F707969COPYTRK$MSG	DB	'Copying track: $'
                		
 1F02 0D0A566572DISKVERIFYMSG	DB	CR,LF,'Verify disk partition Drive A: = Drive B: (CF card).$'
 1F39 5665726966VERIFYTRK$MSG	DB	'Verifying track: $'
 1F4B 0D0A566572VERIFYDONE	DB	CR,LF,'Verify CPM disk A: = B: complete.',CR,LF,'$'
 1F71 0D0A075665VERIFY$ERR	DB	CR,LF,BELL,'Verify error on Track $'
 1F8B 4820205365SEC$MSG		DB	'H  Sector $'
                ;SET$NOHOLE$MSG	DB	'NO HOLE MODE SET.  MAXIMUM SECTOR SET TO DEFAULT OF 03FH',CR,LF,'$'
                ;SET$HOLE$MSG	DB	'HOLE MODE SET.  MAXIMUM SECTOR LEFT AT CURRENT VALUE',CR,LF,'$'
 1F96 456E746572GET$MAX$SEC$MSG	DB	'Enter max sector/Track value (00 - FF): $'
 1FBF 536563746FGET$FIRST$SEC$MSG DB	'Sectors can be numbered 0,1,2,3... (On CF cards) or '
 1FF3 312C322C33		DB	'1,2,3,4... (On Hard Disks).',CR,LF
 2010 456E746572		DB	'Enter the first sector number (00 or 01):$'  
 203A 2C20466972FIRST$STRING	DB	', First Sec # = $'
                
                
                
                ; -------------------------- RAM USAGE -----------------------------------------
                
 204B 2020202020RAMAREA		DB	'           RAM STORE AREA -------->'		;USEFUL FOR DEBUGGING
 206E 0040      @DMA		DW	BUFFER
 2070 00        @DRIVE$SEC	DB	0H
 2071 0000      @DRIVE$TRK	DW	0H
 2073 FF        @DISPLAYFLAG	DB	0FFH		;DISPLAY OF SECTOR DATA INITIALLY ON
 2074 0000      @SEC		DW	0H
 2076 0000      @TRK		DW	0H
 2078 0000      @SEC1		DW	0H		;FOR DISK PARTITION COPY
 207A 0000      @TRK1		DW	0H
 207C 0000      @SEC2		DW	0H
 207E 0000      @TRK2		DW	0H
 2080 0000      @STARTLINEHEX	DW	0H
 2082 0000      @STARTLINEASCII	DW	0H
 2084 0000      @BYTE$COUNT	DW	0H
 2086 0000      @SECTOR$COUNT	DW	0H
 2088 00        @DELAYSTORE	DB	0H
 2089 00        @CURRENT$DRIVE	DB	0H
 208A 00        @DRIVEBPRESENT	DB	0H		;1 IF SECOND DRIVE IS PRESENT
 208B 3D        @MAX$SEC	DB	3DH		;MAX "CPM" SECTORS/TRACK (DEFAULT 3DH FOR "WITH HOLES" MODE)
 208C 00        @FIRST$SEC	DB	0H
                
 208D           		DS	100H
 218D 0000      STACK:		DW	0H
                
                ;
 218F 2020202020		DB	'          Start of ID buffer-->'
 21AE           IDBUFFER:	DS	512
 23AE 3C2D2D456E		DB	'<--End of ID buffer            '
                					
 4000           		ORG	BUFFER$ORG				;<--- IN CASE WE WISH TO USE ZSID ETC.
                
 4000 76        BUFFER:		DB	76H					;PUT A Z80 HALT INSTRUCTION HERE IN CASE WE 
                								;JUMP TO A SECTOR IN ERROR
 4001 3C2D2D5374		DB	'<--Start buffer area'			;A 512 BYTE BUFFER 
 4015           		DS	476
 41F1 456E64206F		DB	'End of buffer-->'
                								;JUMP TO A SECTOR IN ERROR
 4201 3C2D2D5374BUFFER2:	DB	'<--Start buffer2 area'			;A 512 BYTE BUFFER 
 4216           		DS	476
 43F2 456E64206F		DB	'End of buffer2-->'
                
                
 4403           		END	BEGIN
