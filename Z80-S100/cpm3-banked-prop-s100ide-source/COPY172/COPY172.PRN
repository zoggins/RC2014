ZMAC Relocating Macro Assembler v 1.7,                       page    1
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

     2                     ;=======================================================================;
     3                     ;                               C O P Y                                 ;
     4                     ;-----------------------------------------------------------------------;
     5                     ; Derived from MCOPY 4.0 by Richard Conn with Mods by Bruce Morgen(4.8),;
     6                     ; Howard Goldstein (4.6), Michael Bate (4.4,5), Steven M. Cohen (4.3),  ;
     7                     ; Jay Sage, and Joe Wright (4.2)                                        ;
     8                     ;-----------------------------------------------------------------------;
     9                     ; Changes for ZSDOS and DSLIB Copyright (C) 1988  by Harold F. Bower    ;
    10                     ;                       All rights reserved                             ;
    11                     ; This program is made available for non-commercial use.  Any commercial;
    12                     ; use must be authorized by the express written consent of the author.  ;
    13                     ;-----------------------------------------------------------------------;
    14                     ; COPY is a program which copies files between drives or between User   ;
    15                     ; areas.  If Date/Time Stamping is used, Create and Modify Stamps will  ;
    16                     ; be preserved.  Stamps are accessed through DSLIB routines.            ;
    17                     ;                                                                       ;
    18                     ; COPY MUST be linked with The Libraries, Version 4 as:                 ;
    19                     ;                                                                       ;
    20                     ;       ZML COPY,DSLIB/,Z3LIB/,SYSLIB/                                  ;
    21                     ;                                                                       ;
    22                     ; Revisions:                                                            ;
    23                     ;       1.72- Replaced DDIRQ & DDIRPACK library routines with source    ;
    24                     ;               modified to handle Joe Wright's NZTIME stamps along     ;
    25                     ;               with P2Dos, DateStamper(tm) and DosDisk(tm) Stamps.     ;
    26                     ;                                                 17 Jul 93  HFB        ;
    27                     ;       1.71- Deleted unique code in favor of GETMTOP/GZMTOP, deleted   ;
    28                     ;               ZFPARS subroutine for calls to ZPRSFN.  24 Mar 91, HFB  ;
    29                     ;       1.70- Added separate existence test for R/O files controlled by ;
    30                     ;               new O switch.  R/O source files not erased by X option. ;
    31                     ;               M option no longer restricts copy to one group of       ;
    32                     ;               files.  Set attributes call only done when absolutely   ;
    33                     ;               necessary for speed improvement.  Disk reset done for   ;
    34                     ;               all DOS's to ensure proper operation under DOSDISK or   ;
    35                     ;               SPEEDUP RSX.  Initialization improved; CRASHES UNDER    ;
    36                     ;               vanilla CCP fixed.  Top of memory calculation uses      ;
    37                     ;               extended environment if available.  Date comparisons    ;
    38                     ;               now done on all systems that support stamping, not just ;
    39                     ;               ZSDOS.  Bug affecting ZRDOS Public restoration fixed.   ;
    40                     ;               Unnecessary external declarations removed.              ;
    41                     ;                                                       1-9 Mar 91, HG  ;
    42                     ;       1.64- Changed local stack calculations          23 Jul 89, HFB  ;
    43                     ;       1.63- Corrected operation w/"vanilla" CP/M      16 Jul 89, HFB  ;
    44                     ;       1.62- Fixed not restoring entry DU w/o ZCPR3     7 Jun 89, HFB  ;
    45                     ;       1.61- Fixed error in Help Name printout          3 Jun 89, HFB  ;
    46                     ;       1.6 - Modified to operate without ZCPR3, maximum use of Vers 4  ;
    47                     ;               libraries, auto-search for COPY.CFG.    26 May 89, HFB  ;
    48                     ;       1.5 - Fixed obscure bug in buffer calcs, added Jay Sage's patch ;
    49                     ;               to allow COPY DIR:FN.FT to copy to default DIR: rather  ;
    50                     ;               than BACKUP:, Added logic to inhibit /X if /M active.   ;
    51                     ;                                                 12 Mar-2 Apr 89, CWC  ;
    52                     ;       1.4 - Corrected glitch in date comparisons      11 Dec 88, HFB  ;
    53                     ;       1.3 - Unlinked 'E' disable from 'R' and 'A', corrected lack of  ;
    54                     ;               sensing 'R' and 'X', Fall back to Create if no Modify   ;
    55                     ;               date, and print "undated" if neither present, ignore    ;
    56                     ;               erase with X-option if Verify Error.   3-5 Dec 88, HFB  ;
    57                     ;       1.2 - Added 'R' (Replace) option, changed 'X' option to Erase   ;
ZMAC Relocating Macro Assembler v 1.7,                       page    2
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

    58                     ;               source after copy. Release version       2 Dec 88, HFB  ;
    59                     ;       1.1a- Fix glitch on DS only operation, allow rename in same     ;
    60                     ;               user area with different name           25 Nov 88, HFB  ;
    61                     ;       1.1 - Formal release version                    17 Nov 88, HFB  ;
    62                     ;       1.0a-e -  Bug fix in E & N Options, Added Archive, Fixed /M bug ;
    63                     ;               w/test in mcpy28, Restored CRC bypass if not verifying, ;
    64                     ;               corrected glitch if no space on dest, Added File Exclude;
    65                     ;               list, File rename, Archive only if file exists, test    ;
    66                     ;               dates on each file, Add Source open time to Access field;
    67                     ;                                                25 Sep-15 Nov 88, HFB  ;
    68                     ;       1.0 - Initial Release                           18 Sep 88       ;
    69                     ;=======================================================================;

    71         = 0011      VERS    EQU     17              ; Initial Release
    72         = 0032      rev     equ     '2'             ; Bug fix revision
    73                     DATE      MACRO
    74                             DEFB    '17 Jul 93'     ; Prompt Date for easy access
    75                               ENDM

    77                     ; SPECIAL Constants

    79         = 00C0      PLIM    EQU     4*48            ; Size of buffer in pages (4 * nk)
    80                                                     ;       [may be changed]
    81         = 0010      FNSIZE  EQU     16              ; Number of bytes in basic Nam.Typ fields
    82         = 001F      ESIZE   EQU     FNSIZE+15       ; Number of bytes/entry + Date Stamps

    84                     ; CP/M Constants

    86         = 0000      WB      EQU     0               ; CP/M warm boot
    87         = 0005      BDOSE   EQU     WB+5            ; Bdos entry point
    88         = 005C      FCB     EQU     WB+5CH          ; Specified FCB
    89         = 0080      BUFF    EQU     WB+80H          ; Default buffer and input line

    91                     ; DOS Functions Used

    93         = 001A      SDMA    EQU     26              ; Dos Command to set DMA transfer addr
    94         = 0011      SRCHF   EQU     17              ; Dos Command to Search for First file match
    95         = 0012      SRCHN   EQU     18              ; Dos Command to Search for Next file match

    97                     ; ASCII Constants, et al

    99         = 00FF      ON      EQU     0FFH            ; On code
   100         = 0000      OFF     EQU     0               ; Off code
   101         = 000D      CR      EQU     0DH             ; <cr>
   102         = 000A      LF      EQU     0AH             ; <lf>
   103         = 0009      TAB     EQU     09H             ; Horizontal tab
   104         = 0003      CTRLC   EQU     'C'-'@'         ; ^c
   105         = 002F      OPTC    EQU     '/'             ; Option delimiter
   106         = 0000      OPTS    EQU     0000H           ; Skippable option table value

   108                     ; Library Routines used in this Program

   110                             EXT     RETUD, LOGUD, PUTUD, GETUD, GETMTOP, INITFCB    ; Syslib
   111                             EXT     F$EXIST, SETDMA, BDOS, CIN, COUT, CONDIN, CRLF  ;   "
   112                             EXT     MOVEB, EPRINT, EPSTR, PFN1, F$DELETE, F$OPEN    ;   "
   113                             EXT     F$MAKE, F$CLOSE, F$READ, F$WRITE, PAFDC, CAPS   ;   "
ZMAC Relocating Macro Assembler v 1.7,                       page    3
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   114                             EXT     CRC3INIT, CRC3CLR, CRC3UPD, CRC3DONE, CODEND    ;   "
   115                             EXT     DIRMAX, DIRBUF, DPARAMS, @FNCMP, SORT, SSBINIT  ;(DDIRQ)

   117                             EXT     Z3INIT, ZPRSFN, GETQUIET, GETEFCB               ; Z3Lib
   118                             EXT     GETMSG, PUTER2, STOPZEX, WHRENV                 ;   "
   119                             EXT     DIRTDU, DUNDR, GZMTOP                           ;   "

   121                             EXT     GSTAMP, PSTAMP, TIMINI, DOSTYP, TIMTYP, RCLOCK  ; Dslib
   122                             EXT     FINDCK, CKTDF, OPENTD, RWTD, CLOSTD, FSTNXT     ;(DDIRQ)
   123                             EXT     P2UTIM, M2UTIM, BIN2BCD                         ;(DDIRQ)

   125                     ;------------------------------------------------------------------
   126                     ; External ZCPR3 Environment Descriptor

   128   0000' C3 0083'            JP      START

   130   0003' 5A 33 45 4E         DEFB    'Z3ENV'         ; This is a ZCPR3 utility
   131   0008' 01                  DEFB    1               ; External environment descriptor
   132   0009' 0001        Z3EADR: DEFW    0001            ; Dummy value to force WHRENV search

   134                     ; This section aligns to locations needed for ZCNFG auto-search for
   135                     ; configuration file name.  It is aligned to Type-4 header values.

   137   000B' 0000                DEFW    0000            ; Filler for ZCNFG file name offset
   138   000D' 43 4F 50 59         DEFB    'COPY    ',0    ; Search for COPY.CFG

   140                     ; User-Definable Initial Flag Conditions
   141                     ;  The default conditions for MCOPY may be readily patched by the user
   142                     ;  via DDT for his desired default values

   144   0016'             DEFTBL:
   145   0016' FF          DVERFLG: DEFB   ON              ; Set verify
   146   0017' 00          DINSP:   DEFB   OFF             ; Set no inspect
   147   0018' 00          DSYSEXC: DEFB   OFF             ; Set no $SYS file exclusion by default
   148   0019' 00          DNCOPY:  DEFB   OFF             ; Set no multiple copies by default
   149   001A' FF          DEXIST:  DEFB   ON              ; Existence testing on
   150   001B' FF          DEXTRO   DEFB   ON              ; Existence testing, R/O files, on
   151   001C' 00          DARCHV:  DEFB   OFF             ; Do not operate in Archive mode
   152   001D' 00          DREPL:   DEFB   OFF             ; Do Not restrict copy to Existing files
   153                     ;---- All above entries copied to CPYTBL
   154   001E' FF          TYPDAT:  DEFB   ON              ; Type of stamps to select in Source
   155                                                     ; OFF = P2D/DosDisk, ON = DateStamper
   156   001F' 00          USEDDU:  DEFB   OFF             ; If on, default DU: given in next 3 fields
   157   0020' 00          DDUSER:  DEFB   0               ; Default destination user is 0
   158   0021' 01          DDDISK:  DEFB   'B'-'A'         ; Default destination disk is B
   159   0022' 42 41 43 4B BACKDIR: DEFB   'BACKUP  '      ; Name of backup directory
   160   002A' 21 21 3F 3F EXCLUD:  DEFB   '!!?????????'   ; 8-name File Exclusion list
   161   0035' 5B 3F 3F 3F          DEFB   '[??????]???'
   162   0040' 3F 3F 3F 3F          DEFB   '????????$?$'
   163   004B' 20 20 20 20          DEFB   '           '
   164   0056' 20 20 20 20          DEFB   '           '
   165   0061' 20 20 20 20          DEFB   '           '
   166   006C' 20 20 20 20          DEFB   '           '
   167   0077' 20 20 20 20          DEFB   '           '
   168   0082' 00                   DEFB   0               ; List terminator

ZMAC Relocating Macro Assembler v 1.7,                       page    4
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   170                     ; Beginning of COPY Program

   172   0083'             START:                          ; Set up Dynamic (whew!) Buffers
   173   0083' ED73 00A9"          LD      (STACK),SP      ; Save incoming stack pointer
   174   0087' 31 00A9"            LD      SP,STACK        ; ..and set a local stack
   175   008A' 21 0015"            LD      HL,DATABG       ; Set program data area to 0
   176   008D' 11 0016"            LD      DE,DATABG+1
   177   0090' 01 0093             LD      BC,STACK-DATABG-1
   178   0093' 36 00               LD      (HL),0
   179   0095' EDB0                LDIR
   180   0097' CD 0000#            CALL    CODEND          ; Determine free space
   181   009A' CD 0000#            CALL    CRC3INIT        ; Create CRC table
   182   009D' 24                  INC     H               ; Allow 2 pages for CRC table
   183   009E' 24                  INC     H
   184   009F' 22 0063"            LD      (INLINE),HL     ; Ptr to input line
   185   00A2' 2E 80               LD      L,128
   186   00A4' 22 002A"            LD      (FCBS),HL       ; Ptr to source FCB
   187   00A7' 2E A4               LD      L,128+36
   188   00A9' 22 002C"            LD      (FCBD),HL       ; Ptr to dest FCB
   189   00AC' 24                  INC     H
   190   00AD' 2E 00               LD      L,0
   191   00AF' 22 0065"            LD      (FREEBUF),HL    ; Free space buffer

   193   00B2' CD 0000#            CALL    EPRINT          ; Print Banner
   194   00B5' 43 4F 50 59         DEFB    'COPY  Version '
   195   00C3' 31 2E 37 32         DEFB    VERS/10+'0','.',VERS MOD 10 + '0',rev,' (for ZSDOS)   '
   196                             DATE
   196   00D6' 31 37 20 4A         DEFB    '17 Jul 93'     ; Prompt Date for easy access
   197   00DF' 00                  DEFB    0

   199   00E0' 2A 0009'            LD      HL,(Z3EADR)     ; Get candidate ZCPR3 environment
   200   00E3' CD 0000#            CALL    WHRENV
   201   00E6' 22 0009'            LD      (Z3EADR),HL     ; ..and store validated ENV addr
   202   00E9' CD 0000#            CALL    Z3INIT          ; Initialize the ZCPR3 ENV and Z3LIB vectors

   204   00EC' CD 0000#            CALL    TIMINI          ; Initialize the Dos & Time System
   205   00EF' 3A 000A'            LD      A,(Z3EADR+1)    ; Do we have a valid ENV?
   206   00F2' B7                  OR      A               ;  (Page must be Non-Zero if valid)
   207   00F3' 20 06'              JR      NZ,MSGS         ; Have ENV, go do msg stuff
   208   00F5' 3D                  DEC     A
   209   00F6' 32 0033"            LD      (NOMSGS),A      ; No env means no msg buffer
   210   00F9' 18 19'              JR      SDFLGS

   212   00FB' CD 0000#    MSGS:   CALL    STOPZEX         ; Prevent ZEX input

   214   00FE' CD 0000#            CALL    GETQUIET        ; Get ZCPR3 quiet flag
   215   0101' 32 0038"            LD      (QUIET),A       ; ..and set local flag

   217   0104' CD 0000#            CALL    GETMSG          ; See if there is a message buffer
   218   0107' 20 07'              JR      NZ,HAVMSGS
   219   0109' 3E FF               LD      A,0FFH          ; No message buffer - set indicator
   220   010B' 32 0033"            LD      (NOMSGS),A
   221   010E' 18 04'              JR      SDFLGS

   223   0110' AF          HAVMSGS: XOR    A               ; There is a message buffer - clear
   224   0111' CD 0000#            CALL    PUTER2          ; the error flag
ZMAC Relocating Macro Assembler v 1.7,                       page    5
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


   226                     ; Set Default Flags

   228   0114' 21 0016'    SDFLGS: LD      HL,DEFTBL       ; Copy default options to mem.
   229   0117' 11 001B"            LD      DE,CPYTBL
   230   011A' 06 08               LD      B,TBLLEN
   231   011C' CD 0000#            CALL    MOVEB

   233                     ; Check for Backup Directory and establish it as default
   234                     ;  If No Backup Directory or No ZCPR3, select default stored

   236   011F' CD 0000#            CALL    RETUD           ; Set Current DU in BC just in case
   237   0122' 78                  LD      A,B             ; Save disk
   238   0123' 32 0023"            LD      (CDISK),A
   239   0126' 3A 001F'            LD      A,(USEDDU)      ; Fixed default for DU:?
   240   0129' A7                  AND     A
   241   012A' 28 12'              JR      Z,DEFBAK        ; ..jump if not and set current dest

   243   012C' 3A 000A'    DEFBK0: LD      A,(Z3EADR+1)    ; Any valid ENV?
   244   012F' B7                  OR      A
   245   0130' 28 08'              JR      Z,DEFBK1        ; ..get stored default if not
   246   0132' 21 0022'            LD      HL,BACKDIR      ; Pt to directory name
   247   0135' CD 0000#            CALL    DIRTDU          ; Does it exist?
   248   0138' 20 04'              JR      NZ,DEFBAK       ; ..jump if found and select
   249   013A' ED4B 0020'  DEFBK1: LD      BC,(DDUSER)     ; Otherwise use default DU
   250   013E' ED43 0026"  DEFBAK: LD      (DUSER),BC

   252   0142' CD 0000#            CALL    PUTUD           ; Save current Drive/User position
   253   0145' ED5B 0063"          LD      DE,(INLINE)     ; Input line save buffer
   254   0149' 21 0081             LD      HL,BUFF+1       ; Pt to command line characters
   255   014C' 06 7F               LD      B,127           ; Save 127 bytes (arbitrary)
   256   014E' CD 0000#            CALL    MOVEB
   257   0151' EB                  EX      DE,HL           ; Hl pts to input line

   259                     ; Set other flags (always defaults to "off")

   261   0152' AF                  XOR     A               ; A=0
   262   0153' 32 0039"            LD      (NOREPL),A      ; Turn off "no copy if exists" option
   263   0156' 32 0037"            LD      (XMOVE),A       ; ..and "remove source after copy"

   265                     ; Check for empty Command Line and process Command Mode if so
   266                     ; On Entry, HL pts to first char of string from CLINE

   268   0159' 7E          START1: LD      A,(HL)          ; Get char
   269   015A' B7                  OR      A               ; Eol?
   270   015B' CA 0214'            JP      Z,MHELP         ; Print help message if no input
   271   015E' 23                  INC     HL              ; Pt to next
   272   015F' FE 20               CP      ' '             ; Just spaces?
   273   0161' 28 F6'              JR      Z,START1

   275                     ; Command Line was Not Empty -- Check for HELP request

   277   0163' 2B                  DEC     HL              ; Pt to first char
   278   0164' FE 2F               CP      OPTC            ; If opening option, must be help
   279   0166' CA 0214'            JP      Z,MHELP

ZMAC Relocating Macro Assembler v 1.7,                       page    6
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   281                     ; See if Options are available in the Command Line

   283   0169' 22 0015"            LD      (MFPTR),HL      ; Set ptr to first char of file name specs
   284                                                     ; ..Skip to end of File Name Specs
   285   016C' 3A 0080             LD      A,(BUFF)        ; Tail char. count
   286   016F' 4F                  LD      C,A             ; To C
   287   0170' AF                  XOR     A               ; Search for terminating null
   288   0171' 47                  LD      B,A             ; BC now has count
   289   0172' EDB1                CPIR                    ; Search..
   290   0174' C2 0214'            JP      NZ,MHELP        ; Not found, something screwy
   291   0177' 2B                  DEC     HL              ; Get last real char.
   292   0178' 2B                  DEC     HL
   293   0179' 7E                  LD      A,(HL)
   294   017A' FE 3A               CP      ':'             ; Was it a dest. DU:/DIR: ?
   295   017C' 28 1E'              JR      Z,OVRIDE        ; If so, non-option
   296   017E' 3E 20               LD      A,' '           ; Search back for next blank
   297   0180' 0E 0C               LD      C,OPTLEN+1      ; Range in (B)C
   298   0182' EDB9                CPDR                    ; Search..
   299   0184' 20 16'              JR      NZ,OVRIDE       ; Not found, too long for option
   300   0186' 23                  INC     HL              ; Bump point to potential option
   301   0187' 23                  INC     HL
   302   0188' CD 0C87'            CALL    OPTQ            ; Test it thoroughly
   303   018B' 20 0F'              JR      NZ,OVRIDE       ; Treat as option if Z returned

   305                     ; Scan for Option

   307   018D' 7E          OPTION: LD      A,(HL)          ; Get option char
   308   018E' B7                  OR      A               ; Eol?
   309   018F' 28 0B'              JR      Z,OVRIDE        ; Do mcopy
   310   0191' 23                  INC     HL              ; Pt to next
   311   0192' E5                  PUSH    HL              ; Save ptr
   312   0193' 21 01D1'            LD      HL,OPTTAB       ; Pt to option table
   313   0196' CD 01B9'            CALL    CMDER           ; Process command
   314   0199' E1                  POP     HL              ; Get ptr
   315   019A' 18 F1'              JR      OPTION

   317                     ; Since the no replace mode is incompatible with the exist test
   318                     ; mode, if norepl flag is on turn exist off

   320   019C' 3A 0021"    OVRIDE: LD      A,(ARCHIV)      ; Is this an Archive opn?
   321   019F' B7                  OR      A
   322   01A0' 20 06'              JR      NZ,OVRID1       ; ..Supercede other ops if so
   323   01A2' 3A 0022"            LD      A,(REPLAC)      ; Is this copy if Exist?
   324   01A5' B7                  OR      A
   325   01A6' 28 04'              JR      Z,MCOP0V        ; ..jump if not
   326   01A8' AF          OVRID1: XOR     A
   327   01A9' 32 0039"            LD      (NOREPL),A      ; ..and No Replace is off
   328   01AC' 3A 001E"    MCOP0V: LD      A,(NCOPY)
   329   01AF' B7                  OR      A
   330   01B0' 28 04'              JR      Z,OVRID2        ; Test for multiple copy
   331   01B2' AF                  XOR     A
   332   01B3' 32 0037"            LD      (XMOVE),A       ; clear source delete if multiple
   333   01B6' C3 04D3'    OVRID2: JP      MCOPY0

   335                     ; Command Processor -- Command letter in A, HL pts to Table

ZMAC Relocating Macro Assembler v 1.7,                       page    7
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   337   01B9' 47          CMDER:  LD      B,A             ; Command in b
   338   01BA' 7E          CMDER1: LD      A,(HL)          ; Get command letter
   339   01BB' B7                  OR      A               ; Done?
   340   01BC' 28 38'              JR      Z,OHELP
   341   01BE' B8                  CP      B               ; Match?
   342   01BF' 23                  INC     HL              ; Pt to address
   343   01C0' 20 0B'              JR      NZ,CMDER3
   344   01C2' 5E                  LD      E,(HL)          ; Get it in DE
   345   01C3' 23                  INC     HL
   346   01C4' 56                  LD      D,(HL)
   347   01C5' EB                  EX      DE,HL           ; HL pts to command address
   348   01C6' 7D                  LD      A,L
   349   01C7' B4                  OR      H               ; Test for OPTS
   350   01C8' C8                  RET     Z               ; Return w/no action if so
   351   01C9' 7E                  LD      A,(HL)          ; Otherwise get option byte
   352   01CA' 2F                  CPL                     ; Flip it
   353   01CB' 77                  LD      (HL),A          ; Put it back
   354   01CC' C9                  RET

   356   01CD' 23          CMDER3: INC     HL              ; Skip to next entry in table
   357   01CE' 23                  INC     HL
   358   01CF' 18 E9'              JR      CMDER1

   360                     ; Option Command Table

   362   01D1' 20          OPTTAB: DEFB    ' '             ; Skip blanks
   363   01D2' 0000                DEFW    OPTS
   364   01D4' 41                  DEFB    'A'             ; Archive mode
   365   01D5' 0021                DEFW    ARCHIV
   366   01D7' 45                  DEFB    'E'             ; Exist test
   367   01D8' 001F                DEFW    EXIST
   368   01DA' 49                  DEFB    'I'             ; Inspect
   369   01DB' 001C                DEFW    INSP
   370   01DD' 4D                  DEFB    'M'             ; Multiple copy
   371   01DE' 001E                DEFW    NCOPY
   372   01E0' 4E                  DEFB    'N'             ; No copy if file already on dest.
   373   01E1' 0039                DEFW    NOREPL
   374   01E3' 51                  DEFB    'Q'             ; Quiet
   375   01E4' 0038                DEFW    QUIET
   376   01E6' 53                  DEFB    'S'             ; System Exclude
   377   01E7' 001D                DEFW    SYSEXC
   378   01E9' 56                  DEFB    'V'             ; Verify
   379   01EA' 001B                DEFW    VERFLG
   380   01EC' 58                  DEFB    'X'             ; Remove Source after copy
   381   01ED' 0037                DEFW    XMOVE
   382   01EF' 52                  DEFB    'R'             ; Copy ONLY if Dest. Exists
   383   01F0' 0022                DEFW    REPLAC
   384   01F2' 4F                  DEFB    'O'             ; Existence test for R/O files
   385   01F3' 0020                DEFW    EXRO
   386   01F5' 00                  DEFB    0               ; End of table

   388                     ; Invalid Option Char --  Adjust Stack and Print Help

   390   01F6' 3A 0038"    OHELP:  LD      A,(QUIET)
   391   01F9' B7                  OR      A
   392   01FA' 3E 07               LD      A,7
ZMAC Relocating Macro Assembler v 1.7,                       page    8
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   393   01FC' CC 0000#            CALL    Z,COUT          ; Beep if not muzzled
   394   01FF' CD 0000#            CALL    EPRINT
   395   0202' 0D 0A 4F 70         DEFB    CR,LF,'Option error!',CR,LF,0

   397                     ; Print Help Message  (NOTE: DUSER set correctly by the time we get here)

   399   0214' CD 0000#    MHELP:  CALL    EPRINT
   400   0217' 0D 0A 53 79         DEFB    CR,LF,'Syntax:'
   401   0220' 0D 0A 20 20         DEFB    CR,LF,'  ',0
   402   0225' CD 0C57'            CALL    COMNAM          ; "COPY" or EFCB name
   403   0228' CD 0000#            CALL    EPRINT
   404   022B' 20 64 69 72         DEFB    ' dir:[filename.typ]=[dir:]filename.typ,... [/]o...'
   405   025D' 0D 0A 09 09         DEFB    CR,LF,TAB,TAB,'(or)'
   406   0265' 0D 0A 20 20         DEFB    CR,LF,'  ',0
   407   026A' CD 0C57'            CALL    COMNAM          ; "COPY" or EFCB name
   408   026D' CD 0000#            CALL    EPRINT
   409   0270' 20 5B 64 69         DEFB    ' [dir:]filename.typ dir:[filename.typ],... [/]o...'
   410   02A2' 0D 0A 09 09         DEFB    CR,LF,TAB,TAB,'(or)'
   411   02AA' 0D 0A 20 20         DEFB    CR,LF,'  ',0
   412   02AF' CD 0C57'            CALL    COMNAM          ; "COPY" or EFCB name
   413   02B2' CD 0000#            CALL    EPRINT
   414   02B5' 20 5B 64 69         DEFB    ' [dir:]filename.typ,... /o...'
   415   02D2' 0D 0A 09 28         DEFB    CR,LF,TAB,'(Copies to ',0

   417   02E1' ED4B 0026"          LD      BC,(DUSER)      ; get default destination DU:
   418   02E5' CD 0C48'            CALL    PRNDU           ; ..print it
   419   02E8' 04                  INC     B               ; make drive one based for this
   420   02E9' 3A 000A'            LD      A,(Z3EADR+1)    ; Do we have a valid ENV?
   421   02EC' B7                  OR      A
   422   02ED' C4 0000#            CALL    NZ,DUNDR        ; Check for NDR for this one if ENV Ok
   423   02F0' 28 04'              JR      Z,GOTBAK        ; ..jump if no ENV or Name
   424   02F2' 23                  INC     HL              ; point to name
   425   02F3' CD 0C60'            CALL    PRNNAM          ; ..and print up to 8 chars
   426                      
   427   02F6' CD 0000#    GOTBAK: CALL    EPRINT
   428   02F9' 29                  DEFB    ')'
   429   02FA' 0D 0A 4F 70         DEFB    CR,LF,'Options:'
   430   0304' 0D 0A 20 20         DEFB    CR,LF,'  A -- ',0  ; Copy only Non-Archive?
   431   030E' 3A 0021"            LD      A,(ARCHIV)
   432   0311' B7                  OR      A
   433   0312' C4 04CB'            CALL    NZ,SAYNO        ; ..FF is No copy if archived
   434   0315' CD 0000#            CALL    EPRINT
   435   0318' 41 72 63 68         DEFB    'Archive Bit Control'
   436   032B' 0D 0A 20 20         DEFB    CR,LF,'  E -- ',0
   437   0335' 3A 001F"            LD      A,(EXIST)
   438   0338' B7                  OR      A
   439   0339' C4 04CB'            CALL    NZ,SAYNO
   440   033C' CD 0000#            CALL    EPRINT
   441   033F' 45 78 69 73         DEFB    'Existence Test'
   442   034D' 0D 0A 20 20         DEFB    CR,LF,'  I -- ',0
   443   0357' 3A 001C"            LD      A,(INSP)
   444   035A' B7                  OR      A
   445   035B' C4 04CB'            CALL    NZ,SAYNO
   446   035E' CD 0000#            CALL    EPRINT
   447   0361' 49 6E 73 70         DEFB    'Inspect Files'
   448   036E' 0D 0A 20 20         DEFB    CR,LF,'  M -- ',0
ZMAC Relocating Macro Assembler v 1.7,                       page    9
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   449   0378' 3A 001E"            LD      A,(NCOPY)
   450   037B' B7                  OR      A
   451   037C' C4 04CB'            CALL    NZ,SAYNO
   452   037F' CD 0000#            CALL    EPRINT
   453   0382' 4D 75 6C 74         DEFB    'Multiple Copy'
   454   038F' 0D 0A 20 20         DEFB    CR,LF,'  N -- NO Copy if Destination Exists'
   455   03B5' 0D 0A 20 20         DEFB    CR,LF,'  O -- ',0
   456   03BF' 3A 0020"            LD      A,(EXRO)
   457   03C2' B7                  OR      A
   458   03C3' C4 04CB'            CALL    NZ,SAYNO
   459   03C6' CD 0000#            CALL    EPRINT
   460   03C9' 45 78 69 73         DEFB    'Existence test - R/O files'
   461   03E3' 0D 0A 20 20         DEFB    CR,LF,'  Q -- ',0
   462   03ED' 3A 0038"            LD      A,(QUIET)
   463   03F0' B7                  OR      A
   464   03F1' C4 04CB'            CALL    NZ,SAYNO
   465   03F4' CD 0000#            CALL    EPRINT
   466   03F7' 51 75 69 65         DEFB    'Quiet'
   467   03FC' 0D 0A 20 20         DEFB    CR,LF,'  R -- ',0
   468   0406' 3A 001D'            LD      A,(DREPL)
   469   0409' B7                  OR      A
   470   040A' C4 04CB'            CALL    NZ,SAYNO
   471   040D' CD 0000#            CALL    EPRINT
   472   0410' 52 65 70 6C         DEFB    'Replace Only Files existing'
   473   042B' 0D 0A 20 20         DEFB    CR,LF,'  S -- ',0
   474   0435' 3A 001D"            LD      A,(SYSEXC)
   475   0438' B7                  OR      A
   476   0439' C4 04CB'            CALL    NZ,SAYNO
   477   043C' CD 0000#            CALL    EPRINT
   478   043F' 53 79 73 74         DEFB    'System Files excluded'
   479   0454' 0D 0A 20 20         DEFB    CR,LF,'  V -- ',0
   480   045E' 3A 001B"            LD      A,(VERFLG)
   481   0461' B7                  OR      A
   482   0462' C4 04CB'            CALL    NZ,SAYNO
   483   0465' CD 0000#            CALL    EPRINT
   484   0468' 56 65 72 69         DEFB    'Verify'
   485   046E' 0D 0A 20 20         DEFB    CR,LF,'  X -- Delete Source After Copy',CR,LF
   486   0491' 0A 4E 4F 54         DEFB    LF,'NOTES: "R" and/or "A" turns off "N", "M" turns off "X"',0
   487   04C9' 18 3A'              JR      RETSYS          ; Return to Command Processor

   489   04CB' CD 0000#    SAYNO:  CALL    EPRINT
   490   04CE' 4E 4F 20 00         DEFB    'NO ',0
   491   04D2' C9                  RET

   493                     ; **** MCOPY of COMMAND LINE ****

   495   04D3' 31 00A9"    MCOPY0: LD      SP,STACK        ; Reset the Stack
   496   04D6' 3A 0000#            LD      A,(DOSTYP)      ; Check Dos type
   497   04D9' D6 52               SUB     'R'             ; Is it ZRDOS?
   498   04DB' 20 10'              JR      NZ,NOTZRD       ; ..jump if not
   499   04DD' 2A 0009'            LD      HL,(Z3EADR)
   500   04E0' 11 007E             LD      DE,07EH
   501   04E3' 19                  ADD     HL,DE           ; Point HL at PUBLIC bytes
   502   04E4' 5E                  LD      E,(HL)          ; Get first PUBLIC byte in E
   503   04E5' 77                  LD      (HL),A          ; Replace with a zero
   504   04E6' 23                  INC     HL              ; Point to second byte
ZMAC Relocating Macro Assembler v 1.7,                       page   10
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   505   04E7' 56                  LD      D,(HL)          ; Get into D
   506   04E8' 77                  LD      (HL),A          ; Replace with a zero
   507   04E9' ED53 0067"          LD      (PUBS),DE       ; Save for exit

   509   04ED' CD 050A'    NOTZRD: CALL    COPY            ; Do the copy
   510   04F0' ED5B 0067"  CPM:    LD      DE,(PUBS)
   511   04F4' 7B                  LD      A,E
   512   04F5' B2                  OR      D
   513   04F6' 28 0A'              JR      Z,NOPUB
   514   04F8' 2A 0009'            LD      HL,(Z3EADR)
   515   04FB' 01 007E             LD      BC,07EH
   516   04FE' 09                  ADD     HL,BC
   517   04FF' 73                  LD      (HL),E
   518   0500' 23                  INC     HL
   519   0501' 72                  LD      (HL),D
   520   0502' CD 0000#    NOPUB:  CALL    GETUD           ; Restore the entry DU condition
   521   0505' ED7B 00A9"  RETSYS: LD      SP,(STACK)      ; Reset stack
   522   0509' C9                  RET                     ; Return to opsys

   524                     ; **** Begin Multiple Copy Procedure ****

   526   050A' 3A 001E"    COPY:   LD      A,(NCOPY)       ; Are we doing multiple copies?
   527   050D' B7                  OR      A
   528   050E' 28 33'              JR      Z,NOPAUS        ; ..jump if not
   529   0510' CD 0000#            CALL    EPRINT
   530   0513' 0D 0A 20 2E         DEFB    CR,LF,' ...Any key starts copy, ^C Quits - ',0
   531   053A' CD 0BC3'            CALL    GETCH           ; Get response in Uppercase
   532   053D' CD 0000#            CALL    CRLF            ; Go to New Line
   533   0540' FE 03               CP      CTRLC           ; Is it an abort request (^c)?
   534   0542' C8                  RET     Z               ; ..exit here if so
   535   0543' 2A 0015"    NOPAUS: LD      HL,(MFPTR)      ; Pt to first file name
   536   0546' 22 0017"            LD      (NXTPTR),HL     ; Set ptr to next file name
   537   0549' AF                  XOR     A               ; A=0
   538   054A' 32 0030"            LD      (VERCNT),A      ; Zero error count
   539   054D' 32 0034"            LD      (NORST),A       ; Clear "no reset" flag

   541                     ; **** Main Copy Loop ****

   543   0550' 2A 0017"    MCOPY:  LD      HL,(NXTPTR)     ; Get ptr to next file name
   544   0553' 7E                  LD      A,(HL)          ; Get first char
   545   0554' FE 21               CP      ' '+1           ; Done if <sp> or less
   546   0556' 30 2B'              JR      NC,MCOPY1       ; Continue with procedure

   548                     ; MCOPY of File Specs is now done
   549                     ; Done with Copy Procedure -- Continue?

   551   0558' 3A 001B"    COPYT:  LD      A,(VERFLG)      ; Verify?
   552   055B' B7                  OR      A               ; 0=no
   553   055C' 28 1E'              JR      Z,COPYT1
   554   055E' CD 0000#            CALL    EPRINT          ; New line & a blank
   555   0561' 0D 0A 20 00         DEFB    CR,LF,' ',0
   556   0565' 3A 005F"            LD      A,(HAVFIL)      ; Did we do anything?
   557   0568' B7                  OR      A
   558   0569' 28 11'              JR      Z,COPYT1        ; ..jump if not
   559   056B' 3A 0030"            LD      A,(VERCNT)      ; Get error count
   560   056E' CD 0000#            CALL    PAFDC           ; Print as decimal
ZMAC Relocating Macro Assembler v 1.7,                       page   11
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   561   0571' CD 0000#            CALL    EPRINT
   562   0574' 20 45 72 72         DEFB    ' Errors',0
   563   057C' 3A 001E"    COPYT1: LD      A,(NCOPY)       ; Multiple copies?
   564   057F' B7                  OR      A               ; 0=no
   565   0580' C8                  RET     Z
   566   0581' 18 87'              JR      COPY            ; Copy again from the beginning

   568                     ; Begin Copy of File Group

   570   0583' FE 2C       MCOPY1: CP      ','             ; Skip comma separator if there
   571   0585' 20 01'              JR      NZ,MCPY0
   572   0587' 23                  INC     HL              ; Pt to char after comma
   573   0588' E5          MCPY0:  PUSH    HL              ; Preserve regs
   574   0589' 06 0B               LD      B,11
   575   058B' 2A 002C"            LD      HL,(FCBD)       ; Clear dest FileName
   576   058E' 23                  INC     HL
   577   058F' 36 20       INITLZ: LD      (HL),' '
   578   0591' 23                  INC     HL
   579   0592' 10 FB'              DJNZ    INITLZ          ; ..loop til done
   580   0594' E1                  POP     HL              ; Restore input pointer
   581   0595' 7E                  LD      A,(HL)          ; Get next char
   582   0596' FE 21               CP      ' '+1           ; Check for error
   583   0598' DA 09BB'            JP      C,FORMERR
   584   059B' CD 0000#            CALL    GETUD           ; Return home
   585   059E' ED5B 002A"          LD      DE,(FCBS)       ; Pt to source FCB
   586   05A2' AF                  XOR     A
   587   05A3' CD 0000#            CALL    ZPRSFN          ; Extract file name data
   588   05A6' CD 09A7'            CALL    DUCVRT          ; Convert DU into BC
   589   05A9' 7E                  LD      A,(HL)          ; Get delimiter
   590   05AA' FE 2C               CP      ','             ; End of element?
   591   05AC' 28 4C'              JR      Z,MCOPY2        ; Form is dirs:fn.ft
   592   05AE' FE 3D               CP      '='             ; If '=', we have a new disk/user
   593   05B0' 28 22'              JR      Z,NEWDU
   594   05B2' FE 20               CP      ' '             ; Test for reversed syntax
   595   05B4' 20 44'              JR      NZ,MCOPY2       ; Nope, default b/u dest.
   596   05B6' 23                  INC     HL              ; Point to dest. DU:/DIR:
   597   05B7' 7E                  LD      A,(HL)          ; One more end-of-element test
   598   05B8' FE 2C               CP      ','
   599   05BA' 28 3E'              JR      Z,MCOPY2
   600   05BC' FE 21               CP      ' '+1           ; Invalid char. test
   601   05BE' DA 09BB'            JP      C,FORMERR
   602   05C1' C5                  PUSH    BC              ; Save parsed DU in BC
   603   05C2' ED5B 002C"          LD      DE,(FCBD)       ; Set Destination FCB
   604   05C6' AF                  XOR     A
   605   05C7' CD 0000#            CALL    ZPRSFN          ; Extract file name data
   606   05CA' CD 09A7'            CALL    DUCVRT          ; Convert DU into BC
   607   05CD' ED43 0026"          LD      (DUSER),BC      ; Poke as dest.
   608   05D1' C1                  POP     BC              ; Get back src. DU
   609   05D2' 18 26'              JR      MCOPY2          ; and proceed..

   611                     ; Form is DIRD:=DIRS:FN.FT, So set Dest Disk/User

   613   05D4' ED43 0026"  NEWDU:  LD      (DUSER),BC
   614   05D8' E5                  PUSH    HL              ; Preserve regs
   615   05D9' C5                  PUSH    BC
   616   05DA' ED5B 002C"          LD      DE,(FCBD)       ; ..and copy Source to dest
ZMAC Relocating Macro Assembler v 1.7,                       page   12
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   617   05DE' 2A 002A"            LD      HL,(FCBS)
   618   05E1' 01 000C             LD      BC,12
   619   05E4' EDB0                LDIR
   620   05E6' C1                  POP     BC              ; Restore entry regs
   621   05E7' E1                  POP     HL

   623                     ; Now derive DIRS:FN.FT Form after the '='

   625   05E8' 23                  INC     HL              ; Pt to char beyond '='
   626   05E9' 7E                  LD      A,(HL)          ; Get char
   627   05EA' FE 21               CP      ' '+1           ; Format error?
   628   05EC' DA 09BB'            JP      C,FORMERR
   629   05EF' ED5B 002A"          LD      DE,(FCBS)       ; Load FCB
   630   05F3' AF                  XOR     A
   631   05F4' CD 0000#            CALL    ZPRSFN          ; Get source name
   632   05F7' CD 09A7'            CALL    DUCVRT          ; Convert to DU in BC

   634                     ; Save ptr to next char after DIRS:FN.FT, and set source Disk/User

   636   05FA' 22 0017"    MCOPY2: LD      (NXTPTR),HL     ; Save ptr to next char
   637   05FD' ED43 0024"          LD      (SUSER),BC

   639   0601' 2A 002C"            LD      HL,(FCBD)       ; Check for dest renaming
   640   0604' 3E 20               LD      A,' '           ; ..by looking for spaces
   641   0606' CD 0C79'            CALL    SCAN11
   642   0609' D6 0B               SUB     11              ; Sub no entry cnt fm space
   643   060B' 32 0060"            LD      (RENFLG),A      ; ..and save as flag
   644   060E' 28 14'              JR      Z,CKSAMU        ; Jump if not renaming
   645   0610' 2A 002C"            LD      HL,(FCBD)       ; Check for ambiguous dest fn
   646   0613' CD 0C77'            CALL    SCANQQ          ; ..by counting "?"s
   647   0616' C2 0BFB'            JP      NZ,AMBERR       ; ..jump error if ambiguous
   648   0619' 2A 002A"            LD      HL,(FCBS)       ; Check for ambiguous source
   649   061C' CD 0C77'            CALL    SCANQQ          ; ..by counting "?"s
   650   061F' C2 0BFB'            JP      NZ,AMBERR       ; ..jump Error if ambiguous
   651   0622' 18 21'              JR      MCPYOK          ; Else jump to Ok procedure

   653   0624' ED4B 0024"  CKSAMU: LD      BC,(SUSER)      ; Get Source DU
   654   0628' 2A 0026"            LD      HL,(DUSER)      ; ..and Dest DU
   655   062B' B7                  OR      A
   656   062C' ED42                SBC     HL,BC           ; Dest dir must not equal source dir
   657   062E' 20 15'              JR      NZ,MCPYOK       ; Not same, say its ok to go
   658   0630' CD 0000#            CALL    EPRINT
   659   0633' 0D 0A 53 72         DEFB    CR,LF,'Src=Dest Err',0
   660   0642' C3 0AAD'            JP      SETEFLAG        ; Set Error flag & exit

   662   0645' 3A 0021"    MCPYOK: LD      A,(ARCHIV)      ; Are we in Archival mode?
   663   0648' B7                  OR      A
   664   0649' 28 12'              JR      Z,COPYAA        ; ..jump if not
   665   064B' CD 0000#            CALL    EPRINT          ; Print archiving msg
   666   064E' 0D 0A 41 72         DEFB    CR,LF,'Archiving ',0
   667   065B' 18 0E'              JR      COPYBB

   669   065D' CD 0000#    COPYAA: CALL    EPRINT
   670   0660' 0D 0A 43 6F         DEFB    CR,LF,'Copying ',0
   671   066B' CD 0C1D'    COPYBB: CALL    PRTS2D          ; Print "Source to Dest" msg
   672   066E' 0E 0D               LD      C,13            ; Prepare to Reset disk system
ZMAC Relocating Macro Assembler v 1.7,                       page   13
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   673   0670' 3A 0034"            LD      A,(NORST)       ; Is this first copy operation?
   674   0673' B7                  OR      A
   675   0674' CC 0005             CALL    Z,BDOSE         ; Do reset if so
   676   0677' CD 0BF5'            CALL    DFLTAD          ; Set to default DMA addr
   677   067A' CD 0B86'            CALL    SETSR0          ; Log Source, Set FCB & Init it
   678   067D' 2A 0065"            LD      HL,(FREEBUF)    ; Pt to buffer area
   679   0680' F6 FF               OR      0FFH            ; Store Non-Zero wo we won't reset again
   680   0682' 32 0034"            LD      (NORST),A       ; Store a non-zero so we won't reset again
   681   0685' CD 0CE4'            CALL    DDIRQ           ; Load dir, select files, sort, etc
   682   0688' CA 09CC'            JP      Z,TPAOVFL       ; Tpa overflow error?
   683   068B' 78                  LD      A,B             ; Do we have any files?
   684   068C' B1                  OR      C
   685   068D' 28 0E'              JR      Z,SYSOK0        ; Jump if No files
   686   068F' CD 0B45'            CALL    CHKXCL          ; Check for excluded files
   687   0692' 3A 0021"            LD      A,(ARCHIV)      ; Copy only Non-Archived Files?
   688   0695' B7                  OR      A
   689   0696' C4 0B29'            CALL    NZ,SELARC       ; ..reselect directory if so
   690   0699' 78                  LD      A,B             ; And see if any remain selected
   691   069A' B1                  OR      C
   692   069B' 20 30'              JR      NZ,MCPY24       ; ..jump if so
   693   069D' 32 0034"    SYSOK0: LD      (NORST),A       ; Clear flag - disk reset before next copy
   694   06A0' CD 0AAD'            CALL    SETEFLAG        ; Set Error flag
   695   06A3' CD 0000#            CALL    EPRINT
   696   06A6' 0D 0A 20 4E         DEFB    CR,LF,' NO Files -- ^C to Abort ',0
   697   06C2' CD 0BC3'            CALL    GETCH           ; Get response
   698   06C5' FE 03               CP      CTRLC           ; Abort?
   699   06C7' CA 0558'            JP      Z,COPYT         ; End test
   700   06CA' C3 0550'            JP      MCOPY           ; Continue with next

   702   06CD' 3A 001C"    MCPY24: LD      A,(INSP)        ; Inspect files?
   703   06D0' B7                  OR      A               ; 0=No
   704   06D1' C4 0AB6'            CALL    NZ,INSPF        ; Inspect files if option selected
   705   06D4' 78                  LD      A,B             ; Did we select any files?
   706   06D5' B1                  OR      C
   707   06D6' 32 005F"            LD      (HAVFIL),A
   708   06D9' 28 C2'              JR      Z,SYSOK0        ; ..jump if not
   709   06DB' E5                  PUSH    HL              ; Save ptr and count
   710   06DC' C5                  PUSH    BC
   711   06DD' 11 001F             LD      DE,ESIZE        ; Skip to end of loaded files and mark..
   712                                                     ; ..start of Work area
   713   06E0' 19          MCPY25: ADD     HL,DE           ; Pt to next
   714   06E1' 0B                  DEC     BC              ; Count down
   715   06E2' 78                  LD      A,B             ; Done?
   716   06E3' B1                  OR      C
   717   06E4' 20 FA'              JR      NZ,MCPY25

   719                     ; ..a better way to size the copy buffer would be to examine the alloc
   720                     ;  size of the source and target disks and use n*maxalc for buffer 
   721                     ;  size, where n is adjusted to the amount of free memory available.

   723   06E6' 22 0019"            LD      (WORKBF),HL     ; Save ptr to beginning of work buffer
   724   06E9' 24                  INC     H               ; Round buffer to page boundry
   725   06EA' CD 0CC0'            CALL    GETTOP          ; Get Page of lowest OS component in A
   726   06ED' 94                  SUB     H               ; Compute size of buffer area
   727   06EE' DA 09CC'            JP      C,TPAOVFL       ; Abort if not enough tpa
   728   06F1' 2E C0               LD      L,PLIM          ; Set page limit
ZMAC Relocating Macro Assembler v 1.7,                       page   14
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   729   06F3' BD                  CP      L               ; PLIM pages left?
   730   06F4' 38 01'              JR      C,PAGOK         ; If smaller than PLIM, use it
   731   06F6' 7D                  LD      A,L             ; Otherwise use PLIM (why PLIM?)
   732   06F7' 87          PAGOK:  ADD     A,A             ; Convert to # records
   733   06F8' 30 02'              JR      NC,PAGOK0       ; ..jump if less than 256 records
   734   06FA' 3E FF               LD      A,0ffH          ; Else set to 255 record limit
   735   06FC' 32 002E"    PAGOK0: LD      (PAGLIM),A      ; Set page limit
   736   06FF' C1                  POP     BC              ; Restore ptrs
   737   0700' E1                  POP     HL

   739                     ; Main Copying Loop
   740                     ;   File names are pted to by HL and BC=Number of Files

   742   0701' AF          MCPY26: XOR     A               ; Clear the Verify error flag
   743   0702' 32 0062"            LD      (CPYERR),A
   744   0705' E5                  PUSH    HL              ; Save regs
   745   0706' C5                  PUSH    BC
   746   0707' CD 0BAE'            CALL    ABORTCK         ; Check for abort
   747   070A' AF                  XOR     A               ; Set flag for replacement abort check
   748   070B' 32 0061"            LD      (REPLCK),A
   749   070E' 3A 0000#            LD      A,(TIMTYP)      ; Can we do date stamping?
   750   0711' 32 003A"            LD      (DSFLAG),A      ; Set indicator accordingly
   751   0714' CD 0778'            CALL    MCOPYX          ; Copy Source (HL) to Dest using work buffer
   752   0717' CD 0BC9'            CALL    PRDONE          ; Print done message
   753   071A' 3A 0061"            LD      A,(REPLCK)      ; Did we abort a replace request?
   754   071D' B7                  OR      A
   755   071E' 28 4A'              JR      Z,MCPY28        ; ..bypass messages if so
   756   0720' 3A 003A"            LD      A,(DSFLAG)      ; Is DS function alive?
   757   0723' B7                  OR      A
   758   0724' 28 12'              JR      Z,NODATE        ; If not, no DS msg
   759   0726' 3A 0038"            LD      A,(QUIET)
   760   0729' B7                  OR      A               ; Are we operating Quietly?
   761   072A' 20 0C'              JR      NZ,NODATE       ; ..jump and don't print if Quiet
   762   072C' CD 0000#            CALL    EPRINT
   763   072F' 20 28 44 61         DEFB    ' (Dated)',0
   764   0738' CD 0BAE'    NODATE: CALL    ABORTCK         ; Check for abort
   765   073B' 3A 002F"            LD      A,(LSTCPY)      ; Last file copied?
   766   073E' B7                  OR      A               ; 0=no
   767   073F' 3A 001B"            LD      A,(VERFLG)      ; Verify?
   768   0742' 28 26'              JR      Z,MCPY28
   769   0744' B7                  OR      A               ; 0=no
   770   0745' C4 0A5A'            CALL    NZ,MCOPYV       ; Do verify if active

   772   0748' 3A 0037"            LD      A,(XMOVE)       ; Should we erase source file?
   773   074B' B7                  OR      A
   774   074C' 28 1C'              JR      Z,MCPY28        ; ..jump error msg if not
   775   074E' 3A 0062"            LD      A,(CPYERR)      ; Was there an error in Verify?
   776   0751' B7                  OR      A
   777   0752' 20 16'              JR      NZ,MCPY28       ; ..don't erase if so
   778   0754' CD 0B86'            CALL    SETSR0          ; Log Source, Get FCB & Init it
   779   0757' 21 0009             LD      HL,9
   780   075A' 19                  ADD     HL,DE
   781   075B' CB7E                BIT     7,(HL)          ; See if file is R/O
   782   075D' 20 0B'              JR      NZ,MCPY28       ; Don't delete if R/O
   783   075F' CD 0000#            CALL    F$DELETE        ; Delete the file
   784   0762' CD 0000#            CALL    EPRINT          ; Clue that file erased
ZMAC Relocating Macro Assembler v 1.7,                       page   15
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   785   0765' 20 28 58 29         DEFB    ' (X)',0

   787   076A' C1          MCPY28: POP     BC              ; Get regs
   788   076B' E1                  POP     HL
   789   076C' 11 001F             LD      DE,ESIZE        ; Pt to next file
   790   076F' 19                  ADD     HL,DE           ; Hl pts to next file
   791   0770' 0B                  DEC     BC              ; Count down
   792   0771' 78                  LD      A,B
   793   0772' B1                  OR      C
   794   0773' 20 8C'              JR      NZ,MCPY26
   795   0775' C3 0550'            JP      MCOPY           ; Copy next file spec

   797                     ;.....
   798                     ; Copy Source file pted to by HL to Destination

   800   0778' AF          MCOPYX: XOR     A               ; Set no copy of last file
   801   0779' 32 002F"            LD      (LSTCPY),A      ; Set flag

   803   077C' 3A 0060"            LD      A,(RENFLG)      ; Are we renaming?
   804   077F' B7                  OR      A               ; ..set flags
   805   0780' ED5B 002C"          LD      DE,(FCBD)       ; Set Destination FCB
   806   0784' 06 0C               LD      B,12
   807   0786' CC 0000#            CALL    Z,MOVEB         ; Move Drive Name&Typ if not
   808   0789' ED5B 002A"          LD      DE,(FCBS)       ; Set Source FCB
   809   078D' CD 0000#            CALL    MOVEB
   810   0790' 01 0010             LD      BC,FNSIZE       ; Offset to Stamp starting addr
   811   0793' 09                  ADD     HL,BC
   812   0794' 22 0041"            LD      (SRCTD),HL      ; ..and save
   813   0797' CD 0B9C'            CALL    SETDS0          ; Set Dest FCB & Init it
   814   079A' 62                  LD      H,D             ; Copy FCB ptr to HL
   815   079B' 6B                  LD      L,E
   816   079C' 06 0B               LD      B,11
   817   079E' 23          CLRATT: INC     HL              ; Bump to next filename character
   818   079F' CBBE                RES     7,(HL)          ; Clear attribute bit
   819   07A1' 10 FB'              DJNZ    CLRATT
   820   07A3' CD 0BF5'            CALL    DFLTAD          ; Limit "E5" schmutz to 80H-FFH
   821   07A6' 0E 11               LD      C,17
   822   07A8' CD 0000#            CALL    BDOS            ; Search for the file
   823   07AB' 3C                  INC     A               ; Was it found?
   824   07AC' 67                  LD      H,A             ; Save the flag in H
   825   07AD' 3A 0022"            LD      A,(REPLAC)      ; Are we replacing existing?
   826   07B0' B7                  OR      A
   827   07B1' 7C                  LD      A,H             ; ..preparing found test
   828   07B2' 28 02'              JR      Z,NOTX00        ; ..jump if no replace
   829   07B4' B7                  OR      A               ; Found?
   830   07B5' C8                  RET     Z               ; ..return if no file

   832   07B6' CD 0000#    NOTX00: CALL    EPRINT
   833   07B9' 0D 0A 20 2D         DEFB    CR,LF,' -> ',0
   834   07C0' 13                  INC     DE              ; Point to first char of FileName
   835   07C1' CD 0000#            CALL    PFN1            ; ..and print
   836   07C4' 1B                  DEC     DE              ; Back up to Drive byte
   837   07C5' 7C                  LD      A,H             ; Retrieve flag
   838   07C6' 3D                  DEC     A               ; Was file found?
   839   07C7' FA 08CA'            JP      M,FNF           ; ..jump if File not found (0ffh)
   840   07CA' 0F                  RRCA                    ; Convert directory code to offset in buffer
ZMAC Relocating Macro Assembler v 1.7,                       page   16
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   841   07CB' 0F                  RRCA
   842   07CC' 0F                  RRCA
   843   07CD' C6 89               ADD     A,BUFF+9        ; Point to T1 (R/O)
   844   07CF' 6F                  LD      L,A
   845   07D0' 26 00               LD      H,0
   846   07D2' 7E                  LD      A,(HL)
   847   07D3' E6 80               AND     80H             ; Isolate R/O bit
   848   07D5' 32 0035"            LD      (ROFLG),A       ; Save as a flag
   849   07D8' 47                  LD      B,A             ; Stash in B for a moment
   850   07D9' 3A 0020"            LD      A,(EXRO)        ; Get R/O exist test flag
   851   07DC' A0                  AND     B               ; And with R/O status
   852   07DD' 47                  LD      B,A             ; Save result
   853   07DE' 3A 001F"            LD      A,(EXIST)       ; Now get exist test flag
   854   07E1' B0                  OR      B               ; Or with previous result
   855   07E2' 32 0036"            LD      (RPQFLG),A      ; RPQFLG = ((EXRO AND ROFLG) OR EXIST)
   856   07E5' 3A 0039"            LD      A,(NOREPL)      ; Don't copy if already there?
   857   07E8' B7                  OR      A               ; 0=copy anyway
   858   07E9' 20 79'              JR      NZ,FFND         ; ..jump & check file found by PUBlic if so
   859   07EB' 3A 0038"    ISX00:  LD      A,(QUIET)       ; Are we operating Quietly?
   860   07EE' B7                  OR      A
   861   07EF' 20 73'              JR      NZ,FFND         ; ..jump to bypass messages if so
   862   07F1' D5                  PUSH    DE
   863   07F2' 21 0050"            LD      HL,DESTTD       ; Get Timestamp here
   864   07F5' CD 0CB8'            CALL    GETSTMP         ; .using DSLIB function
   865   07F8' D1                  POP     DE
   866   07F9' CD 0000#            CALL    EPRINT
   867   07FC' 20 20 52 65         DEFB    '  Replac',0
   868   0805' 21 0CDC'            LD      HL,SUFFX1       ; Assume ?e are prompting for overwrite
   869   0808' 3A 0036"            LD      A,(RPQFLG)      ; ..now test our assumption
   870   080B' B7                  OR      A
   871   080C' 20 03'              JR      NZ,EXIST0       ; Jump if we want to pause
   872   080E' 21 0CDF'            LD      HL,SUFFX2       ; ..else print "ing"
   873   0811' CD 0000#    EXIST0: CALL    EPSTR
   874   0814' 3A 003A"            LD      A,(DSFLAG)      ; Are we still using Stamps?
   875   0817' B7                  OR      A
   876   0818' 28 4A'              JR      Z,FFND          ; ..jump if not
   877   081A' D5                  PUSH    DE              ; Save FCB
   878   081B' 2A 0041"            LD      HL,(SRCTD)      ; Get the vector to source Stamps
   879   081E' CD 0994'            CALL    CHKDAT          ; Set Mod/Create Date & check valid
   880   0821' 28 35'              JR      Z,UNDAT         ; ..print Undated if No date
   881   0823' EB                  EX      DE,HL           ; Put Source Date addr in DE
   882   0824' 21 0050"            LD      HL,DESTTD       ; Set Dest date & check validity
   883   0827' CD 0994'            CALL    CHKDAT
   884   082A' 28 2C'              JR      Z,UNDAT         ; ..print Undated if No date
   885   082C' 06 05               LD      B,5             ; ..for 5 bytes
   886   082E' 1A          CTDLP:  LD      A,(DE)
   887   082F' BE                  CP      (HL)            ; Are they the same?
   888   0830' 38 10'              JR      C,NEWER         ; .jump here if Newer version
   889   0832' 20 19'              JR      NZ,OLDER        ; ..jump here if Older version
   890   0834' 23                  INC     HL              ; Else
   891   0835' 13                  INC     DE              ; .bump ptrs cause same
   892   0836' 10 F6'              DJNZ    CTDLP           ; ..and loop til done (Same)
   893   0838' CD 0000#            CALL    EPRINT
   894   083B' 53 61 6D 65         DEFB    'Same',0
   895   0840' 18 21'              JR      DATEX           ; Rejoin code

ZMAC Relocating Macro Assembler v 1.7,                       page   17
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   897   0842' CD 0000#    NEWER:  CALL    EPRINT
   898   0845' 4E 65 77 65         DEFB    'Newer',0
   899   084B' 18 16'              JR      DATEX

   901   084D' CD 0000#    OLDER:  CALL    EPRINT
   902   0850' 4F 6C 64 65         DEFB    'Older',0
   903   0856' 18 0B'              JR      DATEX

   905   0858' CD 0000#    UNDAT:  CALL    EPRINT
   906   085B' 55 6E 64 61         DEFB    'Undated',0
   907   0863' D1          DATEX:  POP     DE              ; Restore FCB

   909   0864' 3A 0035"    FFND:   LD      A,(ROFLG)
   910   0867' B7                  OR      A               ; Was file R/O
   911   0868' 28 08'              JR      Z,NORO          ; Jump if not
   912   086A' CD 0000#            CALL    EPRINT
   913   086D' 20 52 2F 4F         DEFB    ' R/O',0
   914   0872' 21 0007     NORO:   LD      HL,7            ; Offset to PUBlic/Path bit
   915   0875' 19                  ADD     HL,DE
   916   0876' CB7E                BIT     7,(HL)          ; Was it found via Public or Path?
   917   0878' 28 0D'              JR      Z,NOTPUB        ; ..jump if not
   918   087A' CD 0000#            CALL    EPRINT          ; Else print additional prompt
   919   087D' 20 28 50 75         DEFB    ' (Public)',0
   920   0887' 3A 0039"    NOTPUB: LD      A,(NOREPL)      ; Are we in a No Replacement mode?
   921   088A' B7                  OR      A
   922   088B' 28 0C'              JR      Z,FFND0         ; Jump if not
   923   088D' CD 0000#            CALL    EPRINT
   924   0890' 20 43 61 6E         DEFB    ' Can''t!',0
   925   0898' C9                  RET                     ; Return with no action (no replace)

   927   0899' 3A 0036"    FFND0:  LD      A,(RPQFLG)      ; Do we need to propt user?
   928   089C' B7                  OR      A
   929   089D' 28 19'              JR      Z,EAT1          ; Jump if not to copy
   930   089F' CD 0000#            CALL    EPRINT
   931   08A2' 20 28 59 2F         DEFB    ' (Y/[N])? ',0
   932   08AD' CD 0BC3'            CALL    GETCH           ; Get response
   933   08B0' FE 0D               CP      CR              ; Yes?
   934   08B2' C4 0000#            CALL    NZ,COUT         ; ..echo if Not CR
   935   08B5' FE 59               CP      'Y'             ; Is it an explicit Yes?
   936   08B7' C0                  RET     NZ              ; ..return if no replace

   938   08B8' 3A 0035"    EAT1:   LD      A,(ROFLG)       ; Is this an R/O file?
   939   08BB' B7                  OR      A
   940   08BC' 28 09'              JR      Z,EAT1A         ; No need to set attributes if not
   941   08BE' 21 0009             LD      HL,9            ; Offset to R/O attribute
   942   08C1' 19                  ADD     HL,DE
   943   08C2' CBBE                RES     7,(HL)
   944   08C4' CD 0982'            CALL    DOATTR          ; Make file R/W
   945   08C7' CD 0000#    EAT1A:  CALL    F$DELETE        ; ..and delete it
   946   08CA' CD 0000#    FNF:    CALL    EPRINT
   947   08CD' 2E 2E 00            DEFB    '..',0
   948   08D0' 3E FF               LD      A,0FFH          ; Set copy of last file
   949   08D2' 32 002F"            LD      (LSTCPY),A      ; Set flag
   950   08D5' 32 0061"            LD      (REPLCK),A      ; ..and another to show No Replacement Abort
   951   08D8' CD 0000#            CALL    INITFCB         ; Insure clean FCB
   952   08DB' CD 0000#            CALL    F$MAKE          ; Create new file
ZMAC Relocating Macro Assembler v 1.7,                       page   18
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   953   08DE' 3C                  INC     A               ; Check for full directory
   954   08DF' CA 0A0E'            JP      Z,DIRFUL        ; Report it

   956                     ; Open Source File in prep for Copy

   958   08E2' CD 0000#            CALL    CRC3CLR         ; Clear CRC value in case we're verifying
   959   08E5' CD 0B86'            CALL    SETSR0          ; Log Source, Initialize & Set FCB
   960   08E8' CD 0000#            CALL    F$OPEN          ; Open file

   962                     ; This loop, which starts at MCPYX, Copies the file from Source to Dest

   964   08EB' CD 0B92'    MCPYX:  CALL    SETSRC          ; Log Source & Set Src FCB
   965   08EE' 2A 0019"            LD      HL,(WORKBF)     ; Pt to buffer to copy into
   966   08F1' CD 0A24'            CALL    LOAD            ; Load file into workbf
   967   08F4' 3A 0031"            LD      A,(BCNT)        ; If count=0, then done
   968   08F7' B7                  OR      A
   969   08F8' 28 27'              JR      Z,MC2DONE

   971                     ; Copy to Disk

   973   08FA' CD 0BA7'            CALL    LOGD            ; Log in destination
   974   08FD' 2A 0019"            LD      HL,(WORKBF)     ; Pt to buffer
   975   0900' CD 0000#    MCPYD1: CALL    SETDMA          ; Set dma address pted to by HL
   976   0903' 11 0080             LD      DE,128          ; Incr HL by 128
   977   0906' 19                  ADD     HL,DE           ; HL pts to next block
   978   0907' ED5B 002C"          LD      DE,(FCBD)       ; Write to destination file
   979   090B' CD 0000#            CALL    F$WRITE
   980   090E' B7                  OR      A               ; Ok?
   981   090F' C2 09DC'            JP      NZ,MCPYDERR

   983                     ; Count down to next block

   985   0912' 3A 0031"            LD      A,(BCNT)        ; Get block count
   986   0915' 3D                  DEC     A               ; Count down
   987   0916' 32 0031"            LD      (BCNT),A
   988   0919' 20 E5'              JR      NZ,MCPYD1
   989   091B' 3A 0032"            LD      A,(CONT)        ; Continue?
   990   091E' B7                  OR      A               ; Cont if not zero
   991   091F' 20 CA'              JR      NZ,MCPYX

   993                     ; End of Copy Loop

   995   0921' CD 0B92'    MC2DONE: CALL   SETSRC          ; Log source & Set FCB
   996   0924' CD 0000#            CALL    F$CLOSE

   998   0927' CD 0BA3'            CALL    SETDST          ; Log Dest & Set FCB
   999   092A' CD 0000#            CALL    F$CLOSE

  1001   092D' D5                  PUSH    DE
  1002   092E' 21 003B"            LD      HL,TMPTIM       ; Set Addr for Date & Time
  1003   0931' CD 0000#            CALL    RCLOCK          ; Attempt a clock read
  1004   0934' 20 10'              JR      NZ,NOCLOK       ; ..jump if not good read

  1006   0936' 2A 0041"            LD      HL,(SRCTD)      ; Set source TD
  1007   0939' 11 0005             LD      DE,5            ; ..offset to Last Access
  1008   093C' 19                  ADD     HL,DE
ZMAC Relocating Macro Assembler v 1.7,                       page   19
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1009   093D' EB                  EX      DE,HL           ; Put in DE reg for dest
  1010   093E' 21 003B"            LD      HL,TMPTIM       ; Point to source tim & dat
  1011   0941' 01 0005             LD      BC,5            ; Move 5 bytes
  1012   0944' EDB0                LDIR
  1013   0946' D1          NOCLOK: POP     DE
  1014   0947' D5                  PUSH    DE              ; ..save pointer for attr set
  1015   0948' CD 0000#            CALL    INITFCB         ; Initialize FCB to start
  1016   094B' 2A 0041"            LD      HL,(SRCTD)      ; Get addr of New file's Stamp
  1017   094E' CD 0CB3'            CALL    PUTSTMP         ; Attempt Put Stamp to Disk
  1018   0951' CD 0000#            CALL    CRC3DONE        ; Get CRC value in case Verifying
  1019   0954' 22 0028"            LD      (CRCVAL),HL     ; Save CRC value or junk if Not Verifying
  1020                                             ;..fall thru, set Attr of Dest to those of Source
  1021   0957' ED5B 002A"          LD      DE,(FCBS)       ; Source FCB contains orig attributes
  1022   095B' 13                  INC     DE              ; Point to 1st attr
  1023   095C' 2A 002C"            LD      HL,(FCBD)       ; Get destination FCB
  1024   095F' 23                  INC     HL              ; ..and pt to 1st attr
  1025   0960' 0E 00               LD      C,0             ; Clear C. Will have count of attributes set
  1026   0962' CD 098A'            CALL    CKATTR          ; Check/Set 1st attr
  1027   0965' 13                  INC     DE              ; Go to Attr F3
  1028   0966' 23                  INC     HL
  1029   0967' 06 08               LD      B,8             ; Do 8 and end at Archive
  1030   0969' CD 098A'    CKATTL: CALL    CKATTR          ; Do a bit/byte
  1031   096C' 10 FB'              DJNZ    CKATTL          ; ..and loop til done
  1032   096E' D1                  POP     DE              ; ...restore FCB pointer
  1033   096F' 79                  LD      A,C             ; Any Attributes Set?
  1034   0970' B7                  OR      A
  1035   0971' C4 0982'            CALL    NZ,DOATTR       ; Set the attributes if any need setting
  1036   0974' 3A 0021"            LD      A,(ARCHIV)      ; Are we in Archiving Mode?
  1037   0977' B7                  OR      A
  1038   0978' C8                  RET     Z               ; ..return if not
  1039   0979' CD 0B92'            CALL    SETSRC          ; Log source & Set FCB
  1040   097C' 21 000B             LD      HL,11           ; Else offset to Archive Bit
  1041   097F' 19                  ADD     HL,DE
  1042   0980' CBFE                SET     7,(HL)          ; ..and Show that it has been Archived
  1043   0982' CD 0000#    DOATTR: CALL    INITFCB         ; Init FCB pted to by DE
  1044   0985' 0E 1E               LD      C,30            ; Set file attributes
  1045   0987' C3 0000#            JP      BDOS            ; MCOPYX returns to caller via BDOS

  1047                     ; Little routine to help with attribute setting

  1049   098A' 1A          CKATTR: LD      A,(DE)          ; Get source byte
  1050   098B' 17                  RLA                     ; ..and test attr
  1051   098C' 30 03'              JR      NC,CKATT0       ; Jump if not set
  1052   098E' CBFE                SET     7,(HL)          ; ..else set dest attr
  1053   0990' 0C                  INC     C               ; ..and count it
  1054   0991' 13          CKATT0: INC     DE              ; Advance to next byte
  1055   0992' 23                  INC     HL
  1056   0993' C9                  RET

  1058                     ;.....
  1059                     ; Check validity of Mod/Create dates
  1060                     ; Enter: HL --> Create Date in std datespec
  1061                     ; Exit : HL --> Valid Mod/Create date field, or Create field if invalid
  1062                     ;        AF = A=0, Zero flag set (Z) if invalid
  1063                     ;               A <> 0, Zero Flag Clear (NZ) if date valid

ZMAC Relocating Macro Assembler v 1.7,                       page   20
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1065   0994' D5          CHKDAT: PUSH    DE              ; Preserve other regs
  1066   0995' EB                  EX      DE,HL           ; Put Create date addr in DE
  1067   0996' 21 000A             LD      HL,10           ; Set offset to Modify field
  1068   0999' 19                  ADD     HL,DE           ; ..and offset to Modify Date
  1069   099A' 7E                  LD      A,(HL)          ; Is it valid?
  1070   099B' 23                  INC     HL
  1071   099C' B6                  OR      (HL)            ; Or Year and Month
  1072   099D' 2B                  DEC     HL              ; ..back up to Year
  1073   099E' 20 05'              JR      NZ,CHKDA0       ; Jump if Date valid
  1074   09A0' EB                  EX      DE,HL           ; ..else put Create date addr in HL
  1075   09A1' 7E                  LD      A,(HL)          ; Check validity
  1076   09A2' 23                  INC     HL
  1077   09A3' B6                  OR      (HL)
  1078   09A4' 2B                  DEC     HL
  1079   09A5' D1          CHKDA0: POP     DE              ; Restore regs
  1080   09A6' C9                  RET                     ; ..with flags set

  1082                     ;.....
  1083                     ; Convert Z3 FCB DU into DU in BC

  1085   09A7' E5          DUCVRT: PUSH    HL              ; Save regs
  1086   09A8' D5                  PUSH    DE
  1087   09A9' 1A                  LD      A,(DE)          ; Get disk
  1088   09AA' B7                  OR      A               ; Current?
  1089   09AB' 20 04'              JR      NZ,DUCV1
  1090   09AD' 3A 0023"            LD      A,(CDISK)       ; Get current
  1091   09B0' 3C                  INC     A               ; Add 1 for a=1
  1092   09B1' 3D          DUCV1:  DEC     A               ; A=0
  1093   09B2' 47                  LD      B,A
  1094   09B3' 21 000D             LD      HL,13           ; Offset to user
  1095   09B6' 19                  ADD     HL,DE
  1096   09B7' 4E                  LD      C,(HL)          ; Get user
  1097   09B8' D1                  POP     DE              ; Restore regs
  1098   09B9' E1                  POP     HL
  1099   09BA' C9                  RET

  1101                     ; Format Error

  1103   09BB' CD 0000#    FORMERR: CALL   EPRINT
  1104   09BE' 0D 0A 20 45         DEFB    CR,LF,' Error: ',0
  1105   09C9' C3 0000#            JP      EPSTR           ; Print error & return

  1107                     ; TPA Overflow

  1109   09CC' CD 0000#    TPAOVFL: CALL   EPRINT
  1110   09CF' 0D 0A 54 50         DEFB    CR,LF,'TPA Ovfl',0
  1111   09DA' 18 2C'              JR      BADCOPY

  1113                     ; Write Error

  1115   09DC' CD 0000#    MCPYDERR: CALL  EPRINT
  1116   09DF' 0D 0A 44 69         DEFB    CR,LF,'Disk Full or Write Error !',0
  1117   09FC' CD 0BA3'            CALL    SETDST          ; Log in Dest & Set FCB
  1118   09FF' CD 0000#            CALL    F$CLOSE         ; ..and close the file
  1119   0A02' CD 0000#            CALL    INITFCB         ; Initialize the FCB
  1120   0A05' CD 0000#            CALL    F$DELETE        ; ...then Kill it
ZMAC Relocating Macro Assembler v 1.7,                       page   21
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1121   0A08' CD 0AAD'    BADCOPY: CALL   SETEFLAG        ; Set ZCPR3 Error flag
  1122   0A0B' C3 04F0'            JP      CPM             ; ..and return to OS

  1124                     ; Directory Full Error

  1126   0A0E' CD 0000#    DIRFUL: CALL    EPRINT
  1127   0A11' 0D 0A 44 69         DEFB    CR,LF,'Directory Full',0
  1128   0A22' 18 E4'              JR      BADCOPY

  1130                     ;.....
  1131                     ; Load Buffer pted to by HL from file whose FCB is pted to by DE
  1132                     ;   On Output, BCNT=Number of blocks loaded (up to 128) and
  1133                     ;   CONT=0 if Done or 128 if Not Done

  1135   0A24' AF          LOAD:   XOR     A               ; A=0
  1136   0A25' 32 0031"            LD      (BCNT),A        ; Set block count
  1137   0A28' 32 0032"            LD      (CONT),A        ; Turn off continuation flag

  1139                     ; Main Copy Loop

  1141   0A2B' CD 0000#    MCPY:   CALL    SETDMA          ; Set DMA to block pted to by HL
  1142   0A2E' CD 0000#            CALL    F$READ          ; ..and Read block
  1143   0A31' B7                  OR      A               ; End of file?
  1144   0A32' C0                  RET     NZ              ; ..return if so
  1145   0A33' 3A 001B"            LD      A,(VERFLG)      ; Doing verify?
  1146   0A36' B7                  OR      A               ; ..set flags
  1147   0A37' 28 0B'              JR      Z,LOAD1         ; ...jump w/no CRC if No ver
  1148   0A39' E5                  PUSH    HL              ; Save ptr to DMA
  1149   0A3A' 06 80               LD      B,128           ; Update CRC for 128 bytes
  1150   0A3C' 7E          MCPYCRC: LD     A,(HL)          ; Get byte
  1151   0A3D' CD 0000#            CALL    CRC3UPD         ; Update CRC
  1152   0A40' 23                  INC     HL              ; Pt to next
  1153   0A41' 10 F9'              DJNZ    MCPYCRC         ; ..Count down and loop til done
  1154   0A43' E1                  POP     HL              ; Retrieve ptr to DMA
  1155   0A44' 01 0080     LOAD1:  LD      BC,128          ; Set # bytes in Sector
  1156   0A47' 09                  ADD     HL,BC           ; ..and pt to nxt log sctr
  1157   0A48' 3A 0031"            LD      A,(BCNT)        ; Get block count
  1158   0A4B' 3C                  INC     A               ; Increment it
  1159   0A4C' 32 0031"            LD      (BCNT),A        ; ..and store
  1160   0A4F' 47                  LD      B,A             ; Block count in B
  1161   0A50' 3A 002E"            LD      A,(PAGLIM)      ; Get page limit (in records)
  1162   0A53' B8                  CP      B               ; Buffer full?
  1163   0A54' 20 D5'              JR      NZ,MCPY         ; ..loop if not
  1164   0A56' 32 0032"            LD      (CONT),A        ; Else set continuation flag
  1165   0A59' C9                  RET

  1167                     ; Verify Phase

  1169   0A5A' 3A 0038"    MCOPYV: LD      A,(QUIET)       ; Check for quiet
  1170   0A5D' B7                  OR      A               ; Nz=quiet
  1171   0A5E' 20 0E'              JR      NZ,MCPYV
  1172   0A60' CD 0000#            CALL    EPRINT
  1173   0A63' 20 20 56 65         DEFB    '  Verify..',0
  1174   0A6E' CD 0000#    MCPYV:  CALL    CRC3CLR         ; Clear crck value
  1175   0A71' CD 0B9C'            CALL    SETDS0          ; Log in Dest, Set FCB & Init
  1176   0A74' CD 0000#            CALL    F$OPEN          ; Open file
ZMAC Relocating Macro Assembler v 1.7,                       page   22
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


  1178                     ; **** Main Verify Loop ****

  1180   0A77' 2A 0019"    VERLOOP: LD     HL,(WORKBF)     ; Load input buffer from destination
  1181   0A7A' ED5B 002C"          LD      DE,(FCBD)
  1182   0A7E' CD 0A24'            CALL    LOAD            ; Load and compute CRC value
  1183   0A81' 3A 0031"            LD      A,(BCNT)        ; Done if no bytes loaded
  1184   0A84' B7                  OR      A
  1185   0A85' 28 06'              JR      Z,VERCRC
  1186   0A87' 3A 0032"            LD      A,(CONT)        ; Continue?
  1187   0A8A' B7                  OR      A               ; 0=no
  1188   0A8B' 20 EA'              JR      NZ,VERLOOP

  1190                     ; Verify Done

  1192   0A8D' CD 0000#    VERCRC: CALL    CRC3DONE        ; Update complete, value in HL
  1193   0A90' ED5B 0028"          LD      DE,(CRCVAL)     ; Get old CRC value into DE
  1194   0A94' AF                  XOR     A               ; Clears carry flag
  1195   0A95' ED52                SBC     HL,DE           ; Compare HL to DE
  1196   0A97' CA 0BC9'            JP      Z,PRDONE        ; Print done msg or fall thru to error msg
  1197                                             ;..else fall thru to Verify Error
  1198   0A9A' 21 0030"            LD      HL,VERCNT       ; Increment error count
  1199   0A9D' 34                  INC     (HL)
  1200   0A9E' CD 0000#            CALL    EPRINT
  1201   0AA1' 20 2E 2E 42         DEFB    ' ..Bad',0
  1202   0AA8' 3E FF               LD      A,0FFH          ; Set flag to show error in Verify
  1203   0AAA' 32 0062"            LD      (CPYERR),A
  1204   0AAD'             SETEFLAG:
  1205   0AAD' 3A 0033"            LD      A,(NOMSGS)      ; Set error flag if there
  1206   0AB0' B7                  OR      A               ; Is a message buffer
  1207   0AB1' C0                  RET     NZ
  1208   0AB2' 2F                  CPL
  1209   0AB3' C3 0000#            JP      PUTER2

  1211                     ; **** MCOPY Utilities ****
  1212                     ;.....
  1213                     ; Allow user to inspect files for Copy
  1214                     ;   First file name pted to by HL, BC = Number of files
  1215                     ;   On Exit, BC = Number of selected files

  1217   0AB6' CD 0000#    INSPF:  CALL    EPRINT
  1218   0AB9' 0D 0A 20 49         DEFB    CR,LF,' Inspect -- '
  1219   0AC7' 59 65 73 2C         DEFB    'Yes, No (def), Skip Rest',0
  1220   0AE0' E5                  PUSH    HL              ; Save ptr to first file
  1221   0AE1' C5                  PUSH    BC              ; Save file count
  1222   0AE2' 11 001F             LD      DE,ESIZE        ; Entries are esize bytes apart
  1223   0AE5' CBBE        INSPF0: RES     7,(HL)          ; Clear MSB to mark file for no copy
  1224   0AE7' 19                  ADD     HL,DE           ; Pt to next
  1225   0AE8' 0B                  DEC     BC              ; Count down
  1226   0AE9' 78                  LD      A,B             ; Done?
  1227   0AEA' B1                  OR      C
  1228   0AEB' 20 F8'              JR      NZ,INSPF0
  1229   0AED' C1                  POP     BC              ; Restore and save again
  1230   0AEE' E1                  POP     HL
  1231   0AEF' E5                  PUSH    HL
  1232   0AF0' C5                  PUSH    BC
ZMAC Relocating Macro Assembler v 1.7,                       page   23
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1233   0AF1' CD 0000#    INSPF1: CALL    CRLF            ; New line
  1234   0AF4' EB                  EX      DE,HL           ; Put FN in DE
  1235   0AF5' 13                  INC     DE              ; ..and point to Name
  1236   0AF6' CD 0000#            CALL    PFN1            ; Print it
  1237   0AF9' 1B                  DEC     DE              ; Re-align ptr to file entry
  1238   0AFA' EB                  EX      DE,HL           ; Restore regs
  1239   0AFB' CD 0000#            CALL    EPRINT
  1240   0AFE' 20 2D 20 28         DEFB    ' - (Y/N/S)? ',0
  1241   0B0B' CD 0BC3'            CALL    GETCH           ; Get response
  1242   0B0E' CD 0000#            CALL    COUT            ; Echo
  1243   0B11' FE 53               CP      'S'             ; Skip?
  1244   0B13' 28 0F'              JR      Z,INSPFA
  1245   0B15' FE 59               CP      'Y'             ; Yes?
  1246   0B17' 20 02'              JR      NZ,INSPF2
  1247   0B19' CBFE                SET     7,(HL)          ; Mark File
  1248   0B1B' 11 001F     INSPF2: LD      DE,ESIZE        ; Pt to next file
  1249   0B1E' 19                  ADD     HL,DE
  1250   0B1F' 0B                  DEC     BC              ; Count down
  1251   0B20' 78                  LD      A,B             ; Done?
  1252   0B21' B1                  OR      C
  1253   0B22' 20 CD'              JR      NZ,INSPF1
  1254   0B24' C1          INSPFA: POP     BC              ; Get count
  1255   0B25' E1                  POP     HL              ; Get ptr to first file
  1256   0B26' C3 0F0A'            JP      DIRPAK          ; Repack directory

  1258                     ;.....
  1259                     ; Select only files which do Not have Archive Bit set
  1260                     ; Enter:HL --> First name in Directory
  1261                     ;       BC = Number of Files
  1262                     ; Exit :BC = New Number of Files
  1263                     ;       HL --> First name in Directory

  1265   0B29' E5          SELARC: PUSH    HL              ; Save values
  1266   0B2A' C5                  PUSH    BC
  1267   0B2B' CBBE        SELAR0: RES     7,(HL)          ; Set initially for No Select
  1268   0B2D' EB                  EX      DE,HL           ; Put file pointer in DE
  1269   0B2E' 21 000B             LD      HL,11           ; ..and offset by Archive Bit
  1270   0B31' 19                  ADD     HL,DE
  1271   0B32' CB7E                BIT     7,(HL)          ; Is it already Archived?
  1272   0B34' 20 04'              JR      NZ,SELAR1       ; ..jump if so to bypass
  1273   0B36' 6B                  LD      L,E             ; Else copy record start to HL
  1274   0B37' 62                  LD      H,D
  1275   0B38' CBFE                SET     7,(HL)          ; ..and select it
  1276   0B3A' 21 001F     SELAR1: LD      HL,ESIZE        ; Offset to Next record
  1277   0B3D' 19                  ADD     HL,DE
  1278   0B3E' 0B                  DEC     BC              ; Decrement count
  1279   0B3F' 78                  LD      A,B             ; Are we out of records?
  1280   0B40' B1                  OR      C
  1281   0B41' 20 E8'              JR      NZ,SELAR0       ; ..loop if Not
  1282   0B43' 18 DF'              JR      INSPFA          ; Else exit by repacking directory

  1284                     ;.....
  1285                     ; Delete files from the directory list in the EXCLUDE list
  1286                     ; Enter:HL --> First name in Directory
  1287                     ;       BC = Number of files
  1288                     ; Exit :BC = New number of files
ZMAC Relocating Macro Assembler v 1.7,                       page   24
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1289                     ;       HL --> First name in Directory

  1291   0B45' E5          CHKXCL: PUSH    HL              ; Save values
  1292   0B46' C5                  PUSH    BC
  1293   0B47' 11 002A'    CHKEX0: LD      DE,EXCLUD       ; Point to Exclude List
  1294   0B4A' CD 0B5D'            CALL    CHKXXX          ; Does it Match?
  1295   0B4D' 28 02'              JR      Z,CHKEX1        ; ..jump if so (no select)
  1296   0B4F' CBFE                SET     7,(HL)          ; Else select it
  1297   0B51' EB          CHKEX1: EX      DE,HL           ; Advance to next entry
  1298   0B52' 21 001F             LD      HL,ESIZE
  1299   0B55' 19                  ADD     HL,DE
  1300   0B56' 0B                  DEC     BC              ; Decrement file count
  1301   0B57' 78                  LD      A,B             ; Are we out of records?
  1302   0B58' B1                  OR      C
  1303   0B59' 20 EC'              JR      NZ,CHKEX0       ; ..loop if not
  1304   0B5B' 18 C7'              JR      INSPFA          ; Else exit by repacking dir

  1306                     ; Check current entry against exclude list

  1308   0B5D' C5          CHKXXX: PUSH    BC              ; Preserve regs
  1309   0B5E' E5                  PUSH    HL
  1310   0B5F' 23          CHKXX0: INC     HL              ; Step by User #
  1311   0B60' 06 0B               LD      B,11            ; Compare FN and FT
  1312   0B62' 1A                  LD      A,(DE)          ; Any entry here?
  1313   0B63' FE 20               CP      ' '             ; ..not if 1st char is space
  1314   0B65' 28 12'              JR      Z,CHKXX2        ; ...jump if no entry
  1315   0B67' 1A          CHKXX1: LD      A,(DE)          ; ..char by char
  1316   0B68' FE 3F               CP      '?'             ; Accomodate wildcard char
  1317   0B6A' 28 05'              JR      Z,CHKX??        ; ..jump if wild
  1318   0B6C' 96                  SUB     (HL)            ; Else compare to entry char
  1319   0B6D' E6 7F               AND     7FH             ; ...masking MSB
  1320   0B6F' 20 08'              JR      NZ,CHKXX2       ; Jump if not equal
  1321   0B71' 23          CHKX??: INC     HL              ; Bump ptrs
  1322   0B72' 13                  INC     DE
  1323   0B73' 10 F2'              DJNZ    CHKXX1          ; ..loop til all checked
  1324   0B75' AF                  XOR     A               ; Clear A in case "?" at end
  1325   0B76' E1          CHKXX3: POP     HL              ; Restore regs..
  1326   0B77' C1                  POP     BC              ; ..leaving flags set
  1327   0B78' C9                  RET

  1329   0B79' 13          CHKXX2: INC     DE              ; Advance past Exc chars
  1330   0B7A' 10 FD'              DJNZ    CHKXX2          ; ..and loop til done
  1331   0B7C' E1                  POP     HL              ; Restore Dir entry ptr
  1332   0B7D' E5                  PUSH    HL              ; ..keeping it on stack
  1333   0B7E' 1A                  LD      A,(DE)          ; Are we at table end?
  1334   0B7F' B7                  OR      A
  1335   0B80' 20 DD'              JR      NZ,CHKXX0       ; ..check another name if not
  1336   0B82' F6 FF               OR      0FFH            ; Signify no match
  1337   0B84' 18 F0'              JR      CHKXX3          ; Else exit here

  1339                     ;.....
  1340                     ; Log in Source User/Disk

  1342   0B86' ED5B 002A"  SETSR0: LD      DE,(FCBS)       ; Get Source FCB addr
  1343   0B8A' CD 0000#            CALL    INITFCB         ; ..and Initialize it
  1344   0B8D' 3A 0025"            LD      A,(SDRIVE)      ; Load Source drive byte
ZMAC Relocating Macro Assembler v 1.7,                       page   25
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1345   0B90' 3C                  INC     A               ; ..prepared for FCB drive #
  1346   0B91' 12                  LD      (DE),A          ; ...and save
  1347   0B92' ED5B 002A"  SETSRC: LD      DE,(FCBS)       ; Get Source FCB addr again
  1348   0B96' ED4B 0024"  LOGS:   LD      BC,(SUSER)
  1349   0B9A' 18 0F'              JR      LOGDS

  1351                     ;.....
  1352                     ; Log in Destination User/Disk

  1354   0B9C' ED5B 002C"  SETDS0: LD      DE,(FCBD)       ; Get Destination FCB addr
  1355   0BA0' CD 0000#            CALL    INITFCB         ; ..and Initialize it
  1356   0BA3' ED5B 002C"  SETDST: LD      DE,(FCBD)       ; Get Dest FCB addr again
  1357   0BA7' ED4B 0026"  LOGD:   LD      BC,(DUSER)
  1358   0BAB' C3 0000#    LOGDS:  JP      LOGUD

  1360                     ;.....
  1361                     ; Check for Abort from Keyboard

  1363   0BAE' CD 0000#    ABORTCK: CALL   CONDIN          ; Conditional input
  1364   0BB1' C8                  RET     Z
  1365   0BB2' FE 03               CP      CTRLC           ; Abort?
  1366   0BB4' C0                  RET     NZ              ; ..return if not
  1367   0BB5' CD 0000#            CALL    EPRINT          ; Else say we are aborting
  1368   0BB8' 0D 0A 41 62         DEFB    CR,LF,'Abort',0
  1369   0BC0' C3 04F0'            JP      CPM             ; ..and qui

  1371                     ;.....
  1372                     ; Get a character from the keyboard converting to uppercase

  1374   0BC3' CD 0000#    GETCH:  CALL    CIN             ; Get a char
  1375   0BC6' C3 0000#            JP      CAPS            ; Convert to Uppercase and return

  1377                     ;.....
  1378                     ; Print Done Message

  1380   0BC9' 3A 0038"    PRDONE: LD      A,(QUIET)       ; Check for quiet
  1381   0BCC' B7                  OR      A               ; Nz=quiet
  1382   0BCD' C0                  RET     NZ
  1383   0BCE' 3A 002F"            LD      A,(LSTCPY)      ; Last file copied?
  1384   0BD1' B7                  OR      A               ; 0 = no
  1385   0BD2' 20 1A'              JR      NZ,DID
  1386   0BD4' 3A 0039"            LD      A,(NOREPL)      ; Not copied because already there?
  1387   0BD7' B7                  OR      A               ; Nz = yes
  1388   0BD8' C8                  RET     Z
  1389   0BD9' CD 0000#            CALL    EPRINT
  1390   0BDC' 20 41 6C 72         DEFB    ' Already Present',0
  1391   0BED' C9                  RET

  1393   0BEE' CD 0000#    DID:    CALL    EPRINT
  1394   0BF1' 4F 6B 00            DEFB    'Ok',0
  1395   0BF4' C9                  RET

  1397                     ;.....
  1398                     ; Set DMA Address to Default buffer (80H)

  1400   0BF5' 21 0080     DFLTAD: LD      HL,BUFF
ZMAC Relocating Macro Assembler v 1.7,                       page   26
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1401   0BF8' C3 0000#            JP      SETDMA          ; Set it and return

  1403                     ;.....
  1404                     ; Print error on Ambiguous Rename attempt w/secondary utility ID print

  1406   0BFB' CD 0000#    AMBERR: CALL    EPRINT
  1407   0BFE' 0D 0A 43 61         DEFB    CR,LF,'Can''t Rename Ambiguously -- ',0
  1408   0C1D' ED4B 0024"  PRTS2D: LD      BC,(SUSER)      ; Print Source File ID
  1409   0C21' CD 0C48'            CALL    PRNDU           ; Print source DU w/":"
  1410   0C24' ED5B 002A"          LD      DE,(FCBS)       ; Print file spec
  1411   0C28' 13                  INC     DE              ; Pt to file Name
  1412   0C29' CD 0000#            CALL    PFN1            ; ..and print
  1413   0C2C' CD 0000#            CALL    EPRINT
  1414   0C2F' 20 74 6F 20         DEFB    ' to ',0
  1415   0C34' ED4B 0026"          LD      BC,(DUSER)
  1416   0C38' CD 0C48'            CALL    PRNDU           ; Print Dest DU w/":"
  1417   0C3B' 3A 0060"            LD      A,(RENFLG)      ; Are we renaming?
  1418   0C3E' B7                  OR      A
  1419   0C3F' C8                  RET     Z               ; ..return if not
  1420   0C40' ED5B 002C"          LD      DE,(FCBD)       ; Else print Dest file spec
  1421   0C44' 13                  INC     DE              ; Pt to File Name
  1422   0C45' C3 0000#            JP      PFN1            ; ..print and return via Stack

  1424                     ;.....
  1425                     ; PRINT "DU:" from values in BC register

  1427   0C48' 78          PRNDU:  LD      A,B
  1428   0C49' C6 41               ADD     A,'A'
  1429   0C4B' CD 0000#            CALL    COUT
  1430   0C4E' 79                  LD      A,C
  1431   0C4F' CD 0000#            CALL    PAFDC
  1432   0C52' 3E 3A               LD      A,':'
  1433   0C54' C3 0000#            JP      COUT

  1435                     ;.....
  1436                     ; Print actual COMfile name if we can,
  1437                     ; otherwise print "COPY"

  1439   0C57' 3A 000A'    COMNAM: LD      A,(Z3EADR+1)    ; Do we have an environment?
  1440   0C5A' B7                  OR      A
  1441   0C5B' C4 0000#            CALL    NZ,GETEFCB      ; .Get EFCB name if so
  1442   0C5E' 28 0E'              JR      Z,NOEFCB        ; ..Print "COPY" if Not
  1443   0C60' 06 08       PRNNAM: LD      B,8
  1444   0C62' 23          COMNML: INC     HL
  1445   0C63' 7E                  LD      A,(HL)
  1446   0C64' E6 7F               AND     7FH
  1447   0C66' FE 20               CP      ' '
  1448   0C68' C4 0000#            CALL    NZ,COUT
  1449   0C6B' 10 F5'              DJNZ    COMNML
  1450   0C6D' C9                  RET

  1452   0C6E' CD 0000#    NOEFCB: CALL    EPRINT
  1453   0C71' 43 4F 50 59         DEFB    'COPY',0
  1454   0C76' C9                  RET

  1456                     ;.....
ZMAC Relocating Macro Assembler v 1.7,                       page   27
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1457                     ; Scan 11-char string for specified character ("?")
  1458                     ; Enter: HL --> Start of string -1
  1459                     ; Exit :  B = 0
  1460                     ;         A = Count of specified character
  1461                     ; Destroys HL & C.  DE unaffected

  1463   0C77' 3E 3F       SCANQQ: LD      A,'?'           ; Set search for Quest Mrks
  1464   0C79' 23          SCAN11: INC     HL              ; Advance to name field
  1465   0C7A' 01 0B00             LD      BC,11*256+0     ; Counter (B) = 11, (C) = 0
  1466   0C7D' BE          SCAN1A: CP      (HL)            ; Compare a char
  1467   0C7E' 20 01'              JR      NZ,SCAN1B       ; ..jump if not same
  1468   0C80' 0C                  INC     C               ; Else bump found counter
  1469   0C81' 23          SCAN1B: INC     HL              ; ..point to next
  1470   0C82' 10 F9'              DJNZ    SCAN1A          ; Loop til done
  1471   0C84' 79                  LD      A,C             ; Set results in reg
  1472   0C85' B7                  OR      A               ; ..and set flags
  1473   0C86' C9                  RET

  1475                     ;.....
  1476                     ; AI (allegedly intelligent) routine to check for a string
  1477                     ; containing legal option letters ONLY.

  1479   0C87' 7E          OPTQ:   LD      A,(HL)
  1480   0C88' D6 2F               SUB     OPTC            ; Slash is explicit option delim
  1481   0C8A' 20 06'              JR      NZ,NOSLSH       ; If not slash, do char. check
  1482   0C8C' 77                  LD      (HL),A          ; If slash, null it out (A = 0)
  1483   0C8D' 2B                  DEC     HL
  1484   0C8E' 77                  LD      (HL),A          ; Null out leading space
  1485   0C8F' 23                  INC     HL              ; Adjust pointer to options
  1486   0C90' 23                  INC     HL
  1487   0C91' C9                  RET                     ; Return with Z flag

  1489   0C92' 54          NOSLSH: LD      D,H             ; Copy into de
  1490   0C93' 5D                  LD      E,L
  1491   0C94' AF                  XOR     A               ; Search for terminating null
  1492   0C95' 01 000B             LD      BC,OPTLEN       ; Range for search
  1493   0C98' EDB1                CPIR                    ; Do short search
  1494   0C9A' 28 02'              JR      Z,DOOPTQ        ; Found null, proceed
  1495   0C9C' EB                  EX      DE,HL           ; Otherwise too long for options
  1496   0C9D' C9                  RET                     ; Return with NZ

  1498   0C9E' D5          DOOPTQ: PUSH    DE
  1499   0C9F' 1B                  DEC     DE
  1500   0CA0' 13          BLOOP:  INC     DE
  1501   0CA1' 1A                  LD      A,(DE)
  1502   0CA2' B7                  OR      A
  1503   0CA3' 28 0C'              JR      Z,OQDONE        ; End of string, return with Z
  1504   0CA5' 06 0B               LD      B,OPTLEN
  1505   0CA7' 21 0CD1'            LD      HL,OPTLTR
  1506   0CAA' BE          LLOOP:  CP      (HL)
  1507   0CAB' 28 F3'              JR      Z,BLOOP
  1508   0CAD' 23                  INC     HL
  1509   0CAE' 10 FA'              DJNZ    LLOOP           ; If B ticks down, a failure!
  1510   0CB0' 05                  DEC     B               ; Cheap NZ return

  1512   0CB1' E1          OQDONE: POP     HL
ZMAC Relocating Macro Assembler v 1.7,                       page   28
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1513   0CB2' C9                  RET

  1515                     ;.....
  1516                     ; Consolidated vectors to Get and Put stamps with Error Detection

  1518   0CB3' CD 0000#    PUTSTMP: CALL   PSTAMP          ; Attempt Put Stamp to Disk
  1519   0CB6' 18 03'              JR      GETST0          ; ..and vector down to Error stuff

  1521   0CB8' CD 0000#    GETSTMP: CALL   GSTAMP          ; Try to Get File Stamp
  1522   0CBB' C0          GETST0: RET     NZ              ; ..return if Good
  1523   0CBC' 32 003A"            LD      (DSFLAG),A      ; Else disable stamping w/0 in A
  1524   0CBF' C9                  RET                     ; ..and return

  1526                     ;.....
  1527                     ; Get base of Lowest Operating System component (CCP or RSX) which
  1528                     ; is the Top of memory usable for a copy buffer.

  1530   0CC0' E5          GETTOP: PUSH    HL              ; Save HL around this call
  1531   0CC1' 2A 0009'            LD      HL,(Z3EADR)     ; Get Z3 environment (if any)
  1532   0CC4' 7D                  LD      A,L
  1533   0CC5' B4                  OR      H
  1534   0CC6' F5                  PUSH    AF              ; Save flag state
  1535   0CC7' C4 0000#            CALL    NZ,GZMTOP       ; .check extended ENV if in Z-System
  1536   0CCA' F1                  POP     AF
  1537   0CCB' CC 0000#            CALL    Z,GETMTOP       ; ..else calculate base/rsx
  1538   0CCE' 7C                  LD      A,H             ; Get returned Page for exit
  1539   0CCF' E1                  POP     HL              ; .restore regs
  1540   0CD0' C9                  RET                     ; ..and back

  1542                     ;.....
  1543                     ; Text and character variables

  1545   0CD1' 41 45 49 4D OPTLTR: DEFB    'AEIMNOQRSVX'   ; Added 'R' and 'X'
  1546   0CDC'             OPTLST: DEFS    0
  1547         = 000B      OPTLEN  EQU     OPTLST-OPTLTR

  1549                     ; Various message suffixes

  1551   0CDC' 65 20 00    SUFFX1: DEFB    'e ',0
  1552   0CDF' 69 6E 67 20 SUFFX2: DEFB    'ing ',0

  1554                     ;====================================================================
  1555                     ; Extracted from DDIRQ routine in DSLIB, which is based on SDIRQ.Z80
  1556                     ;  Ver 1.5 (Syslib) by Richard Conn.            Harold F. Bower
  1557                     ;====================================================================
  1558                     ; Entry: HL - Points to Memory Buffer
  1559                     ;        DE - Points to FCB for selection (36 bytes)
  1560                     ; Exit :  A <> 0, Zero Flag Clear (NZ) if Ok
  1561                     ;             A = 0 and Zero flag Set (Z) if TPA Overflow
  1562                     ;        HL - Points to first file in Buffer
  1563                     ;        BC - Contains number of files in Buffer
  1564                     ; Special Requirements: DMA address set to default of 80H.
  1565                     ;====================================================================

  1567   0CE4' D5          DDIRQ:  PUSH    DE              ; Save ptr to FCB
  1568   0CE5' 22 0005"            LD      (TFCB),HL       ; Set ptr to temp FCB
ZMAC Relocating Macro Assembler v 1.7,                       page   29
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1569   0CE8' 3A 001E'            LD      A,(TYPDAT)      ; Get DS Flag
  1570   0CEB' B7                  OR      A               ; Going for DateStamper Stamps?
  1571   0CEC' 28 14'              JR      Z,DDIRV0        ; ..jump if P2Dos type
  1572   0CEE' E5                  PUSH    HL              ; Save regs while we test for DS Routines
  1573   0CEF' D5                  PUSH    DE
  1574   0CF0' F5                  PUSH    AF              ; ..including flag byte in A
  1575   0CF1' CD 0000#            CALL    FINDCK          ; Is DateStaper alive and well?
  1576   0CF4' 28 08'              JR      Z,NODS          ; ..jump to P2D if not
  1577   0CF6' CD 0000#            CALL    CKTDF           ; Do we have a valid !!!TIME&.DAT file?
  1578   0CF9' 28 03'              JR      Z,NODS          ; ..jump to MS/P2D if not
  1579   0CFB' F1                  POP     AF              ; Else we have everything ready for DS, Do it
  1580   0CFC' 18 02'              JR      DSOK            ; ..bypass defaulting to P2D and continue

  1582   0CFE' F1          NODS:   POP     AF              ; Restore flag byte
  1583   0CFF' AF                  XOR     A               ; ..Clear since No DS
  1584   0D00' D1          DSOK:   POP     DE              ; Restore rest of regs
  1585   0D01' E1                  POP     HL
  1586   0D02' 32 0004"    DDIRV0: LD      (S2FLG),A       ; ..and save
  1587   0D05' 01 0024             LD      BC,36           ; Offset to after FCB
  1588   0D08' 09                  ADD     HL,BC           ; ..useable memory now starts at (HL)
  1589   0D09' CD 0000#            CALL    DPARAMS         ; Set parameters to logged disk

  1591                     ; Set values in the Sort Selection Block

  1593   0D0C' EB                  EX      DE,HL           ; Save in DE while we set up SSB
  1594   0D0D' 2A 0000#            LD      HL,(DIRMAX)     ; Get Max Number of DIR entries
  1595   0D10' 22 0009"            LD      (FCOUNT),HL     ; ..save in SSB
  1596   0D13' 21 001F             LD      HL,ESIZE        ; Get size of records
  1597   0D16' 22 000B"            LD      (ELSIZ),HL      ; ..save in SSB
  1598   0D19' 21 0000             LD      HL,0            ; Let SSBINIT set buffer addr
  1599   0D1C' 22 0007"            LD      (DSTART),HL
  1600   0D1F' 2D                  DEC     L               ; (0-->FF) Use pointers for sorting, Re-Order
  1601   0D20' 22 0011"            LD      (PTRFLG),HL     ; ..place in POINTR (L) and NOREC (H) in SSB
  1602   0D23' 21 0EBF'            LD      HL,DICOMP       ; Address User Compare routine
  1603   0D26' 22 000D"            LD      (COMPIT),HL     ; ..place addr in SSB
  1604   0D29' EB                  EX      DE,HL           ; Put Memory base back in HL
  1605   0D2A' 11 0007"            LD      DE,SSB          ; .point to SSB
  1606   0D2D' CD 0000#            CALL    SSBINIT         ; ..and Initialize the sort routine
  1607   0D30' 22 0000#            LD      (DIRBUF),HL     ; Save returned Record Buffer Address
  1608   0D33' D1                  POP     DE              ; Get ptr to FCB
  1609   0D34' C4 0D48'            CALL    NZ,DIRLOAD      ; Load directory w/o sizing info (if space)
  1610   0D37' C8                  RET     Z               ; Abort if TPA overflow
  1611   0D38' 11 0007"            LD      DE,SSB          ; Set parm for Sort routine
  1612   0D3B' CD 0000#            CALL    SORT            ; ..and do it!
  1613   0D3E' 2A 0007"            LD      HL,(DSTART)     ; .and load exit parms
  1614   0D41' ED4B 0009"          LD      BC,(FCOUNT)
  1615   0D45' F6 FF               OR      0FFH            ; Set Ok status and return
  1616   0D47' C9                  RET


  1619                     ; Build Directory Table at DIRBUF
  1620                     ;   This is the optimal Directory Load Routine; It only loads unique file names
  1621                     ; from disk, but the information is not sufficient to compute the file sizes
  1622                     ;
  1623                     ; On Input : HL pts to Directory Buffer (ESIZE x N Max)
  1624                     ;            DE pts to FCB (Only 12 bytes needed)
ZMAC Relocating Macro Assembler v 1.7,                       page   30
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1625                     ; On Output: BC is Number of Files
  1626                     ;            A = 0 and Zero Flag set if TPA Overflow

  1628   0D48' 22 0007"    DIRLOAD: LD     (DSTART),HL     ; Set start of Buffer area
  1629   0D4B' 13                  INC     DE              ; Pt to file name
  1630   0D4C' 2A 0005"            LD      HL,(TFCB)       ; Pt to TFCB
  1631   0D4F' AF                  XOR     A               ; Else set for current user
  1632   0D50' 77                  LD      (HL),A          ; Stash User Selects
  1633   0D51' 23                  INC     HL              ; Pt to File Name in TFCB
  1634   0D52' 01 000B             LD      BC,11           ; 11 Chars
  1635   0D55' EB                  EX      DE,HL
  1636   0D56' EDB0                LDIR                    ; Copy the Name and Type
  1637   0D58' EB                  EX      DE,HL
  1638                             
  1639   0D59' 06 18               LD      B,24            ; 24 chars (Incl Zero EX)
  1640   0D5B' AF                  XOR     A               ; Zero rest of TFCB

  1642   0D5C' 77          DLLOOP1: LD     (HL),A          ; Store Zero
  1643   0D5D' 23                  INC     HL              ; Pt to next
  1644   0D5E' 10 FC'              DJNZ    DLLOOP1         ; Count down

  1646   0D60' 6F                  LD      L,A             ; Initialize counters (A has null)
  1647   0D61' 67                  LD      H,A
  1648   0D62' 22 0009"            LD      (FCOUNT),HL     ; Total Files on Disk = 0

  1650                     ; Begin by setting default DMA address to 80H

  1652   0D65' 11 0080             LD      DE,BUFF         ; Set DMA address to default
  1653   0D68' 0E 1A               LD      C,SDMA
  1654   0D6A' CD 0005             CALL    BDOSE

  1656                     ; Now we begin scanning for files to place into the memory buffer

  1658   0D6D' 0E 11               LD      C,SRCHF         ; Search for file
  1659   0D6F' 18 07'              JR      DIRLP1

  1661   0D71' CD 0DE4'    DIRLP:  CALL    PENTRY          ; Place entry in Dir
  1662   0D74' 28 69'              JR      Z,DIRDNX        ; Memory Overflow Error
  1663   0D76' 0E 12               LD      C,SRCHN         ; Search for Next match
  1664   0D78' ED5B 0005"  DIRLP1: LD      DE,(TFCB)       ; Pt to FCB
  1665   0D7C' CD 0000#            CALL    FSTNXT
  1666   0D7F' FE FF               CP      255             ; Done?
  1667   0D81' 20 EE'              JR      NZ,DIRLP

  1669   0D83' 3A 0004"            LD      A,(S2FLG)       ; Loading P2D/NZTIME Stamps?
  1670   0D86' B7                  OR      A
  1671   0D87' 28 54'              JR      Z,DIRPDN        ; ..jump to exit if so

  1673                     ; We are using DateStamper stamps, so append stamps to FN.FT string

  1675   0D89' AF                  XOR     A               ; Open T&D for Read-only
  1676   0D8A' CD 0000#            CALL    OPENTD          ; ..don't check errs cause CKTD was Ok
  1677   0D8D' ED4B 0009"          LD      BC,(FCOUNT)     ; Load this many records
  1678   0D91' 2A 0007"            LD      HL,(DSTART)     ; ..starting with this entry
  1679   0D94' 11 FFFF             LD      DE,0FFFFH       ; Set dummy Random record # to force read

ZMAC Relocating Macro Assembler v 1.7,                       page   31
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1681   0D97' 78          TDLOOP: LD      A,B             ; Are we done?
  1682   0D98' B1                  OR      C
  1683   0D99' 28 3F'              JR      Z,DIRDDN        ; ..exit if so
  1684   0D9B' C5                  PUSH    BC              ; Save count
  1685   0D9C' 01 0010             LD      BC,FNSIZE       ; Offset to RR #
  1686   0D9F' 09                  ADD     HL,BC
  1687   0DA0' 7E                  LD      A,(HL)          ; Get Index #
  1688   0DA1' E5                  PUSH    HL              ; Save index to entry TD Field
  1689   0DA2' F5                  PUSH    AF              ; ..and index
  1690   0DA3' 23                  INC     HL
  1691   0DA4' 7E                  LD      A,(HL)          ; Get RR # to HL
  1692   0DA5' 23                  INC     HL
  1693   0DA6' 66                  LD      H,(HL)
  1694   0DA7' 6F                  LD      L,A
  1695   0DA8' B7                  OR      A               ; Compare current (DE) w/desired (HL)
  1696   0DA9' ED52                SBC     HL,DE
  1697   0DAB' 19                  ADD     HL,DE
  1698   0DAC' 28 12'              JR      Z,SAMREC        ; ..jump if we already have the record
  1699   0DAE' EB                  EX      DE,HL           ; Else put rec in DE
  1700   0DAF' D5                  PUSH    DE              ; ..and save
  1701   0DB0' AF                  XOR     A
  1702   0DB1' CD 0000#            CALL    RWTD            ; Read the T&D file ignoring errors
  1703   0DB4' 22 0013"            LD      (TDBUF),HL      ; Save TD buffer start addr
  1704   0DB7' 20 06'              JR      NZ,TDRDOK       ; ..jump if T&D File Read Ok
  1705   0DB9' 06 80               LD      B,128           ; Else Null record (A already = 0)
  1706   0DBB' 77          TDNULL: LD      (HL),A
  1707   0DBC' 23                  INC     HL
  1708   0DBD' 10 FC'              DJNZ    TDNULL          ; Loop til sector filled
  1709   0DBF' D1          TDRDOK: POP     DE              ; ..and restore RR #
  1710   0DC0' F1          SAMREC: POP     AF              ; Restore record Index
  1711   0DC1' 87                  ADD     A,A             ; ..and mult by 16 to get relative addr
  1712   0DC2' 87                  ADD     A,A
  1713   0DC3' 87                  ADD     A,A
  1714   0DC4' 87                  ADD     A,A
  1715   0DC5' 4F                  LD      C,A
  1716   0DC6' 06 00               LD      B,0
  1717   0DC8' 2A 0013"            LD      HL,(TDBUF)
  1718   0DCB' 09                  ADD     HL,BC           ; HL Now points at source T&D string in Buffer
  1719   0DCC' EB                  EX      DE,HL           ; Swap regs..
  1720   0DCD' E3                  EX      (SP),HL         ; ..to put RR # on stack, DEst adr in HL
  1721   0DCE' EB                  EX      DE,HL           ; ...then Dest in DE, source in HL
  1722   0DCF' 01 000F             LD      BC,15           ; Move all three stamps
  1723   0DD2' EDB0                LDIR
  1724   0DD4' EB                  EX      DE,HL           ; HL --> Next Dir entry
  1725   0DD5' D1                  POP     DE              ; DE = RR # in Buff
  1726   0DD6' C1                  POP     BC              ; BC = Count
  1727   0DD7' 0B                  DEC     BC
  1728   0DD8' 18 BD'              JR      TDLOOP          ; ..and loop til done

  1730                     ; Now we are done with the Load -- Set up Return Values

  1732   0DDA' CD 0000#    DIRDDN: CALL    CLOSTD          ; Close the T&D tile for safety
  1733   0DDD' F6 FF       DIRPDN: OR      0FFH            ; Set Flags NZ for Load Ok
  1734   0DDF' ED4B 0009"  DIRDNX: LD      BC,(FCOUNT)     ; Get total number of files in BC
  1735   0DE3' C9                  RET

ZMAC Relocating Macro Assembler v 1.7,                       page   32
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


  1738                     ; PENTRY -- Place entry in Directory Buffer if not an erased entry

  1740                     ; On Input:  A = 0-3 for Adr index in Buff of Entry FCB
  1741                     ;            FCOUNT = Number of files in Dir so far
  1742                     ; On Output: FCOUNT = Number of files in dir so far
  1743                     ;            A = 0 and Zero Flag Set if Memory Overflow Error

  1745   0DE4' 32 0003"    PENTRY: LD      (INDX),A        ; Save index in case of P2Dos Stamp load
  1746   0DE7' D5                  PUSH    DE              ; Save any DS Indices
  1747   0DE8' C5                  PUSH    BC
  1748   0DE9' 0F                  RRCA                    ; Multiply by 32 for Offset computation
  1749   0DEA' 0F                  RRCA
  1750   0DEB' 0F                  RRCA
  1751                     ;;      AND     60H             ; A = Byte Offset
  1752   0DEC' 11 0080             LD      DE,BUFF         ; Pt to Buffer Entry
  1753   0DEF' 6F                  LD      L,A             ; Let HL = Offset
  1754   0DF0' 26 00               LD      H,0
  1755   0DF2' 19                  ADD     HL,DE           ; HL = Ptr to FCB

  1757   0DF3' 7E                  LD      A,(HL)
  1758   0DF4' FE 20               CP      20H             ; Is it CP/M Plus Volume or T&D?
  1759   0DF6' D2 0E81'            JP      NC,PEDONE       ; ..jump if so

  1761                     ; HL = Adr of FCB in BUFF.  Check for attributes of file

  1763   0DF9' E5                  PUSH    HL              ; Save ptr
  1764   0DFA' 01 000A             LD      BC,10           ; Pt to System Attribute
  1765   0DFD' 09                  ADD     HL,BC
  1766   0DFE' CB7E                BIT     7,(HL)          ; Check for System Attribute
  1767   0E00' E1                  POP     HL              ; Restore ptr
  1768   0E01' 28 06'              JR      Z,ATDIR         ; ..jump if Not System File (Selflg in A)
  1769   0E03' 3A 001D"            LD      A,(SYSEXC)
  1770   0E06' B7                  OR      A               ; Are we including SYStem Files?
  1771   0E07' 20 78'              JR      NZ,PEDONE       ; ..jump if Not
  1772                                             ;..Else fall thru to continue

  1774                     ; Increment total number of files

  1776   0E09' ED5B 0009"  ATDIR:  LD      DE,(FCOUNT)     ; Total Files = Total Files + 1
  1777   0E0D' 13                  INC     DE
  1778   0E0E' ED53 0009"          LD      (FCOUNT),DE

  1780                     ; Copy FCB pted to by HL into Directory Buffer

  1782   0E12' ED5B 0000#          LD      DE,(DIRBUF)     ; Pt to Next Entry location
  1783   0E16' 01 0010             LD      BC,FNSIZE       ; Number of Bytes/Entry
  1784   0E19' EDB0                LDIR                    ; Copy FCB into Memory Buffer
  1785   0E1B' C1                  POP     BC              ; Restore any DS indices
  1786   0E1C' E1                  POP     HL
  1787   0E1D' 3A 0004"            LD      A,(S2FLG)       ; Which method do we use?
  1788   0E20' B7                  OR      A
  1789   0E21' 28 0C'              JR      Z,USEMS         ; ..jump if using MS/P2Dos/NZTime stamps
  1790   0E23' EB                  EX      DE,HL           ; Put destination in HL
  1791   0E24' 70                  LD      (HL),B          ; Stash index into T&D sector
  1792   0E25' 23                  INC     HL
ZMAC Relocating Macro Assembler v 1.7,                       page   33
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1793   0E26' 73                  LD      (HL),E          ; ..and T&D Sector number
  1794   0E27' 23                  INC     HL
  1795   0E28' 72                  LD      (HL),D
  1796   0E29' 23                  INC     HL
  1797   0E2A' EB                  EX      DE,HL           ; Put Buffer pointer back in DE
  1798   0E2B' 06 0C               LD      B,ESIZE-FNSIZE-3
  1799   0E2D' 18 43'              JR      FILLIT          ; Null out remaining

  1801   0E2F' 21 0090     USEMS:  LD      HL,BUFF+16      ; Point to DosDisk Flag bytes
  1802   0E32' 7E                  LD      A,(HL)          ; Get first byte
  1803   0E33' FE FD               CP      0FDH            ; Is it the MS-DOS 40-byte flag?
  1804   0E35' 20 11'              JR      NZ,USEP2D       ; ..jump if not
  1805   0E37' 23                  INC     HL              ; Else check second byte to be sure
  1806   0E38' 96                  SUB     (HL)
  1807   0E39' 20 0D'              JR      NZ,USEP2D       ; ..jump if no match
  1808   0E3B' 06 0A               LD      B,10            ; Ok, so null Create and Access fields
  1809   0E3D' CD 0EE8'            CALL    NULLIT
  1810   0E40' 21 0096             LD      HL,BUFF+22      ; Point to source MS-DOS DateSpec
  1811   0E43' CD 0000#            CALL    M2UTIM          ; ..and do the conversions to DE
  1812   0E46' 18 2D'              JR      P2DONE          ; Continue with common code

  1814   0E48' 21 00E0     USEP2D: LD      HL,BUFF+60H     ; Point to P2D Time indicator
  1815   0E4B' 7E                  LD      A,(HL)
  1816   0E4C' E6 7F               AND     7FH             ; Mask difference between Z2D and NZTime
  1817   0E4E' FE 21               CP      21H             ; Is there a valid time stamp flag?
  1818   0E50' 20 1E'              JR      NZ,NOTP2D       ; ..jump if not
  1819   0E52' 3A 0003"            LD      A,(INDX)        ; Else calculate offset to correct entry
  1820   0E55' 4F                  LD      C,A
  1821   0E56' 87                  ADD     A,A             ; *2
  1822   0E57' 87                  ADD     A,A             ; *4
  1823   0E58' 81                  ADD     A,C             ; *5
  1824   0E59' 87                  ADD     A,A             ; *10
  1825   0E5A' 3C                  INC     A               ; +1
  1826   0E5B' 4F                  LD      C,A             ; Entries start at offset=1,11,21 decimal
  1827   0E5C' 06 00               LD      B,0
  1828   0E5E' 7E                  LD      A,(HL)          ; Get Flag Byte (A1=NZTime, 21=P2Dos)
  1829   0E5F' 09                  ADD     HL,BC           ; Point to Stamp field for desired entry
  1830   0E60' 17                  RLA                     ; Is it NzTime?
  1831   0E61' 38 23'              JR      C,USENZT        ; ..jump if NZTime Stamping
  1832   0E63' CD 0000#            CALL    P2UTIM          ; ..and parse Create Stamp to Table
  1833   0E66' 06 05               LD      B,5             ; Null the Last Accessed field
  1834   0E68' CD 0EE8'            CALL    NULLIT
  1835   0E6B' CD 0000#            CALL    P2UTIM          ; Parse Modify Stamp
  1836   0E6E' 18 05'              JR      P2DONE          ; ..and continue

  1838   0E70' 06 0F       NOTP2D: LD      B,ESIZE-FNSIZE  ; Set count to fill entire field
  1839   0E72' CD 0EE8'    FILLIT: CALL    NULLIT          ; Fill rest of time with Nulls
  1840   0E75' ED53 0000#  P2DONE: LD      (DIRBUF),DE     ; Set ptr to Next Entry
  1841   0E79' CD 0000#            CALL    GETMTOP         ; Return highest avail addr in HL
  1842   0E7C' 7C                  LD      A,H             ; Get CCP page in A
  1843   0E7D' 3D                  DEC     A               ; ..and back one page in front of it
  1844   0E7E' BA                  CP      D               ; Is ptr to next entry beyond this?
  1845   0E7F' C8                  RET     Z

  1847   0E80' 11                  DEFB    11H             ; Fall thru trashing DE

ZMAC Relocating Macro Assembler v 1.7,                       page   34
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1849                     ; Done with PENTRY and No Error

  1851   0E81' C1          PEDONE: POP     BC              ; Clear the stack
  1852   0E82' D1                  POP     DE
  1853   0E83' F6 FF               OR      0FFH            ; Set NZ for No Error
  1854   0E85' C9                  RET

  1856                     ; Gather File Stamps from NZTime-stamped directory

  1858   0E86' 22 0000"    USENZT: LD      (IPTR),HL       ; Save Pointer to input NZTime stamps
  1859   0E89' 6E                  LD      L,(HL)
  1860   0E8A' 3A 0003"            LD      A,(INDX)        ; Get Index number (0,1,2)
  1861   0E8D' 47                  LD      B,A             ; .save
  1862   0E8E' 3E 08               LD      A,8
  1863   0E90' 90                  SUB     B               ; Compute current byte when starting
  1864   0E91' 4F                  LD      C,A             ;  save
  1865   0E92' 04                  INC     B
  1866   0E93' 05                  DEC     B               ; Is Input byte already aligned?
  1867   0E94' 28 03'              JR      Z,USENZ1        ; ..jump if so
  1868   0E96' 29          USENZ0: ADD     HL,HL           ; Else rotate input byte (H is don't care)
  1869   0E97' 10 FD'              DJNZ    USENZ0          ; ..looping til done
  1870   0E99' 3E 03       USENZ1: LD      A,3             ; Get all three stamps
  1871   0E9B' 32 0002"    USENZ2: LD      (LPCTR),A       ; Set Outer Loop Counter
  1872   0E9E' 06 07               LD      B,7
  1873   0EA0' CD 0EEE'            CALL    GBITS           ; Get Year (7 bits)
  1874   0EA3' 06 04               LD      B,4
  1875   0EA5' CD 0EEE'            CALL    GBITS           ; Month (4 bits)
  1876   0EA8' 06 05               LD      B,5
  1877   0EAA' CD 0EEE'            CALL    GBITS           ; Day (5 bits)
  1878   0EAD' 06 05               LD      B,5
  1879   0EAF' CD 0EEE'            CALL    GBITS           ; Hour (5 bits)
  1880   0EB2' 06 06               LD      B,6
  1881   0EB4' CD 0EEE'            CALL    GBITS           ; Minute (6 bits)
  1882   0EB7' 3A 0002"            LD      A,(LPCTR)
  1883   0EBA' 3D                  DEC     A               ; Have we done all 3 fields?
  1884   0EBB' 20 DE'              JR      NZ,USENZ2       ; .loop if Not (saving new count)
  1885   0EBD' 18 B6'              JR      P2DONE          ; ..jump to exit when finished

  1887                     ;========================================================================
  1888                     ; NAME - DICOMP.  Compare the directory entry pointed to by HL with that
  1889                     ;               addressed by DE.
  1890                     ; Entry: HL - Points to one FCB extracted entry
  1891                     ;        DE - Points to second FCB extracted entry
  1892                     ; Exit :  F - Carry Set (C) means (DE) < (HL)
  1893                     ;               Zero Set (Z) means (DE) = (HL)
  1894                     ;               Non-Zero (NZ) and No Carry (NC) mans (DE) > (HL)
  1895                     ;========================================================================

  1897   0EBF' C5          DICOMP: PUSH    BC              ; Save count
  1898   0EC0' 06 0B               LD      B,11            ; 11 bytes for FN and FT
  1899   0EC2' E5                  PUSH    HL
  1900   0EC3' D5                  PUSH    DE
  1901   0EC4' 23                  INC     HL              ; Pt to FN
  1902   0EC5' 13                  INC     DE
  1903   0EC6' CD 0000#            CALL    @FNCMP          ; Do comparison
  1904   0EC9' D1                  POP     DE
ZMAC Relocating Macro Assembler v 1.7,                       page   35
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1905   0ECA' E1                  POP     HL
  1906   0ECB' 20 19'              JR      NZ,CMPEX
  1907   0ECD' 1A                  LD      A,(DE)          ; Compare User Number
  1908   0ECE' BE                  CP      (HL)
  1909   0ECF' 20 15'              JR      NZ,CMPEX        ; ..exit if No match
  1910   0ED1' E5                  PUSH    HL              ; Else save ptrs
  1911   0ED2' D5                  PUSH    DE
  1912   0ED3' 01 000E             LD      BC,14
  1913   0ED6' EB                  EX      DE,HL           ; Swap
  1914   0ED7' 09                  ADD     HL,BC           ; .offset File 1 to DM
  1915   0ED8' EB                  EX      DE,HL           ; ..swap
  1916   0ED9' 09                  ADD     HL,BC           ; ...offset File 2 to DM
  1917   0EDA' 1A                  LD      A,(DE)
  1918   0EDB' BE                  CP      (HL)            ; Compare Data Modules
  1919   0EDC' 20 06'              JR      NZ,CMPEX0       ; ..jump if Not Same
  1920   0EDE' 2B                  DEC     HL              ; Else back down to EXT
  1921   0EDF' 2B                  DEC     HL
  1922   0EE0' 1B                  DEC     DE
  1923   0EE1' 1B                  DEC     DE
  1924   0EE2' 1A                  LD      A,(DE)          ; Fetch EX file 1
  1925   0EE3' BE                  CP      (HL)            ; ..compare to EX file 2 and return status
  1926   0EE4' D1          CMPEX0: POP     DE              ; Restore regs
  1927   0EE5' E1                  POP     HL
  1928   0EE6' C1          CMPEX:  POP     BC              ; Restore Count
  1929   0EE7' C9                  RET                     ; ..and exit

  1931                     ;.....
  1932                     ; Fill the string addressed by DE with a zero for B bytes

  1934   0EE8' AF          NULLIT: XOR     A               ; Load a cheap Null
  1935   0EE9' 12          NULL0:  LD      (DE),A          ; Stuff a byte
  1936   0EEA' 13                  INC     DE              ; ..and advance
  1937   0EEB' 10 FC'              DJNZ    NULL0           ; Loop til done
  1938   0EED' C9                  RET

  1940                     ;.....
  1941                     ; NZTime Support Routine.  Gather # of bits speced from NZTIM, Return BCD Digit
  1942                     ; ENTER: L = Current working byte
  1943                     ;       DE = Ptr to Dest of Univ stamps
  1944                     ;        C = Bit # currently in position (8..1)
  1945                     ;        B = Number of bits to gather
  1946                     ; EXIT : A = BCD Conversion of # bits from entry

  1948   0EEE' 26 00       GBITS:  LD      H,0             ; Clear Bit Accumulator
  1949   0EF0' 29          GBITS0: ADD     HL,HL           ; Shift B7 of L into B0 of H, H shifts left
  1950   0EF1' 0D                  DEC     C               ; Have we shifted last of input Byte?
  1951   0EF2' 20 0D'              JR      NZ,GBITS1       ; ..jump if Not

  1953   0EF4' E5                  PUSH    HL              ; Else need a byte, save regs
  1954   0EF5' 2A 0000"            LD      HL,(IPTR)       ; Get input ptr
  1955   0EF8' 23                  INC     HL              ; .go to next byte
  1956   0EF9' 7E                  LD      A,(HL)          ; ..fetch
  1957   0EFA' 22 0000"            LD      (IPTR),HL       ; ...save updated ptr
  1958   0EFD' E1                  POP     HL              ; .(restore regs)
  1959   0EFE' 6F                  LD      L,A             ; Place new Input byte for shifting
  1960   0EFF' 0E 08               LD      C,8             ;  and init Bits Remaining counter
ZMAC Relocating Macro Assembler v 1.7,                       page   36
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


  1962   0F01' 10 ED'      GBITS1: DJNZ    GBITS0          ; ..Shift another if not done
  1963   0F03' 7C                  LD      A,H             ; Else get completed output byte
  1964   0F04' CD 0000#            CALL    BIN2BCD         ; .make BCD for Universal
  1965   0F07' 12                  LD      (DE),A          ; ..store in Output
  1966   0F08' 13                  INC     DE              ; ...and advance to next digit
  1967   0F09' C9                  RET

  1969                     ;====================================================================
  1970                     ; Adapted from SDIR09.Z80 Ver 1.5 by Richard Conn to handle larger
  1971                     ; records needed by DSLib "type" routines.                      HFB
  1972                     ;====================================================================
  1973                     ; Entry: HL - Points to a Directory Buffer
  1974                     ;        BC - Contains the total number of files in Buffer
  1975                     ; Exit : BC - Number of Selected files.  Buffer is restructured
  1976                     ; Uses : BC
  1977                     ; Special Requirements: Required side effect is that the Flag
  1978                     ;       Extent (Set by DIR:) be correct.  In most cases, default
  1979                     ;       of 0 is Ok, except when extent size is greater than 16K
  1980                     ;====================================================================

  1982   0F0A' E5          DIRPAK: PUSH    HL              ; Save Regs
  1983   0F0B' D5                  PUSH    DE
  1984   0F0C' F5                  PUSH    AF
  1985   0F0D' C5                  PUSH    BC              ; Save counter
  1986   0F0E' 01 0000             LD      BC,0
  1987   0F11' ED43 0009"          LD      (FCOUNT),BC     ; Init file count
  1988   0F15' 5D                  LD      E,L             ; Copy Buffer start to DE
  1989   0F16' 54                  LD      D,H

  1991   0F17' C1          DPLOOP: POP     BC              ; Get counter
  1992   0F18' 78                  LD      A,B             ; Check for Done
  1993   0F19' B1                  OR      C
  1994   0F1A' 28 1B'              JR      Z,DPDONE
  1995   0F1C' 0B                  DEC     BC              ; Count down
  1996   0F1D' C5                  PUSH    BC              ; Save counter
  1997   0F1E' 01 001F             LD      BC,ESIZE        ; Set number of bytes in entry
  1998   0F21' CB7E                BIT     7,(HL)          ; Does 1st byte indicate file is selected?
  1999   0F23' 28 0F'              JR      Z,DPNEXT        ; ..jump and advance to next if not

  2001                     ; Found Selected Entry

  2003   0F25' CBBE                RES     7,(HL)          ; Clear MSB of selected entry
  2004   0F27' EDB0                LDIR                    ; Copy the entry to current bottom of byffer
  2005   0F29' ED4B 0009"          LD      BC,(FCOUNT)     ; Increment File Count
  2006   0F2D' 03                  INC     BC
  2007   0F2E' ED43 0009"          LD      (FCOUNT),BC
  2008   0F32' 18 E3'              JR      DPLOOP          ; Continue

  2010                     ; Skip to Next Entry

  2012   0F34' 09          DPNEXT: ADD     HL,BC           ; Skip over entry
  2013   0F35' 18 E0'              JR      DPLOOP          ; Continue

  2015                     ; Compression Complete -- Set up returned values

ZMAC Relocating Macro Assembler v 1.7,                       page   37
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  2017   0F37' ED4B 0009"  DPDONE: LD      BC,(FCOUNT)     ; Put File Count in BC
  2018   0F3B' F1                  POP     AF              ; Restore regs
  2019   0F3C' D1                  POP     DE
  2020   0F3D' E1                  POP     HL
  2021   0F3E' C9                  RET

  2023                     ;++++++++++++++++++++++++++++++++++++++++++++++++++++++
  2024                     ;                  D a t a    A r e a
  2025                     ;++++++++++++++++++++++++++++++++++++++++++++++++++++++

  2027                             DSEG

  2029                     ;---- Data Storage/Buffers for DDIRQ Routine ----

  2031   0000" 00 00       IPTR:   DEFS    2               ; Pointer for NZTime conversion
  2032   0002" 00          LPCTR:  DEFS    1               ; Loop Counter for NZTime conversion

  2034   0003" 00          INDX:   DEFS    1               ; Directory index into sector
  2035   0004" 00          S2FLG:  DEFS    1               ; Secondary Select Flag (Sort & Stamp method)
  2036   0005" 00 00       TFCB:   DEFS    2               ; Address of Temporary FCB

  2038   0007"             SSB:                            ;\ Sort Selection Block:
  2039   0007" 00 00       DSTART: DEFS    2               ;| Pointer to first Directory Entry
  2040   0009" 00 00       FCOUNT: DEFS    2               ;| Tot Number of Files/Number of Selected Files
  2041   000B" 00 00       ELSIZ:  DEFS    2               ;| Size of each element
  2042   000D" 00 00       COMPIT: DEFS    2               ;| Addr of compare routine
  2043   000F" 00 00       ORDBUF: DEFS    2               ;| Addr of Order buffer
  2044   0011" 00          PTRFLG: DEFS    1               ;| FF=Use ptrs, 0=No ptrs
  2045   0012" 00                  DEFS    1               ;/ If Ptrflg<>0, FF=No reorder, 0=Reorder

  2047   0013" 00 00       TDBUF:  DEFS    2               ; Temp storage loc'n for T&D Sector Buffer adr

  2049                     ;---- End of Data area used by DDIRQ routine ----
  2050                     ; Pointers

  2052         = 0015"     DATABG  EQU     $
  2053   0015" 00 00       MFPTR:  DEFS    2               ; Ptr to first char of next fn spec
  2054   0017" 00 00       NXTPTR: DEFS    2               ; Ptr to next fn spec in line
  2055   0019" 00 00       WORKBF: DEFS    2               ; Ptr to beginning of work buffer

  2057                     ;   ----- Do Not Change following values -----
  2058   001B"             CPYTBL:                         ; ..flags copied from default table
  2059   001B" 00          VERFLG: DEFS    1               ; Verify
  2060   001C" 00          INSP:   DEFS    1               ; Inspect
  2061   001D" 00          SYSEXC: DEFS    1               ; Exclude system files
  2062   001E" 00          NCOPY:  DEFS    1               ; Multiple copy
  2063   001F" 00          EXIST:  DEFS    1               ; Test for existence flag
  2064   0020" 00          EXRO:   DEFS    1               ; Test for R/O existence flag
  2065   0021" 00          ARCHIV: DEFS    1               ; Archive flag
  2066   0022" 00          REPLAC: DEFS    1               ; Replace flag (Copy if exists)
  2067         = 0008      TBLLEN  EQU     $-CPYTBL
  2068                     ;       ----- End of no change area -----

  2070                     ; Disks and Users

  2072   0023" 00          CDISK:  DEFS    1               ; Current disk
ZMAC Relocating Macro Assembler v 1.7,                       page   38
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  2073   0024" 00          SUSER:  DEFS    1               ; Source user
  2074   0025" 00          SDRIVE: DEFS    1               ; ..Source disk
  2075   0026" 00          DUSER:  DEFS    1               ; Destination user
  2076   0027" 00                  DEFS    1               ; ..Destination disk

  2078                     ; CRC Value

  2080   0028" 00 00       CRCVAL: DEFS    2               ; CRC check value

  2082                     ; FCBS & FCBD

  2084   002A" 00 00       FCBS:   DEFS    2               ; Source FCB
  2085   002C" 00 00       FCBD:   DEFS    2               ; Destination FCB

  2087                     ; Counts and Flags

  2089   002E" 00          PAGLIM: DEFS    1               ; Max number of pages in work buffer
  2090   002F" 00          LSTCPY: DEFS    1               ; Last file was copied flag
  2091   0030" 00          VERCNT: DEFS    1               ; Error count
  2092   0031" 00          BCNT:   DEFS    1               ; Block count
  2093   0032" 00          CONT:   DEFS    1               ; Continue flag (0=no, 0FFH=yes)
  2094   0033" 00          NOMSGS: DEFS    1               ; 0FFH if there is no ZCPR3 message buffer
  2095   0034" 00          NORST:  DEFS    1               ; Disk reset flag (0=do reset)
  2096   0035" 00          ROFLG:  DEFS    1               ; Dest file R/O flag
  2097   0036" 00          RPQFLG: DEFS    1               ; Replace queery flag (0=replace w/o asking)
  2098   0037" 00          XMOVE:  DEFS    1               ; Delete source after copy flag (Move)
  2099   0038" 00          QUIET:  DEFS    1               ; Quiet
  2100   0039" 00          NOREPL: DEFS    1               ; No copy if file already on dest. flag
  2101   003A" 00          DSFLAG: DEFS    1               ; DateStamper active flag
  2102   003B" 00 00 00 00 TMPTIM: DEFS    6               ; Temporary Clock Date/Time buffer
  2103   0041" 00 00 00 00 SRCTD:  DEFS    15              ; Source Time & Date buffer
  2104   0050" 00 00 00 00 DESTTD: DEFS    15              ; Destination Time &Date Buffer
  2105   005F" 00          HAVFIL: DEFS    1               ; Flag to indicate filecount. 0=No Files
  2106   0060" 00          RENFLG: DEFS    1               ; 0 = No rename, <>0 for rename opn
  2107   0061" 00          REPLCK: DEFS    1               ; Flag for Replacement abort (MCOPYX sets)
  2108   0062" 00          CPYERR: DEFS    1               ; 0=No error in Verify, FF=Verify err

  2110                     ; Dynamic Buffers

  2112   0063" 00 00       INLINE:  DEFS   2               ; Input line buffer
  2113   0065" 00 00       FREEBUF: DEFS   2               ; Free space buffer
  2114   0067" 00 00       PUBS:    DEFS   2               ; ZRDOS PUBLIC bytes from ENV+0FEH
  2115   0069" 00 00 00 00          DEFS   64              ; Space for local Stack
  2116   00A9" 00 00       STACK:   DEFS   2               ; Opsys stack ptr

  2118                             END
