ZMAC Relocating Macro Assembler v 1.7,                       page    1
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

     2                     ;=======================================================================;
     3                     ;                               C O P Y                                 ;
     4                     ;-----------------------------------------------------------------------;
     5                     ; Derived from MCOPY 4.0 by Richard Conn with Mods by Bruce Morgen(4.8),;
     6                     ; Howard Goldstein (4.6), Michael Bate (4.4,5), Steven M. Cohen (4.3),  ;
     7                     ; Jay Sage, and Joe Wright (4.2)                                        ;
     8                     ;-----------------------------------------------------------------------;
     9                     ; Changes for ZSDOS and DSLIB Copyright (C) 1988  by Harold F. Bower    ;
    10                     ;                       All rights reserved                             ;
    11                     ; This program is made available for non-commercial use.  Any commercial;
    12                     ; use must be authorized by the express written consent of the author.  ;
    13                     ;-----------------------------------------------------------------------;
    14                     ; COPY is a program which copies files between drives or between User   ;
    15                     ; areas.  If Date/Time Stamping is used, Create and Modify Stamps will  ;
    16                     ; be preserved.  Stamps are accessed through DSLIB routines.            ;
    17                     ;                                                                       ;
    18                     ; COPY MUST be linked with The Libraries, Version 4 as:                 ;
    19                     ;                                                                       ;
    20                     ;       ZML COPY,DSLIB/,Z3LIB/,SYSLIB/                                  ;
    21                     ;                                                                       ;
    22                     ; Revisions:                                                            ;
    23                     ;       1.72- Replaced DDIRQ & DDIRPACK library routines with source    ;
    24                     ;               modified to handle Joe Wright's NZTIME stamps along     ;
    25                     ;               with P2Dos, DateStamper(tm) and DosDisk(tm) Stamps.     ;
    26                     ;                                                 17 Jul 93  HFB        ;
    27                     ;       1.71- Deleted unique code in favor of GETMTOP/GZMTOP, deleted   ;
    28                     ;               ZFPARS subroutine for calls to ZPRSFN.  24 Mar 91, HFB  ;
    29                     ;       1.70- Added separate existence test for R/O files controlled by ;
    30                     ;               new O switch.  R/O source files not erased by X option. ;
    31                     ;               M option no longer restricts copy to one group of       ;
    32                     ;               files.  Set attributes call only done when absolutely   ;
    33                     ;               necessary for speed improvement.  Disk reset done for   ;
    34                     ;               all DOS's to ensure proper operation under DOSDISK or   ;
    35                     ;               SPEEDUP RSX.  Initialization improved; CRASHES UNDER    ;
    36                     ;               vanilla CCP fixed.  Top of memory calculation uses      ;
    37                     ;               extended environment if available.  Date comparisons    ;
    38                     ;               now done on all systems that support stamping, not just ;
    39                     ;               ZSDOS.  Bug affecting ZRDOS Public restoration fixed.   ;
    40                     ;               Unnecessary external declarations removed.              ;
    41                     ;                                                       1-9 Mar 91, HG  ;
    42                     ;       1.64- Changed local stack calculations          23 Jul 89, HFB  ;
    43                     ;       1.63- Corrected operation w/"vanilla" CP/M      16 Jul 89, HFB  ;
    44                     ;       1.62- Fixed not restoring entry DU w/o ZCPR3     7 Jun 89, HFB  ;
    45                     ;       1.61- Fixed error in Help Name printout          3 Jun 89, HFB  ;
    46                     ;       1.6 - Modified to operate without ZCPR3, maximum use of Vers 4  ;
    47                     ;               libraries, auto-search for COPY.CFG.    26 May 89, HFB  ;
    48                     ;       1.5 - Fixed obscure bug in buffer calcs, added Jay Sage's patch ;
    49                     ;               to allow COPY DIR:FN.FT to copy to default DIR: rather  ;
    50                     ;               than BACKUP:, Added logic to inhibit /X if /M active.   ;
    51                     ;                                                 12 Mar-2 Apr 89, CWC  ;
    52                     ;       1.4 - Corrected glitch in date comparisons      11 Dec 88, HFB  ;
    53                     ;       1.3 - Unlinked 'E' disable from 'R' and 'A', corrected lack of  ;
    54                     ;               sensing 'R' and 'X', Fall back to Create if no Modify   ;
    55                     ;               date, and print "undated" if neither present, ignore    ;
    56                     ;               erase with X-option if Verify Error.   3-5 Dec 88, HFB  ;
    57                     ;       1.2 - Added 'R' (Replace) option, changed 'X' option to Erase   ;
ZMAC Relocating Macro Assembler v 1.7,                       page    2
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

    58                     ;               source after copy. Release version       2 Dec 88, HFB  ;
    59                     ;       1.1a- Fix glitch on DS only operation, allow rename in same     ;
    60                     ;               user area with different name           25 Nov 88, HFB  ;
    61                     ;       1.1 - Formal release version                    17 Nov 88, HFB  ;
    62                     ;       1.0a-e -  Bug fix in E & N Options, Added Archive, Fixed /M bug ;
    63                     ;               w/test in mcpy28, Restored CRC bypass if not verifying, ;
    64                     ;               corrected glitch if no space on dest, Added File Exclude;
    65                     ;               list, File rename, Archive only if file exists, test    ;
    66                     ;               dates on each file, Add Source open time to Access field;
    67                     ;                                                25 Sep-15 Nov 88, HFB  ;
    68                     ;       1.0 - Initial Release                           18 Sep 88       ;
    69                     ;=======================================================================;

    71         = 0011      VERS    EQU     17              ; Initial Release
    72         = 0032      rev     equ     '2'             ; Bug fix revision
    73                     DATE      MACRO
    74                             DEFB    '17 Jul 93'     ; Prompt Date for easy access
    75                               ENDM

    77                     ; SPECIAL Constants

    79         = 00C0      PLIM    EQU     4*48            ; Size of buffer in pages (4 * nk)
    80                                                     ;       [may be changed]
    81         = 0010      FNSIZE  EQU     16              ; Number of bytes in basic Nam.Typ fields
    82         = 001F      ESIZE   EQU     FNSIZE+15       ; Number of bytes/entry + Date Stamps

    84                     ; CP/M Constants

    86         = 0000      WB      EQU     0               ; CP/M warm boot
    87         = 0005      BDOSE   EQU     WB+5            ; Bdos entry point
    88         = 005C      FCB     EQU     WB+5CH          ; Specified FCB
    89         = 0080      BUFF    EQU     WB+80H          ; Default buffer and input line

    91                     ; DOS Functions Used

    93         = 001A      SDMA    EQU     26              ; Dos Command to set DMA transfer addr
    94         = 0011      SRCHF   EQU     17              ; Dos Command to Search for First file match
    95         = 0012      SRCHN   EQU     18              ; Dos Command to Search for Next file match

    97                     ; ASCII Constants, et al

    99         = 00FF      ON      EQU     0FFH            ; On code
   100         = 0000      OFF     EQU     0               ; Off code
   101         = 000D      CR      EQU     0DH             ; <cr>
   102         = 000A      LF      EQU     0AH             ; <lf>
   103         = 0009      TAB     EQU     09H             ; Horizontal tab
   104         = 0003      CTRLC   EQU     'C'-'@'         ; ^c
   105         = 002F      OPTC    EQU     '/'             ; Option delimiter
   106         = 0000      OPTS    EQU     0000H           ; Skippable option table value

   108                     ; Library Routines used in this Program

   110                             EXT     RETUD, LOGUD, PUTUD, GETUD, GETMTOP, INITFCB    ; Syslib
   111                             EXT     F$EXIST, SETDMA, BDOS, CIN, COUT, CONDIN, CRLF  ;   "
   112                             EXT     MOVEB, EPRINT, EPSTR, PFN1, F$DELETE, F$OPEN    ;   "
   113                             EXT     F$MAKE, F$CLOSE, F$READ, F$WRITE, PAFDC, CAPS   ;   "
ZMAC Relocating Macro Assembler v 1.7,                       page    3
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   114                             EXT     CRC3INIT, CRC3CLR, CRC3UPD, CRC3DONE, CODEND    ;   "
   115                             EXT     DIRMAX, DIRBUF, DPARAMS, @FNCMP, SORT, SSBINIT  ;(DDIRQ)

   117                             EXT     Z3INIT, ZPRSFN, GETQUIET, GETEFCB               ; Z3Lib
   118                             EXT     GETMSG, PUTER2, STOPZEX, WHRENV                 ;   "
   119                             EXT     DIRTDU, DUNDR, GZMTOP                           ;   "

   121                             EXT     GSTAMP, PSTAMP, TIMINI, DOSTYP, TIMTYP, RCLOCK  ; Dslib
   122                             EXT     FINDCK, CKTDF, OPENTD, RWTD, CLOSTD, FSTNXT     ;(DDIRQ)
   123                             EXT     P2UTIM, M2UTIM, BIN2BCD                         ;(DDIRQ)

   125                     ;------------------------------------------------------------------
   126                     ; External ZCPR3 Environment Descriptor

   128   0000' 76                  HALT
   129   0001' C3 0084'            JP      START

   131   0004' 5A 33 45 4E         DEFB    'Z3ENV'         ; This is a ZCPR3 utility
   132   0009' 01                  DEFB    1               ; External environment descriptor
   133   000A' 0001        Z3EADR: DEFW    0001            ; Dummy value to force WHRENV search

   135                     ; This section aligns to locations needed for ZCNFG auto-search for
   136                     ; configuration file name.  It is aligned to Type-4 header values.

   138   000C' 0000                DEFW    0000            ; Filler for ZCNFG file name offset
   139   000E' 43 4F 50 59         DEFB    'COPY    ',0    ; Search for COPY.CFG

   141                     ; User-Definable Initial Flag Conditions
   142                     ;  The default conditions for MCOPY may be readily patched by the user
   143                     ;  via DDT for his desired default values

   145   0017'             DEFTBL:
   146   0017' FF          DVERFLG: DEFB   ON              ; Set verify
   147   0018' 00          DINSP:   DEFB   OFF             ; Set no inspect
   148   0019' 00          DSYSEXC: DEFB   OFF             ; Set no $SYS file exclusion by default
   149   001A' 00          DNCOPY:  DEFB   OFF             ; Set no multiple copies by default
   150   001B' FF          DEXIST:  DEFB   ON              ; Existence testing on
   151   001C' FF          DEXTRO   DEFB   ON              ; Existence testing, R/O files, on
   152   001D' 00          DARCHV:  DEFB   OFF             ; Do not operate in Archive mode
   153   001E' 00          DREPL:   DEFB   OFF             ; Do Not restrict copy to Existing files
   154                     ;---- All above entries copied to CPYTBL
   155   001F' FF          TYPDAT:  DEFB   ON              ; Type of stamps to select in Source
   156                                                     ; OFF = P2D/DosDisk, ON = DateStamper
   157   0020' 00          USEDDU:  DEFB   OFF             ; If on, default DU: given in next 3 fields
   158   0021' 00          DDUSER:  DEFB   0               ; Default destination user is 0
   159   0022' 01          DDDISK:  DEFB   'B'-'A'         ; Default destination disk is B
   160   0023' 42 41 43 4B BACKDIR: DEFB   'BACKUP  '      ; Name of backup directory
   161   002B' 21 21 3F 3F EXCLUD:  DEFB   '!!?????????'   ; 8-name File Exclusion list
   162   0036' 5B 3F 3F 3F          DEFB   '[??????]???'
   163   0041' 3F 3F 3F 3F          DEFB   '????????$?$'
   164   004C' 20 20 20 20          DEFB   '           '
   165   0057' 20 20 20 20          DEFB   '           '
   166   0062' 20 20 20 20          DEFB   '           '
   167   006D' 20 20 20 20          DEFB   '           '
   168   0078' 20 20 20 20          DEFB   '           '
   169   0083' 00                   DEFB   0               ; List terminator
ZMAC Relocating Macro Assembler v 1.7,                       page    4
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


   171                     ; Beginning of COPY Program

   173   0084'             START:                          ; Set up Dynamic (whew!) Buffers
   174   0084' ED73 00A9"          LD      (STACK),SP      ; Save incoming stack pointer
   175   0088' 31 00A9"            LD      SP,STACK        ; ..and set a local stack
   176   008B' 21 0015"            LD      HL,DATABG       ; Set program data area to 0
   177   008E' 11 0016"            LD      DE,DATABG+1
   178   0091' 01 0093             LD      BC,STACK-DATABG-1
   179   0094' 36 00               LD      (HL),0
   180   0096' EDB0                LDIR
   181   0098' CD 0000#            CALL    CODEND          ; Determine free space
   182   009B' CD 0000#            CALL    CRC3INIT        ; Create CRC table
   183   009E' 24                  INC     H               ; Allow 2 pages for CRC table
   184   009F' 24                  INC     H
   185   00A0' 22 0063"            LD      (INLINE),HL     ; Ptr to input line
   186   00A3' 2E 80               LD      L,128
   187   00A5' 22 002A"            LD      (FCBS),HL       ; Ptr to source FCB
   188   00A8' 2E A4               LD      L,128+36
   189   00AA' 22 002C"            LD      (FCBD),HL       ; Ptr to dest FCB
   190   00AD' 24                  INC     H
   191   00AE' 2E 00               LD      L,0
   192   00B0' 22 0065"            LD      (FREEBUF),HL    ; Free space buffer

   194   00B3' CD 0000#            CALL    EPRINT          ; Print Banner
   195   00B6' 43 4F 50 59         DEFB    'COPY  Version '
   196   00C4' 31 2E 37 32         DEFB    VERS/10+'0','.',VERS MOD 10 + '0',rev,' (for ZSDOS)   '
   197                             DATE
   197   00D7' 31 37 20 4A         DEFB    '17 Jul 93'     ; Prompt Date for easy access
   198   00E0' 00                  DEFB    0

   200   00E1' 2A 000A'            LD      HL,(Z3EADR)     ; Get candidate ZCPR3 environment
   201   00E4' CD 0000#            CALL    WHRENV
   202   00E7' 22 000A'            LD      (Z3EADR),HL     ; ..and store validated ENV addr
   203   00EA' CD 0000#            CALL    Z3INIT          ; Initialize the ZCPR3 ENV and Z3LIB vectors

   205   00ED' CD 0000#            CALL    TIMINI          ; Initialize the Dos & Time System
   206   00F0' 3A 000B'            LD      A,(Z3EADR+1)    ; Do we have a valid ENV?
   207   00F3' B7                  OR      A               ;  (Page must be Non-Zero if valid)
   208   00F4' 20 06'              JR      NZ,MSGS         ; Have ENV, go do msg stuff
   209   00F6' 3D                  DEC     A
   210   00F7' 32 0033"            LD      (NOMSGS),A      ; No env means no msg buffer
   211   00FA' 18 19'              JR      SDFLGS

   213   00FC' CD 0000#    MSGS:   CALL    STOPZEX         ; Prevent ZEX input

   215   00FF' CD 0000#            CALL    GETQUIET        ; Get ZCPR3 quiet flag
   216   0102' 32 0038"            LD      (QUIET),A       ; ..and set local flag

   218   0105' CD 0000#            CALL    GETMSG          ; See if there is a message buffer
   219   0108' 20 07'              JR      NZ,HAVMSGS
   220   010A' 3E FF               LD      A,0FFH          ; No message buffer - set indicator
   221   010C' 32 0033"            LD      (NOMSGS),A
   222   010F' 18 04'              JR      SDFLGS

   224   0111' AF          HAVMSGS: XOR    A               ; There is a message buffer - clear
ZMAC Relocating Macro Assembler v 1.7,                       page    5
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   225   0112' CD 0000#            CALL    PUTER2          ; the error flag

   227                     ; Set Default Flags

   229   0115' 21 0017'    SDFLGS: LD      HL,DEFTBL       ; Copy default options to mem.
   230   0118' 11 001B"            LD      DE,CPYTBL
   231   011B' 06 08               LD      B,TBLLEN
   232   011D' CD 0000#            CALL    MOVEB

   234                     ; Check for Backup Directory and establish it as default
   235                     ;  If No Backup Directory or No ZCPR3, select default stored

   237   0120' CD 0000#            CALL    RETUD           ; Set Current DU in BC just in case
   238   0123' 78                  LD      A,B             ; Save disk
   239   0124' 32 0023"            LD      (CDISK),A
   240   0127' 3A 0020'            LD      A,(USEDDU)      ; Fixed default for DU:?
   241   012A' A7                  AND     A
   242   012B' 28 12'              JR      Z,DEFBAK        ; ..jump if not and set current dest

   244   012D' 3A 000B'    DEFBK0: LD      A,(Z3EADR+1)    ; Any valid ENV?
   245   0130' B7                  OR      A
   246   0131' 28 08'              JR      Z,DEFBK1        ; ..get stored default if not
   247   0133' 21 0023'            LD      HL,BACKDIR      ; Pt to directory name
   248   0136' CD 0000#            CALL    DIRTDU          ; Does it exist?
   249   0139' 20 04'              JR      NZ,DEFBAK       ; ..jump if found and select
   250   013B' ED4B 0021'  DEFBK1: LD      BC,(DDUSER)     ; Otherwise use default DU
   251   013F' ED43 0026"  DEFBAK: LD      (DUSER),BC

   253   0143' CD 0000#            CALL    PUTUD           ; Save current Drive/User position
   254   0146' ED5B 0063"          LD      DE,(INLINE)     ; Input line save buffer
   255   014A' 21 0081             LD      HL,BUFF+1       ; Pt to command line characters
   256   014D' 06 7F               LD      B,127           ; Save 127 bytes (arbitrary)
   257   014F' CD 0000#            CALL    MOVEB
   258   0152' EB                  EX      DE,HL           ; Hl pts to input line

   260                     ; Set other flags (always defaults to "off")

   262   0153' AF                  XOR     A               ; A=0
   263   0154' 32 0039"            LD      (NOREPL),A      ; Turn off "no copy if exists" option
   264   0157' 32 0037"            LD      (XMOVE),A       ; ..and "remove source after copy"

   266                     ; Check for empty Command Line and process Command Mode if so
   267                     ; On Entry, HL pts to first char of string from CLINE

   269   015A' 7E          START1: LD      A,(HL)          ; Get char
   270   015B' B7                  OR      A               ; Eol?
   271   015C' CA 0215'            JP      Z,MHELP         ; Print help message if no input
   272   015F' 23                  INC     HL              ; Pt to next
   273   0160' FE 20               CP      ' '             ; Just spaces?
   274   0162' 28 F6'              JR      Z,START1

   276                     ; Command Line was Not Empty -- Check for HELP request

   278   0164' 2B                  DEC     HL              ; Pt to first char
   279   0165' FE 2F               CP      OPTC            ; If opening option, must be help
   280   0167' CA 0215'            JP      Z,MHELP
ZMAC Relocating Macro Assembler v 1.7,                       page    6
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


   282                     ; See if Options are available in the Command Line

   284   016A' 22 0015"            LD      (MFPTR),HL      ; Set ptr to first char of file name specs
   285                                                     ; ..Skip to end of File Name Specs
   286   016D' 3A 0080             LD      A,(BUFF)        ; Tail char. count
   287   0170' 4F                  LD      C,A             ; To C
   288   0171' AF                  XOR     A               ; Search for terminating null
   289   0172' 47                  LD      B,A             ; BC now has count
   290   0173' EDB1                CPIR                    ; Search..
   291   0175' C2 0215'            JP      NZ,MHELP        ; Not found, something screwy
   292   0178' 2B                  DEC     HL              ; Get last real char.
   293   0179' 2B                  DEC     HL
   294   017A' 7E                  LD      A,(HL)
   295   017B' FE 3A               CP      ':'             ; Was it a dest. DU:/DIR: ?
   296   017D' 28 1E'              JR      Z,OVRIDE        ; If so, non-option
   297   017F' 3E 20               LD      A,' '           ; Search back for next blank
   298   0181' 0E 0C               LD      C,OPTLEN+1      ; Range in (B)C
   299   0183' EDB9                CPDR                    ; Search..
   300   0185' 20 16'              JR      NZ,OVRIDE       ; Not found, too long for option
   301   0187' 23                  INC     HL              ; Bump point to potential option
   302   0188' 23                  INC     HL
   303   0189' CD 0C88'            CALL    OPTQ            ; Test it thoroughly
   304   018C' 20 0F'              JR      NZ,OVRIDE       ; Treat as option if Z returned

   306                     ; Scan for Option

   308   018E' 7E          OPTION: LD      A,(HL)          ; Get option char
   309   018F' B7                  OR      A               ; Eol?
   310   0190' 28 0B'              JR      Z,OVRIDE        ; Do mcopy
   311   0192' 23                  INC     HL              ; Pt to next
   312   0193' E5                  PUSH    HL              ; Save ptr
   313   0194' 21 01D2'            LD      HL,OPTTAB       ; Pt to option table
   314   0197' CD 01BA'            CALL    CMDER           ; Process command
   315   019A' E1                  POP     HL              ; Get ptr
   316   019B' 18 F1'              JR      OPTION

   318                     ; Since the no replace mode is incompatible with the exist test
   319                     ; mode, if norepl flag is on turn exist off

   321   019D' 3A 0021"    OVRIDE: LD      A,(ARCHIV)      ; Is this an Archive opn?
   322   01A0' B7                  OR      A
   323   01A1' 20 06'              JR      NZ,OVRID1       ; ..Supercede other ops if so
   324   01A3' 3A 0022"            LD      A,(REPLAC)      ; Is this copy if Exist?
   325   01A6' B7                  OR      A
   326   01A7' 28 04'              JR      Z,MCOP0V        ; ..jump if not
   327   01A9' AF          OVRID1: XOR     A
   328   01AA' 32 0039"            LD      (NOREPL),A      ; ..and No Replace is off
   329   01AD' 3A 001E"    MCOP0V: LD      A,(NCOPY)
   330   01B0' B7                  OR      A
   331   01B1' 28 04'              JR      Z,OVRID2        ; Test for multiple copy
   332   01B3' AF                  XOR     A
   333   01B4' 32 0037"            LD      (XMOVE),A       ; clear source delete if multiple
   334   01B7' C3 04D4'    OVRID2: JP      MCOPY0

   336                     ; Command Processor -- Command letter in A, HL pts to Table
ZMAC Relocating Macro Assembler v 1.7,                       page    7
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


   338   01BA' 47          CMDER:  LD      B,A             ; Command in b
   339   01BB' 7E          CMDER1: LD      A,(HL)          ; Get command letter
   340   01BC' B7                  OR      A               ; Done?
   341   01BD' 28 38'              JR      Z,OHELP
   342   01BF' B8                  CP      B               ; Match?
   343   01C0' 23                  INC     HL              ; Pt to address
   344   01C1' 20 0B'              JR      NZ,CMDER3
   345   01C3' 5E                  LD      E,(HL)          ; Get it in DE
   346   01C4' 23                  INC     HL
   347   01C5' 56                  LD      D,(HL)
   348   01C6' EB                  EX      DE,HL           ; HL pts to command address
   349   01C7' 7D                  LD      A,L
   350   01C8' B4                  OR      H               ; Test for OPTS
   351   01C9' C8                  RET     Z               ; Return w/no action if so
   352   01CA' 7E                  LD      A,(HL)          ; Otherwise get option byte
   353   01CB' 2F                  CPL                     ; Flip it
   354   01CC' 77                  LD      (HL),A          ; Put it back
   355   01CD' C9                  RET

   357   01CE' 23          CMDER3: INC     HL              ; Skip to next entry in table
   358   01CF' 23                  INC     HL
   359   01D0' 18 E9'              JR      CMDER1

   361                     ; Option Command Table

   363   01D2' 20          OPTTAB: DEFB    ' '             ; Skip blanks
   364   01D3' 0000                DEFW    OPTS
   365   01D5' 41                  DEFB    'A'             ; Archive mode
   366   01D6' 0021                DEFW    ARCHIV
   367   01D8' 45                  DEFB    'E'             ; Exist test
   368   01D9' 001F                DEFW    EXIST
   369   01DB' 49                  DEFB    'I'             ; Inspect
   370   01DC' 001C                DEFW    INSP
   371   01DE' 4D                  DEFB    'M'             ; Multiple copy
   372   01DF' 001E                DEFW    NCOPY
   373   01E1' 4E                  DEFB    'N'             ; No copy if file already on dest.
   374   01E2' 0039                DEFW    NOREPL
   375   01E4' 51                  DEFB    'Q'             ; Quiet
   376   01E5' 0038                DEFW    QUIET
   377   01E7' 53                  DEFB    'S'             ; System Exclude
   378   01E8' 001D                DEFW    SYSEXC
   379   01EA' 56                  DEFB    'V'             ; Verify
   380   01EB' 001B                DEFW    VERFLG
   381   01ED' 58                  DEFB    'X'             ; Remove Source after copy
   382   01EE' 0037                DEFW    XMOVE
   383   01F0' 52                  DEFB    'R'             ; Copy ONLY if Dest. Exists
   384   01F1' 0022                DEFW    REPLAC
   385   01F3' 4F                  DEFB    'O'             ; Existence test for R/O files
   386   01F4' 0020                DEFW    EXRO
   387   01F6' 00                  DEFB    0               ; End of table

   389                     ; Invalid Option Char --  Adjust Stack and Print Help

   391   01F7' 3A 0038"    OHELP:  LD      A,(QUIET)
   392   01FA' B7                  OR      A
ZMAC Relocating Macro Assembler v 1.7,                       page    8
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   393   01FB' 3E 07               LD      A,7
   394   01FD' CC 0000#            CALL    Z,COUT          ; Beep if not muzzled
   395   0200' CD 0000#            CALL    EPRINT
   396   0203' 0D 0A 4F 70         DEFB    CR,LF,'Option error!',CR,LF,0

   398                     ; Print Help Message  (NOTE: DUSER set correctly by the time we get here)

   400   0215' CD 0000#    MHELP:  CALL    EPRINT
   401   0218' 0D 0A 53 79         DEFB    CR,LF,'Syntax:'
   402   0221' 0D 0A 20 20         DEFB    CR,LF,'  ',0
   403   0226' CD 0C58'            CALL    COMNAM          ; "COPY" or EFCB name
   404   0229' CD 0000#            CALL    EPRINT
   405   022C' 20 64 69 72         DEFB    ' dir:[filename.typ]=[dir:]filename.typ,... [/]o...'
   406   025E' 0D 0A 09 09         DEFB    CR,LF,TAB,TAB,'(or)'
   407   0266' 0D 0A 20 20         DEFB    CR,LF,'  ',0
   408   026B' CD 0C58'            CALL    COMNAM          ; "COPY" or EFCB name
   409   026E' CD 0000#            CALL    EPRINT
   410   0271' 20 5B 64 69         DEFB    ' [dir:]filename.typ dir:[filename.typ],... [/]o...'
   411   02A3' 0D 0A 09 09         DEFB    CR,LF,TAB,TAB,'(or)'
   412   02AB' 0D 0A 20 20         DEFB    CR,LF,'  ',0
   413   02B0' CD 0C58'            CALL    COMNAM          ; "COPY" or EFCB name
   414   02B3' CD 0000#            CALL    EPRINT
   415   02B6' 20 5B 64 69         DEFB    ' [dir:]filename.typ,... /o...'
   416   02D3' 0D 0A 09 28         DEFB    CR,LF,TAB,'(Copies to ',0

   418   02E2' ED4B 0026"          LD      BC,(DUSER)      ; get default destination DU:
   419   02E6' CD 0C49'            CALL    PRNDU           ; ..print it
   420   02E9' 04                  INC     B               ; make drive one based for this
   421   02EA' 3A 000B'            LD      A,(Z3EADR+1)    ; Do we have a valid ENV?
   422   02ED' B7                  OR      A
   423   02EE' C4 0000#            CALL    NZ,DUNDR        ; Check for NDR for this one if ENV Ok
   424   02F1' 28 04'              JR      Z,GOTBAK        ; ..jump if no ENV or Name
   425   02F3' 23                  INC     HL              ; point to name
   426   02F4' CD 0C61'            CALL    PRNNAM          ; ..and print up to 8 chars
   427                      
   428   02F7' CD 0000#    GOTBAK: CALL    EPRINT
   429   02FA' 29                  DEFB    ')'
   430   02FB' 0D 0A 4F 70         DEFB    CR,LF,'Options:'
   431   0305' 0D 0A 20 20         DEFB    CR,LF,'  A -- ',0  ; Copy only Non-Archive?
   432   030F' 3A 0021"            LD      A,(ARCHIV)
   433   0312' B7                  OR      A
   434   0313' C4 04CC'            CALL    NZ,SAYNO        ; ..FF is No copy if archived
   435   0316' CD 0000#            CALL    EPRINT
   436   0319' 41 72 63 68         DEFB    'Archive Bit Control'
   437   032C' 0D 0A 20 20         DEFB    CR,LF,'  E -- ',0
   438   0336' 3A 001F"            LD      A,(EXIST)
   439   0339' B7                  OR      A
   440   033A' C4 04CC'            CALL    NZ,SAYNO
   441   033D' CD 0000#            CALL    EPRINT
   442   0340' 45 78 69 73         DEFB    'Existence Test'
   443   034E' 0D 0A 20 20         DEFB    CR,LF,'  I -- ',0
   444   0358' 3A 001C"            LD      A,(INSP)
   445   035B' B7                  OR      A
   446   035C' C4 04CC'            CALL    NZ,SAYNO
   447   035F' CD 0000#            CALL    EPRINT
   448   0362' 49 6E 73 70         DEFB    'Inspect Files'
ZMAC Relocating Macro Assembler v 1.7,                       page    9
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   449   036F' 0D 0A 20 20         DEFB    CR,LF,'  M -- ',0
   450   0379' 3A 001E"            LD      A,(NCOPY)
   451   037C' B7                  OR      A
   452   037D' C4 04CC'            CALL    NZ,SAYNO
   453   0380' CD 0000#            CALL    EPRINT
   454   0383' 4D 75 6C 74         DEFB    'Multiple Copy'
   455   0390' 0D 0A 20 20         DEFB    CR,LF,'  N -- NO Copy if Destination Exists'
   456   03B6' 0D 0A 20 20         DEFB    CR,LF,'  O -- ',0
   457   03C0' 3A 0020"            LD      A,(EXRO)
   458   03C3' B7                  OR      A
   459   03C4' C4 04CC'            CALL    NZ,SAYNO
   460   03C7' CD 0000#            CALL    EPRINT
   461   03CA' 45 78 69 73         DEFB    'Existence test - R/O files'
   462   03E4' 0D 0A 20 20         DEFB    CR,LF,'  Q -- ',0
   463   03EE' 3A 0038"            LD      A,(QUIET)
   464   03F1' B7                  OR      A
   465   03F2' C4 04CC'            CALL    NZ,SAYNO
   466   03F5' CD 0000#            CALL    EPRINT
   467   03F8' 51 75 69 65         DEFB    'Quiet'
   468   03FD' 0D 0A 20 20         DEFB    CR,LF,'  R -- ',0
   469   0407' 3A 001E'            LD      A,(DREPL)
   470   040A' B7                  OR      A
   471   040B' C4 04CC'            CALL    NZ,SAYNO
   472   040E' CD 0000#            CALL    EPRINT
   473   0411' 52 65 70 6C         DEFB    'Replace Only Files existing'
   474   042C' 0D 0A 20 20         DEFB    CR,LF,'  S -- ',0
   475   0436' 3A 001D"            LD      A,(SYSEXC)
   476   0439' B7                  OR      A
   477   043A' C4 04CC'            CALL    NZ,SAYNO
   478   043D' CD 0000#            CALL    EPRINT
   479   0440' 53 79 73 74         DEFB    'System Files excluded'
   480   0455' 0D 0A 20 20         DEFB    CR,LF,'  V -- ',0
   481   045F' 3A 001B"            LD      A,(VERFLG)
   482   0462' B7                  OR      A
   483   0463' C4 04CC'            CALL    NZ,SAYNO
   484   0466' CD 0000#            CALL    EPRINT
   485   0469' 56 65 72 69         DEFB    'Verify'
   486   046F' 0D 0A 20 20         DEFB    CR,LF,'  X -- Delete Source After Copy',CR,LF
   487   0492' 0A 4E 4F 54         DEFB    LF,'NOTES: "R" and/or "A" turns off "N", "M" turns off "X"',0
   488   04CA' 18 3A'              JR      RETSYS          ; Return to Command Processor

   490   04CC' CD 0000#    SAYNO:  CALL    EPRINT
   491   04CF' 4E 4F 20 00         DEFB    'NO ',0
   492   04D3' C9                  RET

   494                     ; **** MCOPY of COMMAND LINE ****

   496   04D4' 31 00A9"    MCOPY0: LD      SP,STACK        ; Reset the Stack
   497   04D7' 3A 0000#            LD      A,(DOSTYP)      ; Check Dos type
   498   04DA' D6 52               SUB     'R'             ; Is it ZRDOS?
   499   04DC' 20 10'              JR      NZ,NOTZRD       ; ..jump if not
   500   04DE' 2A 000A'            LD      HL,(Z3EADR)
   501   04E1' 11 007E             LD      DE,07EH
   502   04E4' 19                  ADD     HL,DE           ; Point HL at PUBLIC bytes
   503   04E5' 5E                  LD      E,(HL)          ; Get first PUBLIC byte in E
   504   04E6' 77                  LD      (HL),A          ; Replace with a zero
ZMAC Relocating Macro Assembler v 1.7,                       page   10
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   505   04E7' 23                  INC     HL              ; Point to second byte
   506   04E8' 56                  LD      D,(HL)          ; Get into D
   507   04E9' 77                  LD      (HL),A          ; Replace with a zero
   508   04EA' ED53 0067"          LD      (PUBS),DE       ; Save for exit

   510   04EE' CD 050B'    NOTZRD: CALL    COPY            ; Do the copy
   511   04F1' ED5B 0067"  CPM:    LD      DE,(PUBS)
   512   04F5' 7B                  LD      A,E
   513   04F6' B2                  OR      D
   514   04F7' 28 0A'              JR      Z,NOPUB
   515   04F9' 2A 000A'            LD      HL,(Z3EADR)
   516   04FC' 01 007E             LD      BC,07EH
   517   04FF' 09                  ADD     HL,BC
   518   0500' 73                  LD      (HL),E
   519   0501' 23                  INC     HL
   520   0502' 72                  LD      (HL),D
   521   0503' CD 0000#    NOPUB:  CALL    GETUD           ; Restore the entry DU condition
   522   0506' ED7B 00A9"  RETSYS: LD      SP,(STACK)      ; Reset stack
   523   050A' C9                  RET                     ; Return to opsys

   525                     ; **** Begin Multiple Copy Procedure ****

   527   050B' 3A 001E"    COPY:   LD      A,(NCOPY)       ; Are we doing multiple copies?
   528   050E' B7                  OR      A
   529   050F' 28 33'              JR      Z,NOPAUS        ; ..jump if not
   530   0511' CD 0000#            CALL    EPRINT
   531   0514' 0D 0A 20 2E         DEFB    CR,LF,' ...Any key starts copy, ^C Quits - ',0
   532   053B' CD 0BC4'            CALL    GETCH           ; Get response in Uppercase
   533   053E' CD 0000#            CALL    CRLF            ; Go to New Line
   534   0541' FE 03               CP      CTRLC           ; Is it an abort request (^c)?
   535   0543' C8                  RET     Z               ; ..exit here if so
   536   0544' 2A 0015"    NOPAUS: LD      HL,(MFPTR)      ; Pt to first file name
   537   0547' 22 0017"            LD      (NXTPTR),HL     ; Set ptr to next file name
   538   054A' AF                  XOR     A               ; A=0
   539   054B' 32 0030"            LD      (VERCNT),A      ; Zero error count
   540   054E' 32 0034"            LD      (NORST),A       ; Clear "no reset" flag

   542                     ; **** Main Copy Loop ****

   544   0551' 2A 0017"    MCOPY:  LD      HL,(NXTPTR)     ; Get ptr to next file name
   545   0554' 7E                  LD      A,(HL)          ; Get first char
   546   0555' FE 21               CP      ' '+1           ; Done if <sp> or less
   547   0557' 30 2B'              JR      NC,MCOPY1       ; Continue with procedure

   549                     ; MCOPY of File Specs is now done
   550                     ; Done with Copy Procedure -- Continue?

   552   0559' 3A 001B"    COPYT:  LD      A,(VERFLG)      ; Verify?
   553   055C' B7                  OR      A               ; 0=no
   554   055D' 28 1E'              JR      Z,COPYT1
   555   055F' CD 0000#            CALL    EPRINT          ; New line & a blank
   556   0562' 0D 0A 20 00         DEFB    CR,LF,' ',0
   557   0566' 3A 005F"            LD      A,(HAVFIL)      ; Did we do anything?
   558   0569' B7                  OR      A
   559   056A' 28 11'              JR      Z,COPYT1        ; ..jump if not
   560   056C' 3A 0030"            LD      A,(VERCNT)      ; Get error count
ZMAC Relocating Macro Assembler v 1.7,                       page   11
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   561   056F' CD 0000#            CALL    PAFDC           ; Print as decimal
   562   0572' CD 0000#            CALL    EPRINT
   563   0575' 20 45 72 72         DEFB    ' Errors',0
   564   057D' 3A 001E"    COPYT1: LD      A,(NCOPY)       ; Multiple copies?
   565   0580' B7                  OR      A               ; 0=no
   566   0581' C8                  RET     Z
   567   0582' 18 87'              JR      COPY            ; Copy again from the beginning

   569                     ; Begin Copy of File Group

   571   0584' FE 2C       MCOPY1: CP      ','             ; Skip comma separator if there
   572   0586' 20 01'              JR      NZ,MCPY0
   573   0588' 23                  INC     HL              ; Pt to char after comma
   574   0589' E5          MCPY0:  PUSH    HL              ; Preserve regs
   575   058A' 06 0B               LD      B,11
   576   058C' 2A 002C"            LD      HL,(FCBD)       ; Clear dest FileName
   577   058F' 23                  INC     HL
   578   0590' 36 20       INITLZ: LD      (HL),' '
   579   0592' 23                  INC     HL
   580   0593' 10 FB'              DJNZ    INITLZ          ; ..loop til done
   581   0595' E1                  POP     HL              ; Restore input pointer
   582   0596' 7E                  LD      A,(HL)          ; Get next char
   583   0597' FE 21               CP      ' '+1           ; Check for error
   584   0599' DA 09BC'            JP      C,FORMERR
   585   059C' CD 0000#            CALL    GETUD           ; Return home
   586   059F' ED5B 002A"          LD      DE,(FCBS)       ; Pt to source FCB
   587   05A3' AF                  XOR     A
   588   05A4' CD 0000#            CALL    ZPRSFN          ; Extract file name data
   589   05A7' CD 09A8'            CALL    DUCVRT          ; Convert DU into BC
   590   05AA' 7E                  LD      A,(HL)          ; Get delimiter
   591   05AB' FE 2C               CP      ','             ; End of element?
   592   05AD' 28 4C'              JR      Z,MCOPY2        ; Form is dirs:fn.ft
   593   05AF' FE 3D               CP      '='             ; If '=', we have a new disk/user
   594   05B1' 28 22'              JR      Z,NEWDU
   595   05B3' FE 20               CP      ' '             ; Test for reversed syntax
   596   05B5' 20 44'              JR      NZ,MCOPY2       ; Nope, default b/u dest.
   597   05B7' 23                  INC     HL              ; Point to dest. DU:/DIR:
   598   05B8' 7E                  LD      A,(HL)          ; One more end-of-element test
   599   05B9' FE 2C               CP      ','
   600   05BB' 28 3E'              JR      Z,MCOPY2
   601   05BD' FE 21               CP      ' '+1           ; Invalid char. test
   602   05BF' DA 09BC'            JP      C,FORMERR
   603   05C2' C5                  PUSH    BC              ; Save parsed DU in BC
   604   05C3' ED5B 002C"          LD      DE,(FCBD)       ; Set Destination FCB
   605   05C7' AF                  XOR     A
   606   05C8' CD 0000#            CALL    ZPRSFN          ; Extract file name data
   607   05CB' CD 09A8'            CALL    DUCVRT          ; Convert DU into BC
   608   05CE' ED43 0026"          LD      (DUSER),BC      ; Poke as dest.
   609   05D2' C1                  POP     BC              ; Get back src. DU
   610   05D3' 18 26'              JR      MCOPY2          ; and proceed..

   612                     ; Form is DIRD:=DIRS:FN.FT, So set Dest Disk/User

   614   05D5' ED43 0026"  NEWDU:  LD      (DUSER),BC
   615   05D9' E5                  PUSH    HL              ; Preserve regs
   616   05DA' C5                  PUSH    BC
ZMAC Relocating Macro Assembler v 1.7,                       page   12
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   617   05DB' ED5B 002C"          LD      DE,(FCBD)       ; ..and copy Source to dest
   618   05DF' 2A 002A"            LD      HL,(FCBS)
   619   05E2' 01 000C             LD      BC,12
   620   05E5' EDB0                LDIR
   621   05E7' C1                  POP     BC              ; Restore entry regs
   622   05E8' E1                  POP     HL

   624                     ; Now derive DIRS:FN.FT Form after the '='

   626   05E9' 23                  INC     HL              ; Pt to char beyond '='
   627   05EA' 7E                  LD      A,(HL)          ; Get char
   628   05EB' FE 21               CP      ' '+1           ; Format error?
   629   05ED' DA 09BC'            JP      C,FORMERR
   630   05F0' ED5B 002A"          LD      DE,(FCBS)       ; Load FCB
   631   05F4' AF                  XOR     A
   632   05F5' CD 0000#            CALL    ZPRSFN          ; Get source name
   633   05F8' CD 09A8'            CALL    DUCVRT          ; Convert to DU in BC

   635                     ; Save ptr to next char after DIRS:FN.FT, and set source Disk/User

   637   05FB' 22 0017"    MCOPY2: LD      (NXTPTR),HL     ; Save ptr to next char
   638   05FE' ED43 0024"          LD      (SUSER),BC

   640   0602' 2A 002C"            LD      HL,(FCBD)       ; Check for dest renaming
   641   0605' 3E 20               LD      A,' '           ; ..by looking for spaces
   642   0607' CD 0C7A'            CALL    SCAN11
   643   060A' D6 0B               SUB     11              ; Sub no entry cnt fm space
   644   060C' 32 0060"            LD      (RENFLG),A      ; ..and save as flag
   645   060F' 28 14'              JR      Z,CKSAMU        ; Jump if not renaming
   646   0611' 2A 002C"            LD      HL,(FCBD)       ; Check for ambiguous dest fn
   647   0614' CD 0C78'            CALL    SCANQQ          ; ..by counting "?"s
   648   0617' C2 0BFC'            JP      NZ,AMBERR       ; ..jump error if ambiguous
   649   061A' 2A 002A"            LD      HL,(FCBS)       ; Check for ambiguous source
   650   061D' CD 0C78'            CALL    SCANQQ          ; ..by counting "?"s
   651   0620' C2 0BFC'            JP      NZ,AMBERR       ; ..jump Error if ambiguous
   652   0623' 18 21'              JR      MCPYOK          ; Else jump to Ok procedure

   654   0625' ED4B 0024"  CKSAMU: LD      BC,(SUSER)      ; Get Source DU
   655   0629' 2A 0026"            LD      HL,(DUSER)      ; ..and Dest DU
   656   062C' B7                  OR      A
   657   062D' ED42                SBC     HL,BC           ; Dest dir must not equal source dir
   658   062F' 20 15'              JR      NZ,MCPYOK       ; Not same, say its ok to go
   659   0631' CD 0000#            CALL    EPRINT
   660   0634' 0D 0A 53 72         DEFB    CR,LF,'Src=Dest Err',0
   661   0643' C3 0AAE'            JP      SETEFLAG        ; Set Error flag & exit

   663   0646' 3A 0021"    MCPYOK: LD      A,(ARCHIV)      ; Are we in Archival mode?
   664   0649' B7                  OR      A
   665   064A' 28 12'              JR      Z,COPYAA        ; ..jump if not
   666   064C' CD 0000#            CALL    EPRINT          ; Print archiving msg
   667   064F' 0D 0A 41 72         DEFB    CR,LF,'Archiving ',0
   668   065C' 18 0E'              JR      COPYBB

   670   065E' CD 0000#    COPYAA: CALL    EPRINT
   671   0661' 0D 0A 43 6F         DEFB    CR,LF,'Copying ',0
   672   066C' CD 0C1E'    COPYBB: CALL    PRTS2D          ; Print "Source to Dest" msg
ZMAC Relocating Macro Assembler v 1.7,                       page   13
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   673   066F' 0E 0D               LD      C,13            ; Prepare to Reset disk system
   674   0671' 3A 0034"            LD      A,(NORST)       ; Is this first copy operation?
   675   0674' B7                  OR      A
   676   0675' CC 0005             CALL    Z,BDOSE         ; Do reset if so
   677   0678' CD 0BF6'            CALL    DFLTAD          ; Set to default DMA addr
   678   067B' CD 0B87'            CALL    SETSR0          ; Log Source, Set FCB & Init it
   679   067E' 2A 0065"            LD      HL,(FREEBUF)    ; Pt to buffer area
   680   0681' F6 FF               OR      0FFH            ; Store Non-Zero wo we won't reset again
   681   0683' 32 0034"            LD      (NORST),A       ; Store a non-zero so we won't reset again
   682   0686' CD 0CE5'            CALL    DDIRQ           ; Load dir, select files, sort, etc
   683   0689' CA 09CD'            JP      Z,TPAOVFL       ; Tpa overflow error?
   684   068C' 78                  LD      A,B             ; Do we have any files?
   685   068D' B1                  OR      C
   686   068E' 28 0E'              JR      Z,SYSOK0        ; Jump if No files
   687   0690' CD 0B46'            CALL    CHKXCL          ; Check for excluded files
   688   0693' 3A 0021"            LD      A,(ARCHIV)      ; Copy only Non-Archived Files?
   689   0696' B7                  OR      A
   690   0697' C4 0B2A'            CALL    NZ,SELARC       ; ..reselect directory if so
   691   069A' 78                  LD      A,B             ; And see if any remain selected
   692   069B' B1                  OR      C
   693   069C' 20 30'              JR      NZ,MCPY24       ; ..jump if so
   694   069E' 32 0034"    SYSOK0: LD      (NORST),A       ; Clear flag - disk reset before next copy
   695   06A1' CD 0AAE'            CALL    SETEFLAG        ; Set Error flag
   696   06A4' CD 0000#            CALL    EPRINT
   697   06A7' 0D 0A 20 4E         DEFB    CR,LF,' NO Files -- ^C to Abort ',0
   698   06C3' CD 0BC4'            CALL    GETCH           ; Get response
   699   06C6' FE 03               CP      CTRLC           ; Abort?
   700   06C8' CA 0559'            JP      Z,COPYT         ; End test
   701   06CB' C3 0551'            JP      MCOPY           ; Continue with next

   703   06CE' 3A 001C"    MCPY24: LD      A,(INSP)        ; Inspect files?
   704   06D1' B7                  OR      A               ; 0=No
   705   06D2' C4 0AB7'            CALL    NZ,INSPF        ; Inspect files if option selected
   706   06D5' 78                  LD      A,B             ; Did we select any files?
   707   06D6' B1                  OR      C
   708   06D7' 32 005F"            LD      (HAVFIL),A
   709   06DA' 28 C2'              JR      Z,SYSOK0        ; ..jump if not
   710   06DC' E5                  PUSH    HL              ; Save ptr and count
   711   06DD' C5                  PUSH    BC
   712   06DE' 11 001F             LD      DE,ESIZE        ; Skip to end of loaded files and mark..
   713                                                     ; ..start of Work area
   714   06E1' 19          MCPY25: ADD     HL,DE           ; Pt to next
   715   06E2' 0B                  DEC     BC              ; Count down
   716   06E3' 78                  LD      A,B             ; Done?
   717   06E4' B1                  OR      C
   718   06E5' 20 FA'              JR      NZ,MCPY25

   720                     ; ..a better way to size the copy buffer would be to examine the alloc
   721                     ;  size of the source and target disks and use n*maxalc for buffer 
   722                     ;  size, where n is adjusted to the amount of free memory available.

   724   06E7' 22 0019"            LD      (WORKBF),HL     ; Save ptr to beginning of work buffer
   725   06EA' 24                  INC     H               ; Round buffer to page boundry
   726   06EB' CD 0CC1'            CALL    GETTOP          ; Get Page of lowest OS component in A
   727   06EE' 94                  SUB     H               ; Compute size of buffer area
   728   06EF' DA 09CD'            JP      C,TPAOVFL       ; Abort if not enough tpa
ZMAC Relocating Macro Assembler v 1.7,                       page   14
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   729   06F2' 2E C0               LD      L,PLIM          ; Set page limit
   730   06F4' BD                  CP      L               ; PLIM pages left?
   731   06F5' 38 01'              JR      C,PAGOK         ; If smaller than PLIM, use it
   732   06F7' 7D                  LD      A,L             ; Otherwise use PLIM (why PLIM?)
   733   06F8' 87          PAGOK:  ADD     A,A             ; Convert to # records
   734   06F9' 30 02'              JR      NC,PAGOK0       ; ..jump if less than 256 records
   735   06FB' 3E FF               LD      A,0FFH          ; Else set to 255 record limit
   736   06FD' 32 002E"    PAGOK0: LD      (PAGLIM),A      ; Set page limit
   737   0700' C1                  POP     BC              ; Restore ptrs
   738   0701' E1                  POP     HL

   740                     ; Main Copying Loop
   741                     ;   File names are pted to by HL and BC=Number of Files

   743   0702' AF          MCPY26: XOR     A               ; Clear the Verify error flag
   744   0703' 32 0062"            LD      (CPYERR),A
   745   0706' E5                  PUSH    HL              ; Save regs
   746   0707' C5                  PUSH    BC
   747   0708' CD 0BAF'            CALL    ABORTCK         ; Check for abort
   748   070B' AF                  XOR     A               ; Set flag for replacement abort check
   749   070C' 32 0061"            LD      (REPLCK),A
   750   070F' 3A 0000#            LD      A,(TIMTYP)      ; Can we do date stamping?
   751   0712' 32 003A"            LD      (DSFLAG),A      ; Set indicator accordingly
   752   0715' CD 0779'            CALL    MCOPYX          ; Copy Source (HL) to Dest using work buffer
   753   0718' CD 0BCA'            CALL    PRDONE          ; Print done message
   754   071B' 3A 0061"            LD      A,(REPLCK)      ; Did we abort a replace request?
   755   071E' B7                  OR      A
   756   071F' 28 4A'              JR      Z,MCPY28        ; ..bypass messages if so
   757   0721' 3A 003A"            LD      A,(DSFLAG)      ; Is DS function alive?
   758   0724' B7                  OR      A
   759   0725' 28 12'              JR      Z,NODATE        ; If not, no DS msg
   760   0727' 3A 0038"            LD      A,(QUIET)
   761   072A' B7                  OR      A               ; Are we operating Quietly?
   762   072B' 20 0C'              JR      NZ,NODATE       ; ..jump and don't print if Quiet
   763   072D' CD 0000#            CALL    EPRINT
   764   0730' 20 28 44 61         DEFB    ' (Dated)',0
   765   0739' CD 0BAF'    NODATE: CALL    ABORTCK         ; Check for abort
   766   073C' 3A 002F"            LD      A,(LSTCPY)      ; Last file copied?
   767   073F' B7                  OR      A               ; 0=no
   768   0740' 3A 001B"            LD      A,(VERFLG)      ; Verify?
   769   0743' 28 26'              JR      Z,MCPY28
   770   0745' B7                  OR      A               ; 0=no
   771   0746' C4 0A5B'            CALL    NZ,MCOPYV       ; Do verify if active

   773   0749' 3A 0037"            LD      A,(XMOVE)       ; Should we erase source file?
   774   074C' B7                  OR      A
   775   074D' 28 1C'              JR      Z,MCPY28        ; ..jump error msg if not
   776   074F' 3A 0062"            LD      A,(CPYERR)      ; Was there an error in Verify?
   777   0752' B7                  OR      A
   778   0753' 20 16'              JR      NZ,MCPY28       ; ..don't erase if so
   779   0755' CD 0B87'            CALL    SETSR0          ; Log Source, Get FCB & Init it
   780   0758' 21 0009             LD      HL,9
   781   075B' 19                  ADD     HL,DE
   782   075C' CB7E                BIT     7,(HL)          ; See if file is R/O
   783   075E' 20 0B'              JR      NZ,MCPY28       ; Don't delete if R/O
   784   0760' CD 0000#            CALL    F$DELETE        ; Delete the file
ZMAC Relocating Macro Assembler v 1.7,                       page   15
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   785   0763' CD 0000#            CALL    EPRINT          ; Clue that file erased
   786   0766' 20 28 58 29         DEFB    ' (X)',0

   788   076B' C1          MCPY28: POP     BC              ; Get regs
   789   076C' E1                  POP     HL
   790   076D' 11 001F             LD      DE,ESIZE        ; Pt to next file
   791   0770' 19                  ADD     HL,DE           ; Hl pts to next file
   792   0771' 0B                  DEC     BC              ; Count down
   793   0772' 78                  LD      A,B
   794   0773' B1                  OR      C
   795   0774' 20 8C'              JR      NZ,MCPY26
   796   0776' C3 0551'            JP      MCOPY           ; Copy next file spec

   798                     ;.....
   799                     ; Copy Source file pted to by HL to Destination

   801   0779' AF          MCOPYX: XOR     A               ; Set no copy of last file
   802   077A' 32 002F"            LD      (LSTCPY),A      ; Set flag

   804   077D' 3A 0060"            LD      A,(RENFLG)      ; Are we renaming?
   805   0780' B7                  OR      A               ; ..set flags
   806   0781' ED5B 002C"          LD      DE,(FCBD)       ; Set Destination FCB
   807   0785' 06 0C               LD      B,12
   808   0787' CC 0000#            CALL    Z,MOVEB         ; Move Drive Name&Typ if not
   809   078A' ED5B 002A"          LD      DE,(FCBS)       ; Set Source FCB
   810   078E' CD 0000#            CALL    MOVEB
   811   0791' 01 0010             LD      BC,FNSIZE       ; Offset to Stamp starting addr
   812   0794' 09                  ADD     HL,BC
   813   0795' 22 0041"            LD      (SRCTD),HL      ; ..and save
   814   0798' CD 0B9D'            CALL    SETDS0          ; Set Dest FCB & Init it
   815   079B' 62                  LD      H,D             ; Copy FCB ptr to HL
   816   079C' 6B                  LD      L,E
   817   079D' 06 0B               LD      B,11
   818   079F' 23          CLRATT: INC     HL              ; Bump to next filename character
   819   07A0' CBBE                RES     7,(HL)          ; Clear attribute bit
   820   07A2' 10 FB'              DJNZ    CLRATT
   821   07A4' CD 0BF6'            CALL    DFLTAD          ; Limit "E5" schmutz to 80H-FFH
   822   07A7' 0E 11               LD      C,17
   823   07A9' CD 0000#            CALL    BDOS            ; Search for the file
   824   07AC' 3C                  INC     A               ; Was it found?
   825   07AD' 67                  LD      H,A             ; Save the flag in H
   826   07AE' 3A 0022"            LD      A,(REPLAC)      ; Are we replacing existing?
   827   07B1' B7                  OR      A
   828   07B2' 7C                  LD      A,H             ; ..preparing found test
   829   07B3' 28 02'              JR      Z,NOTX00        ; ..jump if no replace
   830   07B5' B7                  OR      A               ; Found?
   831   07B6' C8                  RET     Z               ; ..return if no file

   833   07B7' CD 0000#    NOTX00: CALL    EPRINT
   834   07BA' 0D 0A 20 2D         DEFB    CR,LF,' -> ',0
   835   07C1' 13                  INC     DE              ; Point to first char of FileName
   836   07C2' CD 0000#            CALL    PFN1            ; ..and print
   837   07C5' 1B                  DEC     DE              ; Back up to Drive byte
   838   07C6' 7C                  LD      A,H             ; Retrieve flag
   839   07C7' 3D                  DEC     A               ; Was file found?
   840   07C8' FA 08CB'            JP      M,FNF           ; ..jump if File not found (0ffh)
ZMAC Relocating Macro Assembler v 1.7,                       page   16
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   841   07CB' 0F                  RRCA                    ; Convert directory code to offset in buffer
   842   07CC' 0F                  RRCA
   843   07CD' 0F                  RRCA
   844   07CE' C6 89               ADD     A,BUFF+9        ; Point to T1 (R/O)
   845   07D0' 6F                  LD      L,A
   846   07D1' 26 00               LD      H,0
   847   07D3' 7E                  LD      A,(HL)
   848   07D4' E6 80               AND     80H             ; Isolate R/O bit
   849   07D6' 32 0035"            LD      (ROFLG),A       ; Save as a flag
   850   07D9' 47                  LD      B,A             ; Stash in B for a moment
   851   07DA' 3A 0020"            LD      A,(EXRO)        ; Get R/O exist test flag
   852   07DD' A0                  AND     B               ; And with R/O status
   853   07DE' 47                  LD      B,A             ; Save result
   854   07DF' 3A 001F"            LD      A,(EXIST)       ; Now get exist test flag
   855   07E2' B0                  OR      B               ; Or with previous result
   856   07E3' 32 0036"            LD      (RPQFLG),A      ; RPQFLG = ((EXRO AND ROFLG) OR EXIST)
   857   07E6' 3A 0039"            LD      A,(NOREPL)      ; Don't copy if already there?
   858   07E9' B7                  OR      A               ; 0=copy anyway
   859   07EA' 20 79'              JR      NZ,FFND         ; ..jump & check file found by PUBlic if so
   860   07EC' 3A 0038"    ISX00:  LD      A,(QUIET)       ; Are we operating Quietly?
   861   07EF' B7                  OR      A
   862   07F0' 20 73'              JR      NZ,FFND         ; ..jump to bypass messages if so
   863   07F2' D5                  PUSH    DE
   864   07F3' 21 0050"            LD      HL,DESTTD       ; Get Timestamp here
   865   07F6' CD 0CB9'            CALL    GETSTMP         ; .using DSLIB function
   866   07F9' D1                  POP     DE
   867   07FA' CD 0000#            CALL    EPRINT
   868   07FD' 20 20 52 65         DEFB    '  Replac',0
   869   0806' 21 0CDD'            LD      HL,SUFFX1       ; Assume ?e are prompting for overwrite
   870   0809' 3A 0036"            LD      A,(RPQFLG)      ; ..now test our assumption
   871   080C' B7                  OR      A
   872   080D' 20 03'              JR      NZ,EXIST0       ; Jump if we want to pause
   873   080F' 21 0CE0'            LD      HL,SUFFX2       ; ..else print "ing"
   874   0812' CD 0000#    EXIST0: CALL    EPSTR
   875   0815' 3A 003A"            LD      A,(DSFLAG)      ; Are we still using Stamps?
   876   0818' B7                  OR      A
   877   0819' 28 4A'              JR      Z,FFND          ; ..jump if not
   878   081B' D5                  PUSH    DE              ; Save FCB
   879   081C' 2A 0041"            LD      HL,(SRCTD)      ; Get the vector to source Stamps
   880   081F' CD 0995'            CALL    CHKDAT          ; Set Mod/Create Date & check valid
   881   0822' 28 35'              JR      Z,UNDAT         ; ..print Undated if No date
   882   0824' EB                  EX      DE,HL           ; Put Source Date addr in DE
   883   0825' 21 0050"            LD      HL,DESTTD       ; Set Dest date & check validity
   884   0828' CD 0995'            CALL    CHKDAT
   885   082B' 28 2C'              JR      Z,UNDAT         ; ..print Undated if No date
   886   082D' 06 05               LD      B,5             ; ..for 5 bytes
   887   082F' 1A          CTDLP:  LD      A,(DE)
   888   0830' BE                  CP      (HL)            ; Are they the same?
   889   0831' 38 10'              JR      C,NEWER         ; .jump here if Newer version
   890   0833' 20 19'              JR      NZ,OLDER        ; ..jump here if Older version
   891   0835' 23                  INC     HL              ; Else
   892   0836' 13                  INC     DE              ; .bump ptrs cause same
   893   0837' 10 F6'              DJNZ    CTDLP           ; ..and loop til done (Same)
   894   0839' CD 0000#            CALL    EPRINT
   895   083C' 53 61 6D 65         DEFB    'Same',0
   896   0841' 18 21'              JR      DATEX           ; Rejoin code
ZMAC Relocating Macro Assembler v 1.7,                       page   17
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


   898   0843' CD 0000#    NEWER:  CALL    EPRINT
   899   0846' 4E 65 77 65         DEFB    'Newer',0
   900   084C' 18 16'              JR      DATEX

   902   084E' CD 0000#    OLDER:  CALL    EPRINT
   903   0851' 4F 6C 64 65         DEFB    'Older',0
   904   0857' 18 0B'              JR      DATEX

   906   0859' CD 0000#    UNDAT:  CALL    EPRINT
   907   085C' 55 6E 64 61         DEFB    'Undated',0
   908   0864' D1          DATEX:  POP     DE              ; Restore FCB

   910   0865' 3A 0035"    FFND:   LD      A,(ROFLG)
   911   0868' B7                  OR      A               ; Was file R/O
   912   0869' 28 08'              JR      Z,NORO          ; Jump if not
   913   086B' CD 0000#            CALL    EPRINT
   914   086E' 20 52 2F 4F         DEFB    ' R/O',0
   915   0873' 21 0007     NORO:   LD      HL,7            ; Offset to PUBlic/Path bit
   916   0876' 19                  ADD     HL,DE
   917   0877' CB7E                BIT     7,(HL)          ; Was it found via Public or Path?
   918   0879' 28 0D'              JR      Z,NOTPUB        ; ..jump if not
   919   087B' CD 0000#            CALL    EPRINT          ; Else print additional prompt
   920   087E' 20 28 50 75         DEFB    ' (Public)',0
   921   0888' 3A 0039"    NOTPUB: LD      A,(NOREPL)      ; Are we in a No Replacement mode?
   922   088B' B7                  OR      A
   923   088C' 28 0C'              JR      Z,FFND0         ; Jump if not
   924   088E' CD 0000#            CALL    EPRINT
   925   0891' 20 43 61 6E         DEFB    ' Can''t!',0
   926   0899' C9                  RET                     ; Return with no action (no replace)

   928   089A' 3A 0036"    FFND0:  LD      A,(RPQFLG)      ; Do we need to propt user?
   929   089D' B7                  OR      A
   930   089E' 28 19'              JR      Z,EAT1          ; Jump if not to copy
   931   08A0' CD 0000#            CALL    EPRINT
   932   08A3' 20 28 59 2F         DEFB    ' (Y/[N])? ',0
   933   08AE' CD 0BC4'            CALL    GETCH           ; Get response
   934   08B1' FE 0D               CP      CR              ; Yes?
   935   08B3' C4 0000#            CALL    NZ,COUT         ; ..echo if Not CR
   936   08B6' FE 59               CP      'Y'             ; Is it an explicit Yes?
   937   08B8' C0                  RET     NZ              ; ..return if no replace

   939   08B9' 3A 0035"    EAT1:   LD      A,(ROFLG)       ; Is this an R/O file?
   940   08BC' B7                  OR      A
   941   08BD' 28 09'              JR      Z,EAT1A         ; No need to set attributes if not
   942   08BF' 21 0009             LD      HL,9            ; Offset to R/O attribute
   943   08C2' 19                  ADD     HL,DE
   944   08C3' CBBE                RES     7,(HL)
   945   08C5' CD 0983'            CALL    DOATTR          ; Make file R/W
   946   08C8' CD 0000#    EAT1A:  CALL    F$DELETE        ; ..and delete it
   947   08CB' CD 0000#    FNF:    CALL    EPRINT
   948   08CE' 2E 2E 00            DEFB    '..',0
   949   08D1' 3E FF               LD      A,0FFH          ; Set copy of last file
   950   08D3' 32 002F"            LD      (LSTCPY),A      ; Set flag
   951   08D6' 32 0061"            LD      (REPLCK),A      ; ..and another to show No Replacement Abort
   952   08D9' CD 0000#            CALL    INITFCB         ; Insure clean FCB
ZMAC Relocating Macro Assembler v 1.7,                       page   18
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

   953   08DC' CD 0000#            CALL    F$MAKE          ; Create new file
   954   08DF' 3C                  INC     A               ; Check for full directory
   955   08E0' CA 0A0F'            JP      Z,DIRFUL        ; Report it

   957                     ; Open Source File in prep for Copy

   959   08E3' CD 0000#            CALL    CRC3CLR         ; Clear CRC value in case we're verifying
   960   08E6' CD 0B87'            CALL    SETSR0          ; Log Source, Initialize & Set FCB
   961   08E9' CD 0000#            CALL    F$OPEN          ; Open file

   963                     ; This loop, which starts at MCPYX, Copies the file from Source to Dest

   965   08EC' CD 0B93'    MCPYX:  CALL    SETSRC          ; Log Source & Set Src FCB
   966   08EF' 2A 0019"            LD      HL,(WORKBF)     ; Pt to buffer to copy into
   967   08F2' CD 0A25'            CALL    LOAD            ; Load file into workbf
   968   08F5' 3A 0031"            LD      A,(BCNT)        ; If count=0, then done
   969   08F8' B7                  OR      A
   970   08F9' 28 27'              JR      Z,MC2DONE

   972                     ; Copy to Disk

   974   08FB' CD 0BA8'            CALL    LOGD            ; Log in destination
   975   08FE' 2A 0019"            LD      HL,(WORKBF)     ; Pt to buffer
   976   0901' CD 0000#    MCPYD1: CALL    SETDMA          ; Set dma address pted to by HL
   977   0904' 11 0080             LD      DE,128          ; Incr HL by 128
   978   0907' 19                  ADD     HL,DE           ; HL pts to next block
   979   0908' ED5B 002C"          LD      DE,(FCBD)       ; Write to destination file
   980   090C' CD 0000#            CALL    F$WRITE
   981   090F' B7                  OR      A               ; Ok?
   982   0910' C2 09DD'            JP      NZ,MCPYDERR

   984                     ; Count down to next block

   986   0913' 3A 0031"            LD      A,(BCNT)        ; Get block count
   987   0916' 3D                  DEC     A               ; Count down
   988   0917' 32 0031"            LD      (BCNT),A
   989   091A' 20 E5'              JR      NZ,MCPYD1
   990   091C' 3A 0032"            LD      A,(CONT)        ; Continue?
   991   091F' B7                  OR      A               ; Cont if not zero
   992   0920' 20 CA'              JR      NZ,MCPYX

   994                     ; End of Copy Loop

   996   0922' CD 0B93'    MC2DONE: CALL   SETSRC          ; Log source & Set FCB
   997   0925' CD 0000#            CALL    F$CLOSE

   999   0928' CD 0BA4'            CALL    SETDST          ; Log Dest & Set FCB
  1000   092B' CD 0000#            CALL    F$CLOSE

  1002   092E' D5                  PUSH    DE
  1003   092F' 21 003B"            LD      HL,TMPTIM       ; Set Addr for Date & Time
  1004   0932' CD 0000#            CALL    RCLOCK          ; Attempt a clock read
  1005   0935' 20 10'              JR      NZ,NOCLOK       ; ..jump if not good read

  1007   0937' 2A 0041"            LD      HL,(SRCTD)      ; Set source TD
  1008   093A' 11 0005             LD      DE,5            ; ..offset to Last Access
ZMAC Relocating Macro Assembler v 1.7,                       page   19
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1009   093D' 19                  ADD     HL,DE
  1010   093E' EB                  EX      DE,HL           ; Put in DE reg for dest
  1011   093F' 21 003B"            LD      HL,TMPTIM       ; Point to source tim & dat
  1012   0942' 01 0005             LD      BC,5            ; Move 5 bytes
  1013   0945' EDB0                LDIR
  1014   0947' D1          NOCLOK: POP     DE
  1015   0948' D5                  PUSH    DE              ; ..save pointer for attr set
  1016   0949' CD 0000#            CALL    INITFCB         ; Initialize FCB to start
  1017   094C' 2A 0041"            LD      HL,(SRCTD)      ; Get addr of New file's Stamp
  1018   094F' CD 0CB4'            CALL    PUTSTMP         ; Attempt Put Stamp to Disk
  1019   0952' CD 0000#            CALL    CRC3DONE        ; Get CRC value in case Verifying
  1020   0955' 22 0028"            LD      (CRCVAL),HL     ; Save CRC value or junk if Not Verifying
  1021                                             ;..fall thru, set Attr of Dest to those of Source
  1022   0958' ED5B 002A"          LD      DE,(FCBS)       ; Source FCB contains orig attributes
  1023   095C' 13                  INC     DE              ; Point to 1st attr
  1024   095D' 2A 002C"            LD      HL,(FCBD)       ; Get destination FCB
  1025   0960' 23                  INC     HL              ; ..and pt to 1st attr
  1026   0961' 0E 00               LD      C,0             ; Clear C. Will have count of attributes set
  1027   0963' CD 098B'            CALL    CKATTR          ; Check/Set 1st attr
  1028   0966' 13                  INC     DE              ; Go to Attr F3
  1029   0967' 23                  INC     HL
  1030   0968' 06 08               LD      B,8             ; Do 8 and end at Archive
  1031   096A' CD 098B'    CKATTL: CALL    CKATTR          ; Do a bit/byte
  1032   096D' 10 FB'              DJNZ    CKATTL          ; ..and loop til done
  1033   096F' D1                  POP     DE              ; ...restore FCB pointer
  1034   0970' 79                  LD      A,C             ; Any Attributes Set?
  1035   0971' B7                  OR      A
  1036   0972' C4 0983'            CALL    NZ,DOATTR       ; Set the attributes if any need setting
  1037   0975' 3A 0021"            LD      A,(ARCHIV)      ; Are we in Archiving Mode?
  1038   0978' B7                  OR      A
  1039   0979' C8                  RET     Z               ; ..return if not
  1040   097A' CD 0B93'            CALL    SETSRC          ; Log source & Set FCB
  1041   097D' 21 000B             LD      HL,11           ; Else offset to Archive Bit
  1042   0980' 19                  ADD     HL,DE
  1043   0981' CBFE                SET     7,(HL)          ; ..and Show that it has been Archived
  1044   0983' CD 0000#    DOATTR: CALL    INITFCB         ; Init FCB pted to by DE
  1045   0986' 0E 1E               LD      C,30            ; Set file attributes
  1046   0988' C3 0000#            JP      BDOS            ; MCOPYX returns to caller via BDOS

  1048                     ; Little routine to help with attribute setting

  1050   098B' 1A          CKATTR: LD      A,(DE)          ; Get source byte
  1051   098C' 17                  RLA                     ; ..and test attr
  1052   098D' 30 03'              JR      NC,CKATT0       ; Jump if not set
  1053   098F' CBFE                SET     7,(HL)          ; ..else set dest attr
  1054   0991' 0C                  INC     C               ; ..and count it
  1055   0992' 13          CKATT0: INC     DE              ; Advance to next byte
  1056   0993' 23                  INC     HL
  1057   0994' C9                  RET

  1059                     ;.....
  1060                     ; Check validity of Mod/Create dates
  1061                     ; Enter: HL --> Create Date in std datespec
  1062                     ; Exit : HL --> Valid Mod/Create date field, or Create field if invalid
  1063                     ;        AF = A=0, Zero flag set (Z) if invalid
  1064                     ;               A <> 0, Zero Flag Clear (NZ) if date valid
ZMAC Relocating Macro Assembler v 1.7,                       page   20
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


  1066   0995' D5          CHKDAT: PUSH    DE              ; Preserve other regs
  1067   0996' EB                  EX      DE,HL           ; Put Create date addr in DE
  1068   0997' 21 000A             LD      HL,10           ; Set offset to Modify field
  1069   099A' 19                  ADD     HL,DE           ; ..and offset to Modify Date
  1070   099B' 7E                  LD      A,(HL)          ; Is it valid?
  1071   099C' 23                  INC     HL
  1072   099D' B6                  OR      (HL)            ; Or Year and Month
  1073   099E' 2B                  DEC     HL              ; ..back up to Year
  1074   099F' 20 05'              JR      NZ,CHKDA0       ; Jump if Date valid
  1075   09A1' EB                  EX      DE,HL           ; ..else put Create date addr in HL
  1076   09A2' 7E                  LD      A,(HL)          ; Check validity
  1077   09A3' 23                  INC     HL
  1078   09A4' B6                  OR      (HL)
  1079   09A5' 2B                  DEC     HL
  1080   09A6' D1          CHKDA0: POP     DE              ; Restore regs
  1081   09A7' C9                  RET                     ; ..with flags set

  1083                     ;.....
  1084                     ; Convert Z3 FCB DU into DU in BC

  1086   09A8' E5          DUCVRT: PUSH    HL              ; Save regs
  1087   09A9' D5                  PUSH    DE
  1088   09AA' 1A                  LD      A,(DE)          ; Get disk
  1089   09AB' B7                  OR      A               ; Current?
  1090   09AC' 20 04'              JR      NZ,DUCV1
  1091   09AE' 3A 0023"            LD      A,(CDISK)       ; Get current
  1092   09B1' 3C                  INC     A               ; Add 1 for a=1
  1093   09B2' 3D          DUCV1:  DEC     A               ; A=0
  1094   09B3' 47                  LD      B,A
  1095   09B4' 21 000D             LD      HL,13           ; Offset to user
  1096   09B7' 19                  ADD     HL,DE
  1097   09B8' 4E                  LD      C,(HL)          ; Get user
  1098   09B9' D1                  POP     DE              ; Restore regs
  1099   09BA' E1                  POP     HL
  1100   09BB' C9                  RET

  1102                     ; Format Error

  1104   09BC' CD 0000#    FORMERR: CALL   EPRINT
  1105   09BF' 0D 0A 20 45         DEFB    CR,LF,' Error: ',0
  1106   09CA' C3 0000#            JP      EPSTR           ; Print error & return

  1108                     ; TPA Overflow

  1110   09CD' CD 0000#    TPAOVFL: CALL   EPRINT
  1111   09D0' 0D 0A 54 50         DEFB    CR,LF,'TPA Ovfl',0
  1112   09DB' 18 2C'              JR      BADCOPY

  1114                     ; Write Error

  1116   09DD' CD 0000#    MCPYDERR: CALL  EPRINT
  1117   09E0' 0D 0A 44 69         DEFB    CR,LF,'Disk Full or Write Error !',0
  1118   09FD' CD 0BA4'            CALL    SETDST          ; Log in Dest & Set FCB
  1119   0A00' CD 0000#            CALL    F$CLOSE         ; ..and close the file
  1120   0A03' CD 0000#            CALL    INITFCB         ; Initialize the FCB
ZMAC Relocating Macro Assembler v 1.7,                       page   21
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1121   0A06' CD 0000#            CALL    F$DELETE        ; ...then Kill it
  1122   0A09' CD 0AAE'    BADCOPY: CALL   SETEFLAG        ; Set ZCPR3 Error flag
  1123   0A0C' C3 04F1'            JP      CPM             ; ..and return to OS

  1125                     ; Directory Full Error

  1127   0A0F' CD 0000#    DIRFUL: CALL    EPRINT
  1128   0A12' 0D 0A 44 69         DEFB    CR,LF,'Directory Full',0
  1129   0A23' 18 E4'              JR      BADCOPY

  1131                     ;.....
  1132                     ; Load Buffer pted to by HL from file whose FCB is pted to by DE
  1133                     ;   On Output, BCNT=Number of blocks loaded (up to 128) and
  1134                     ;   CONT=0 if Done or 128 if Not Done

  1136   0A25' AF          LOAD:   XOR     A               ; A=0
  1137   0A26' 32 0031"            LD      (BCNT),A        ; Set block count
  1138   0A29' 32 0032"            LD      (CONT),A        ; Turn off continuation flag

  1140                     ; Main Copy Loop

  1142   0A2C' CD 0000#    MCPY:   CALL    SETDMA          ; Set DMA to block pted to by HL
  1143   0A2F' CD 0000#            CALL    F$READ          ; ..and Read block
  1144   0A32' B7                  OR      A               ; End of file?
  1145   0A33' C0                  RET     NZ              ; ..return if so
  1146   0A34' 3A 001B"            LD      A,(VERFLG)      ; Doing verify?
  1147   0A37' B7                  OR      A               ; ..set flags
  1148   0A38' 28 0B'              JR      Z,LOAD1         ; ...jump w/no CRC if No ver
  1149   0A3A' E5                  PUSH    HL              ; Save ptr to DMA
  1150   0A3B' 06 80               LD      B,128           ; Update CRC for 128 bytes
  1151   0A3D' 7E          MCPYCRC: LD     A,(HL)          ; Get byte
  1152   0A3E' CD 0000#            CALL    CRC3UPD         ; Update CRC
  1153   0A41' 23                  INC     HL              ; Pt to next
  1154   0A42' 10 F9'              DJNZ    MCPYCRC         ; ..Count down and loop til done
  1155   0A44' E1                  POP     HL              ; Retrieve ptr to DMA
  1156   0A45' 01 0080     LOAD1:  LD      BC,128          ; Set # bytes in Sector
  1157   0A48' 09                  ADD     HL,BC           ; ..and pt to nxt log sctr
  1158   0A49' 3A 0031"            LD      A,(BCNT)        ; Get block count
  1159   0A4C' 3C                  INC     A               ; Increment it
  1160   0A4D' 32 0031"            LD      (BCNT),A        ; ..and store
  1161   0A50' 47                  LD      B,A             ; Block count in B
  1162   0A51' 3A 002E"            LD      A,(PAGLIM)      ; Get page limit (in records)
  1163   0A54' B8                  CP      B               ; Buffer full?
  1164   0A55' 20 D5'              JR      NZ,MCPY         ; ..loop if not
  1165   0A57' 32 0032"            LD      (CONT),A        ; Else set continuation flag
  1166   0A5A' C9                  RET

  1168                     ; Verify Phase

  1170   0A5B' 3A 0038"    MCOPYV: LD      A,(QUIET)       ; Check for quiet
  1171   0A5E' B7                  OR      A               ; Nz=quiet
  1172   0A5F' 20 0E'              JR      NZ,MCPYV
  1173   0A61' CD 0000#            CALL    EPRINT
  1174   0A64' 20 20 56 65         DEFB    '  Verify..',0
  1175   0A6F' CD 0000#    MCPYV:  CALL    CRC3CLR         ; Clear crck value
  1176   0A72' CD 0B9D'            CALL    SETDS0          ; Log in Dest, Set FCB & Init
ZMAC Relocating Macro Assembler v 1.7,                       page   22
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1177   0A75' CD 0000#            CALL    F$OPEN          ; Open file

  1179                     ; **** Main Verify Loop ****

  1181   0A78' 2A 0019"    VERLOOP: LD     HL,(WORKBF)     ; Load input buffer from destination
  1182   0A7B' ED5B 002C"          LD      DE,(FCBD)
  1183   0A7F' CD 0A25'            CALL    LOAD            ; Load and compute CRC value
  1184   0A82' 3A 0031"            LD      A,(BCNT)        ; Done if no bytes loaded
  1185   0A85' B7                  OR      A
  1186   0A86' 28 06'              JR      Z,VERCRC
  1187   0A88' 3A 0032"            LD      A,(CONT)        ; Continue?
  1188   0A8B' B7                  OR      A               ; 0=no
  1189   0A8C' 20 EA'              JR      NZ,VERLOOP

  1191                     ; Verify Done

  1193   0A8E' CD 0000#    VERCRC: CALL    CRC3DONE        ; Update complete, value in HL
  1194   0A91' ED5B 0028"          LD      DE,(CRCVAL)     ; Get old CRC value into DE
  1195   0A95' AF                  XOR     A               ; Clears carry flag
  1196   0A96' ED52                SBC     HL,DE           ; Compare HL to DE
  1197   0A98' CA 0BCA'            JP      Z,PRDONE        ; Print done msg or fall thru to error msg
  1198                                             ;..else fall thru to Verify Error
  1199   0A9B' 21 0030"            LD      HL,VERCNT       ; Increment error count
  1200   0A9E' 34                  INC     (HL)
  1201   0A9F' CD 0000#            CALL    EPRINT
  1202   0AA2' 20 2E 2E 42         DEFB    ' ..Bad',0
  1203   0AA9' 3E FF               LD      A,0FFH          ; Set flag to show error in Verify
  1204   0AAB' 32 0062"            LD      (CPYERR),A
  1205   0AAE'             SETEFLAG:
  1206   0AAE' 3A 0033"            LD      A,(NOMSGS)      ; Set error flag if there
  1207   0AB1' B7                  OR      A               ; Is a message buffer
  1208   0AB2' C0                  RET     NZ
  1209   0AB3' 2F                  CPL
  1210   0AB4' C3 0000#            JP      PUTER2

  1212                     ; **** MCOPY Utilities ****
  1213                     ;.....
  1214                     ; Allow user to inspect files for Copy
  1215                     ;   First file name pted to by HL, BC = Number of files
  1216                     ;   On Exit, BC = Number of selected files

  1218   0AB7' CD 0000#    INSPF:  CALL    EPRINT
  1219   0ABA' 0D 0A 20 49         DEFB    CR,LF,' Inspect -- '
  1220   0AC8' 59 65 73 2C         DEFB    'Yes, No (def), Skip Rest',0
  1221   0AE1' E5                  PUSH    HL              ; Save ptr to first file
  1222   0AE2' C5                  PUSH    BC              ; Save file count
  1223   0AE3' 11 001F             LD      DE,ESIZE        ; Entries are esize bytes apart
  1224   0AE6' CBBE        INSPF0: RES     7,(HL)          ; Clear MSB to mark file for no copy
  1225   0AE8' 19                  ADD     HL,DE           ; Pt to next
  1226   0AE9' 0B                  DEC     BC              ; Count down
  1227   0AEA' 78                  LD      A,B             ; Done?
  1228   0AEB' B1                  OR      C
  1229   0AEC' 20 F8'              JR      NZ,INSPF0
  1230   0AEE' C1                  POP     BC              ; Restore and save again
  1231   0AEF' E1                  POP     HL
  1232   0AF0' E5                  PUSH    HL
ZMAC Relocating Macro Assembler v 1.7,                       page   23
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1233   0AF1' C5                  PUSH    BC
  1234   0AF2' CD 0000#    INSPF1: CALL    CRLF            ; New line
  1235   0AF5' EB                  EX      DE,HL           ; Put FN in DE
  1236   0AF6' 13                  INC     DE              ; ..and point to Name
  1237   0AF7' CD 0000#            CALL    PFN1            ; Print it
  1238   0AFA' 1B                  DEC     DE              ; Re-align ptr to file entry
  1239   0AFB' EB                  EX      DE,HL           ; Restore regs
  1240   0AFC' CD 0000#            CALL    EPRINT
  1241   0AFF' 20 2D 20 28         DEFB    ' - (Y/N/S)? ',0
  1242   0B0C' CD 0BC4'            CALL    GETCH           ; Get response
  1243   0B0F' CD 0000#            CALL    COUT            ; Echo
  1244   0B12' FE 53               CP      'S'             ; Skip?
  1245   0B14' 28 0F'              JR      Z,INSPFA
  1246   0B16' FE 59               CP      'Y'             ; Yes?
  1247   0B18' 20 02'              JR      NZ,INSPF2
  1248   0B1A' CBFE                SET     7,(HL)          ; Mark File
  1249   0B1C' 11 001F     INSPF2: LD      DE,ESIZE        ; Pt to next file
  1250   0B1F' 19                  ADD     HL,DE
  1251   0B20' 0B                  DEC     BC              ; Count down
  1252   0B21' 78                  LD      A,B             ; Done?
  1253   0B22' B1                  OR      C
  1254   0B23' 20 CD'              JR      NZ,INSPF1
  1255   0B25' C1          INSPFA: POP     BC              ; Get count
  1256   0B26' E1                  POP     HL              ; Get ptr to first file
  1257   0B27' C3 0F0B'            JP      DIRPAK          ; Repack directory

  1259                     ;.....
  1260                     ; Select only files which do Not have Archive Bit set
  1261                     ; Enter:HL --> First name in Directory
  1262                     ;       BC = Number of Files
  1263                     ; Exit :BC = New Number of Files
  1264                     ;       HL --> First name in Directory

  1266   0B2A' E5          SELARC: PUSH    HL              ; Save values
  1267   0B2B' C5                  PUSH    BC
  1268   0B2C' CBBE        SELAR0: RES     7,(HL)          ; Set initially for No Select
  1269   0B2E' EB                  EX      DE,HL           ; Put file pointer in DE
  1270   0B2F' 21 000B             LD      HL,11           ; ..and offset by Archive Bit
  1271   0B32' 19                  ADD     HL,DE
  1272   0B33' CB7E                BIT     7,(HL)          ; Is it already Archived?
  1273   0B35' 20 04'              JR      NZ,SELAR1       ; ..jump if so to bypass
  1274   0B37' 6B                  LD      L,E             ; Else copy record start to HL
  1275   0B38' 62                  LD      H,D
  1276   0B39' CBFE                SET     7,(HL)          ; ..and select it
  1277   0B3B' 21 001F     SELAR1: LD      HL,ESIZE        ; Offset to Next record
  1278   0B3E' 19                  ADD     HL,DE
  1279   0B3F' 0B                  DEC     BC              ; Decrement count
  1280   0B40' 78                  LD      A,B             ; Are we out of records?
  1281   0B41' B1                  OR      C
  1282   0B42' 20 E8'              JR      NZ,SELAR0       ; ..loop if Not
  1283   0B44' 18 DF'              JR      INSPFA          ; Else exit by repacking directory

  1285                     ;.....
  1286                     ; Delete files from the directory list in the EXCLUDE list
  1287                     ; Enter:HL --> First name in Directory
  1288                     ;       BC = Number of files
ZMAC Relocating Macro Assembler v 1.7,                       page   24
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1289                     ; Exit :BC = New number of files
  1290                     ;       HL --> First name in Directory

  1292   0B46' E5          CHKXCL: PUSH    HL              ; Save values
  1293   0B47' C5                  PUSH    BC
  1294   0B48' 11 002B'    CHKEX0: LD      DE,EXCLUD       ; Point to Exclude List
  1295   0B4B' CD 0B5E'            CALL    CHKXXX          ; Does it Match?
  1296   0B4E' 28 02'              JR      Z,CHKEX1        ; ..jump if so (no select)
  1297   0B50' CBFE                SET     7,(HL)          ; Else select it
  1298   0B52' EB          CHKEX1: EX      DE,HL           ; Advance to next entry
  1299   0B53' 21 001F             LD      HL,ESIZE
  1300   0B56' 19                  ADD     HL,DE
  1301   0B57' 0B                  DEC     BC              ; Decrement file count
  1302   0B58' 78                  LD      A,B             ; Are we out of records?
  1303   0B59' B1                  OR      C
  1304   0B5A' 20 EC'              JR      NZ,CHKEX0       ; ..loop if not
  1305   0B5C' 18 C7'              JR      INSPFA          ; Else exit by repacking dir

  1307                     ; Check current entry against exclude list

  1309   0B5E' C5          CHKXXX: PUSH    BC              ; Preserve regs
  1310   0B5F' E5                  PUSH    HL
  1311   0B60' 23          CHKXX0: INC     HL              ; Step by User #
  1312   0B61' 06 0B               LD      B,11            ; Compare FN and FT
  1313   0B63' 1A                  LD      A,(DE)          ; Any entry here?
  1314   0B64' FE 20               CP      ' '             ; ..not if 1st char is space
  1315   0B66' 28 12'              JR      Z,CHKXX2        ; ...jump if no entry
  1316   0B68' 1A          CHKXX1: LD      A,(DE)          ; ..char by char
  1317   0B69' FE 3F               CP      '?'             ; Accomodate wildcard char
  1318   0B6B' 28 05'              JR      Z,CHKX??        ; ..jump if wild
  1319   0B6D' 96                  SUB     (HL)            ; Else compare to entry char
  1320   0B6E' E6 7F               AND     7FH             ; ...masking MSB
  1321   0B70' 20 08'              JR      NZ,CHKXX2       ; Jump if not equal
  1322   0B72' 23          CHKX??: INC     HL              ; Bump ptrs
  1323   0B73' 13                  INC     DE
  1324   0B74' 10 F2'              DJNZ    CHKXX1          ; ..loop til all checked
  1325   0B76' AF                  XOR     A               ; Clear A in case "?" at end
  1326   0B77' E1          CHKXX3: POP     HL              ; Restore regs..
  1327   0B78' C1                  POP     BC              ; ..leaving flags set
  1328   0B79' C9                  RET

  1330   0B7A' 13          CHKXX2: INC     DE              ; Advance past Exc chars
  1331   0B7B' 10 FD'              DJNZ    CHKXX2          ; ..and loop til done
  1332   0B7D' E1                  POP     HL              ; Restore Dir entry ptr
  1333   0B7E' E5                  PUSH    HL              ; ..keeping it on stack
  1334   0B7F' 1A                  LD      A,(DE)          ; Are we at table end?
  1335   0B80' B7                  OR      A
  1336   0B81' 20 DD'              JR      NZ,CHKXX0       ; ..check another name if not
  1337   0B83' F6 FF               OR      0FFH            ; Signify no match
  1338   0B85' 18 F0'              JR      CHKXX3          ; Else exit here

  1340                     ;.....
  1341                     ; Log in Source User/Disk

  1343   0B87' ED5B 002A"  SETSR0: LD      DE,(FCBS)       ; Get Source FCB addr
  1344   0B8B' CD 0000#            CALL    INITFCB         ; ..and Initialize it
ZMAC Relocating Macro Assembler v 1.7,                       page   25
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1345   0B8E' 3A 0025"            LD      A,(SDRIVE)      ; Load Source drive byte
  1346   0B91' 3C                  INC     A               ; ..prepared for FCB drive #
  1347   0B92' 12                  LD      (DE),A          ; ...and save
  1348   0B93' ED5B 002A"  SETSRC: LD      DE,(FCBS)       ; Get Source FCB addr again
  1349   0B97' ED4B 0024"  LOGS:   LD      BC,(SUSER)
  1350   0B9B' 18 0F'              JR      LOGDS

  1352                     ;.....
  1353                     ; Log in Destination User/Disk

  1355   0B9D' ED5B 002C"  SETDS0: LD      DE,(FCBD)       ; Get Destination FCB addr
  1356   0BA1' CD 0000#            CALL    INITFCB         ; ..and Initialize it
  1357   0BA4' ED5B 002C"  SETDST: LD      DE,(FCBD)       ; Get Dest FCB addr again
  1358   0BA8' ED4B 0026"  LOGD:   LD      BC,(DUSER)
  1359   0BAC' C3 0000#    LOGDS:  JP      LOGUD

  1361                     ;.....
  1362                     ; Check for Abort from Keyboard

  1364   0BAF' CD 0000#    ABORTCK: CALL   CONDIN          ; Conditional input
  1365   0BB2' C8                  RET     Z
  1366   0BB3' FE 03               CP      CTRLC           ; Abort?
  1367   0BB5' C0                  RET     NZ              ; ..return if not
  1368   0BB6' CD 0000#            CALL    EPRINT          ; Else say we are aborting
  1369   0BB9' 0D 0A 41 62         DEFB    CR,LF,'Abort',0
  1370   0BC1' C3 04F1'            JP      CPM             ; ..and qui

  1372                     ;.....
  1373                     ; Get a character from the keyboard converting to uppercase

  1375   0BC4' CD 0000#    GETCH:  CALL    CIN             ; Get a char
  1376   0BC7' C3 0000#            JP      CAPS            ; Convert to Uppercase and return

  1378                     ;.....
  1379                     ; Print Done Message

  1381   0BCA' 3A 0038"    PRDONE: LD      A,(QUIET)       ; Check for quiet
  1382   0BCD' B7                  OR      A               ; Nz=quiet
  1383   0BCE' C0                  RET     NZ
  1384   0BCF' 3A 002F"            LD      A,(LSTCPY)      ; Last file copied?
  1385   0BD2' B7                  OR      A               ; 0 = no
  1386   0BD3' 20 1A'              JR      NZ,DID
  1387   0BD5' 3A 0039"            LD      A,(NOREPL)      ; Not copied because already there?
  1388   0BD8' B7                  OR      A               ; Nz = yes
  1389   0BD9' C8                  RET     Z
  1390   0BDA' CD 0000#            CALL    EPRINT
  1391   0BDD' 20 41 6C 72         DEFB    ' Already Present',0
  1392   0BEE' C9                  RET

  1394   0BEF' CD 0000#    DID:    CALL    EPRINT
  1395   0BF2' 4F 6B 00            DEFB    'Ok',0
  1396   0BF5' C9                  RET

  1398                     ;.....
  1399                     ; Set DMA Address to Default buffer (80H)

ZMAC Relocating Macro Assembler v 1.7,                       page   26
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1401   0BF6' 21 0080     DFLTAD: LD      HL,BUFF
  1402   0BF9' C3 0000#            JP      SETDMA          ; Set it and return

  1404                     ;.....
  1405                     ; Print error on Ambiguous Rename attempt w/secondary utility ID print

  1407   0BFC' CD 0000#    AMBERR: CALL    EPRINT
  1408   0BFF' 0D 0A 43 61         DEFB    CR,LF,'Can''t Rename Ambiguously -- ',0
  1409   0C1E' ED4B 0024"  PRTS2D: LD      BC,(SUSER)      ; Print Source File ID
  1410   0C22' CD 0C49'            CALL    PRNDU           ; Print source DU w/":"
  1411   0C25' ED5B 002A"          LD      DE,(FCBS)       ; Print file spec
  1412   0C29' 13                  INC     DE              ; Pt to file Name
  1413   0C2A' CD 0000#            CALL    PFN1            ; ..and print
  1414   0C2D' CD 0000#            CALL    EPRINT
  1415   0C30' 20 74 6F 20         DEFB    ' to ',0
  1416   0C35' ED4B 0026"          LD      BC,(DUSER)
  1417   0C39' CD 0C49'            CALL    PRNDU           ; Print Dest DU w/":"
  1418   0C3C' 3A 0060"            LD      A,(RENFLG)      ; Are we renaming?
  1419   0C3F' B7                  OR      A
  1420   0C40' C8                  RET     Z               ; ..return if not
  1421   0C41' ED5B 002C"          LD      DE,(FCBD)       ; Else print Dest file spec
  1422   0C45' 13                  INC     DE              ; Pt to File Name
  1423   0C46' C3 0000#            JP      PFN1            ; ..print and return via Stack

  1425                     ;.....
  1426                     ; PRINT "DU:" from values in BC register

  1428   0C49' 78          PRNDU:  LD      A,B
  1429   0C4A' C6 41               ADD     A,'A'
  1430   0C4C' CD 0000#            CALL    COUT
  1431   0C4F' 79                  LD      A,C
  1432   0C50' CD 0000#            CALL    PAFDC
  1433   0C53' 3E 3A               LD      A,':'
  1434   0C55' C3 0000#            JP      COUT

  1436                     ;.....
  1437                     ; Print actual COMfile name if we can,
  1438                     ; otherwise print "COPY"

  1440   0C58' 3A 000B'    COMNAM: LD      A,(Z3EADR+1)    ; Do we have an environment?
  1441   0C5B' B7                  OR      A
  1442   0C5C' C4 0000#            CALL    NZ,GETEFCB      ; .Get EFCB name if so
  1443   0C5F' 28 0E'              JR      Z,NOEFCB        ; ..Print "COPY" if Not
  1444   0C61' 06 08       PRNNAM: LD      B,8
  1445   0C63' 23          COMNML: INC     HL
  1446   0C64' 7E                  LD      A,(HL)
  1447   0C65' E6 7F               AND     7FH
  1448   0C67' FE 20               CP      ' '
  1449   0C69' C4 0000#            CALL    NZ,COUT
  1450   0C6C' 10 F5'              DJNZ    COMNML
  1451   0C6E' C9                  RET

  1453   0C6F' CD 0000#    NOEFCB: CALL    EPRINT
  1454   0C72' 43 4F 50 59         DEFB    'COPY',0
  1455   0C77' C9                  RET

ZMAC Relocating Macro Assembler v 1.7,                       page   27
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1457                     ;.....
  1458                     ; Scan 11-char string for specified character ("?")
  1459                     ; Enter: HL --> Start of string -1
  1460                     ; Exit :  B = 0
  1461                     ;         A = Count of specified character
  1462                     ; Destroys HL & C.  DE unaffected

  1464   0C78' 3E 3F       SCANQQ: LD      A,'?'           ; Set search for Quest Mrks
  1465   0C7A' 23          SCAN11: INC     HL              ; Advance to name field
  1466   0C7B' 01 0B00             LD      BC,11*256+0     ; Counter (B) = 11, (C) = 0
  1467   0C7E' BE          SCAN1A: CP      (HL)            ; Compare a char
  1468   0C7F' 20 01'              JR      NZ,SCAN1B       ; ..jump if not same
  1469   0C81' 0C                  INC     C               ; Else bump found counter
  1470   0C82' 23          SCAN1B: INC     HL              ; ..point to next
  1471   0C83' 10 F9'              DJNZ    SCAN1A          ; Loop til done
  1472   0C85' 79                  LD      A,C             ; Set results in reg
  1473   0C86' B7                  OR      A               ; ..and set flags
  1474   0C87' C9                  RET

  1476                     ;.....
  1477                     ; AI (allegedly intelligent) routine to check for a string
  1478                     ; containing legal option letters ONLY.

  1480   0C88' 7E          OPTQ:   LD      A,(HL)
  1481   0C89' D6 2F               SUB     OPTC            ; Slash is explicit option delim
  1482   0C8B' 20 06'              JR      NZ,NOSLSH       ; If not slash, do char. check
  1483   0C8D' 77                  LD      (HL),A          ; If slash, null it out (A = 0)
  1484   0C8E' 2B                  DEC     HL
  1485   0C8F' 77                  LD      (HL),A          ; Null out leading space
  1486   0C90' 23                  INC     HL              ; Adjust pointer to options
  1487   0C91' 23                  INC     HL
  1488   0C92' C9                  RET                     ; Return with Z flag

  1490   0C93' 54          NOSLSH: LD      D,H             ; Copy into de
  1491   0C94' 5D                  LD      E,L
  1492   0C95' AF                  XOR     A               ; Search for terminating null
  1493   0C96' 01 000B             LD      BC,OPTLEN       ; Range for search
  1494   0C99' EDB1                CPIR                    ; Do short search
  1495   0C9B' 28 02'              JR      Z,DOOPTQ        ; Found null, proceed
  1496   0C9D' EB                  EX      DE,HL           ; Otherwise too long for options
  1497   0C9E' C9                  RET                     ; Return with NZ

  1499   0C9F' D5          DOOPTQ: PUSH    DE
  1500   0CA0' 1B                  DEC     DE
  1501   0CA1' 13          BLOOP:  INC     DE
  1502   0CA2' 1A                  LD      A,(DE)
  1503   0CA3' B7                  OR      A
  1504   0CA4' 28 0C'              JR      Z,OQDONE        ; End of string, return with Z
  1505   0CA6' 06 0B               LD      B,OPTLEN
  1506   0CA8' 21 0CD2'            LD      HL,OPTLTR
  1507   0CAB' BE          LLOOP:  CP      (HL)
  1508   0CAC' 28 F3'              JR      Z,BLOOP
  1509   0CAE' 23                  INC     HL
  1510   0CAF' 10 FA'              DJNZ    LLOOP           ; If B ticks down, a failure!
  1511   0CB1' 05                  DEC     B               ; Cheap NZ return

ZMAC Relocating Macro Assembler v 1.7,                       page   28
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1513   0CB2' E1          OQDONE: POP     HL
  1514   0CB3' C9                  RET

  1516                     ;.....
  1517                     ; Consolidated vectors to Get and Put stamps with Error Detection

  1519   0CB4' CD 0000#    PUTSTMP: CALL   PSTAMP          ; Attempt Put Stamp to Disk
  1520   0CB7' 18 03'              JR      GETST0          ; ..and vector down to Error stuff

  1522   0CB9' CD 0000#    GETSTMP: CALL   GSTAMP          ; Try to Get File Stamp
  1523   0CBC' C0          GETST0: RET     NZ              ; ..return if Good
  1524   0CBD' 32 003A"            LD      (DSFLAG),A      ; Else disable stamping w/0 in A
  1525   0CC0' C9                  RET                     ; ..and return

  1527                     ;.....
  1528                     ; Get base of Lowest Operating System component (CCP or RSX) which
  1529                     ; is the Top of memory usable for a copy buffer.

  1531   0CC1' E5          GETTOP: PUSH    HL              ; Save HL around this call
  1532   0CC2' 2A 000A'            LD      HL,(Z3EADR)     ; Get Z3 environment (if any)
  1533   0CC5' 7D                  LD      A,L
  1534   0CC6' B4                  OR      H
  1535   0CC7' F5                  PUSH    AF              ; Save flag state
  1536   0CC8' C4 0000#            CALL    NZ,GZMTOP       ; .check extended ENV if in Z-System
  1537   0CCB' F1                  POP     AF
  1538   0CCC' CC 0000#            CALL    Z,GETMTOP       ; ..else calculate base/rsx
  1539   0CCF' 7C                  LD      A,H             ; Get returned Page for exit
  1540   0CD0' E1                  POP     HL              ; .restore regs
  1541   0CD1' C9                  RET                     ; ..and back

  1543                     ;.....
  1544                     ; Text and character variables

  1546   0CD2' 41 45 49 4D OPTLTR: DEFB    'AEIMNOQRSVX'   ; Added 'R' and 'X'
  1547   0CDD'             OPTLST: DEFS    0
  1548         = 000B      OPTLEN  EQU     OPTLST-OPTLTR

  1550                     ; Various message suffixes

  1552   0CDD' 65 20 00    SUFFX1: DEFB    'e ',0
  1553   0CE0' 69 6E 67 20 SUFFX2: DEFB    'ing ',0

  1555                     ;====================================================================
  1556                     ; Extracted from DDIRQ routine in DSLIB, which is based on SDIRQ.Z80
  1557                     ;  Ver 1.5 (Syslib) by Richard Conn.            Harold F. Bower
  1558                     ;====================================================================
  1559                     ; Entry: HL - Points to Memory Buffer
  1560                     ;        DE - Points to FCB for selection (36 bytes)
  1561                     ; Exit :  A <> 0, Zero Flag Clear (NZ) if Ok
  1562                     ;             A = 0 and Zero flag Set (Z) if TPA Overflow
  1563                     ;        HL - Points to first file in Buffer
  1564                     ;        BC - Contains number of files in Buffer
  1565                     ; Special Requirements: DMA address set to default of 80H.
  1566                     ;====================================================================

  1568   0CE5' D5          DDIRQ:  PUSH    DE              ; Save ptr to FCB
ZMAC Relocating Macro Assembler v 1.7,                       page   29
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1569   0CE6' 22 0005"            LD      (TFCB),HL       ; Set ptr to temp FCB
  1570   0CE9' 3A 001F'            LD      A,(TYPDAT)      ; Get DS Flag
  1571   0CEC' B7                  OR      A               ; Going for DateStamper Stamps?
  1572   0CED' 28 14'              JR      Z,DDIRV0        ; ..jump if P2Dos type
  1573   0CEF' E5                  PUSH    HL              ; Save regs while we test for DS Routines
  1574   0CF0' D5                  PUSH    DE
  1575   0CF1' F5                  PUSH    AF              ; ..including flag byte in A
  1576   0CF2' CD 0000#            CALL    FINDCK          ; Is DateStaper alive and well?
  1577   0CF5' 28 08'              JR      Z,NODS          ; ..jump to P2D if not
  1578   0CF7' CD 0000#            CALL    CKTDF           ; Do we have a valid !!!TIME&.DAT file?
  1579   0CFA' 28 03'              JR      Z,NODS          ; ..jump to MS/P2D if not
  1580   0CFC' F1                  POP     AF              ; Else we have everything ready for DS, Do it
  1581   0CFD' 18 02'              JR      DSOK            ; ..bypass defaulting to P2D and continue

  1583   0CFF' F1          NODS:   POP     AF              ; Restore flag byte
  1584   0D00' AF                  XOR     A               ; ..Clear since No DS
  1585   0D01' D1          DSOK:   POP     DE              ; Restore rest of regs
  1586   0D02' E1                  POP     HL
  1587   0D03' 32 0004"    DDIRV0: LD      (S2FLG),A       ; ..and save
  1588   0D06' 01 0024             LD      BC,36           ; Offset to after FCB
  1589   0D09' 09                  ADD     HL,BC           ; ..useable memory now starts at (HL)
  1590   0D0A' CD 0000#            CALL    DPARAMS         ; Set parameters to logged disk

  1592                     ; Set values in the Sort Selection Block

  1594   0D0D' EB                  EX      DE,HL           ; Save in DE while we set up SSB
  1595   0D0E' 2A 0000#            LD      HL,(DIRMAX)     ; Get Max Number of DIR entries
  1596   0D11' 22 0009"            LD      (FCOUNT),HL     ; ..save in SSB
  1597   0D14' 21 001F             LD      HL,ESIZE        ; Get size of records
  1598   0D17' 22 000B"            LD      (ELSIZ),HL      ; ..save in SSB
  1599   0D1A' 21 0000             LD      HL,0            ; Let SSBINIT set buffer addr
  1600   0D1D' 22 0007"            LD      (DSTART),HL
  1601   0D20' 2D                  DEC     L               ; (0-->FF) Use pointers for sorting, Re-Order
  1602   0D21' 22 0011"            LD      (PTRFLG),HL     ; ..place in POINTR (L) and NOREC (H) in SSB
  1603   0D24' 21 0EC0'            LD      HL,DICOMP       ; Address User Compare routine
  1604   0D27' 22 000D"            LD      (COMPIT),HL     ; ..place addr in SSB
  1605   0D2A' EB                  EX      DE,HL           ; Put Memory base back in HL
  1606   0D2B' 11 0007"            LD      DE,SSB          ; .point to SSB
  1607   0D2E' CD 0000#            CALL    SSBINIT         ; ..and Initialize the sort routine
  1608   0D31' 22 0000#            LD      (DIRBUF),HL     ; Save returned Record Buffer Address
  1609   0D34' D1                  POP     DE              ; Get ptr to FCB
  1610   0D35' C4 0D49'            CALL    NZ,DIRLOAD      ; Load directory w/o sizing info (if space)
  1611   0D38' C8                  RET     Z               ; Abort if TPA overflow
  1612   0D39' 11 0007"            LD      DE,SSB          ; Set parm for Sort routine
  1613   0D3C' CD 0000#            CALL    SORT            ; ..and do it!
  1614   0D3F' 2A 0007"            LD      HL,(DSTART)     ; .and load exit parms
  1615   0D42' ED4B 0009"          LD      BC,(FCOUNT)
  1616   0D46' F6 FF               OR      0FFH            ; Set Ok status and return
  1617   0D48' C9                  RET


  1620                     ; Build Directory Table at DIRBUF
  1621                     ;   This is the optimal Directory Load Routine; It only loads unique file names
  1622                     ; from disk, but the information is not sufficient to compute the file sizes
  1623                     ;
  1624                     ; On Input : HL pts to Directory Buffer (ESIZE x N Max)
ZMAC Relocating Macro Assembler v 1.7,                       page   30
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1625                     ;            DE pts to FCB (Only 12 bytes needed)
  1626                     ; On Output: BC is Number of Files
  1627                     ;            A = 0 and Zero Flag set if TPA Overflow

  1629   0D49' 22 0007"    DIRLOAD: LD     (DSTART),HL     ; Set start of Buffer area
  1630   0D4C' 13                  INC     DE              ; Pt to file name
  1631   0D4D' 2A 0005"            LD      HL,(TFCB)       ; Pt to TFCB
  1632   0D50' AF                  XOR     A               ; Else set for current user
  1633   0D51' 77                  LD      (HL),A          ; Stash User Selects
  1634   0D52' 23                  INC     HL              ; Pt to File Name in TFCB
  1635   0D53' 01 000B             LD      BC,11           ; 11 Chars
  1636   0D56' EB                  EX      DE,HL
  1637   0D57' EDB0                LDIR                    ; Copy the Name and Type
  1638   0D59' EB                  EX      DE,HL
  1639                             
  1640   0D5A' 06 18               LD      B,24            ; 24 chars (Incl Zero EX)
  1641   0D5C' AF                  XOR     A               ; Zero rest of TFCB

  1643   0D5D' 77          DLLOOP1: LD     (HL),A          ; Store Zero
  1644   0D5E' 23                  INC     HL              ; Pt to next
  1645   0D5F' 10 FC'              DJNZ    DLLOOP1         ; Count down

  1647   0D61' 6F                  LD      L,A             ; Initialize counters (A has null)
  1648   0D62' 67                  LD      H,A
  1649   0D63' 22 0009"            LD      (FCOUNT),HL     ; Total Files on Disk = 0

  1651                     ; Begin by setting default DMA address to 80H

  1653   0D66' 11 0080             LD      DE,BUFF         ; Set DMA address to default
  1654   0D69' 0E 1A               LD      C,SDMA
  1655   0D6B' CD 0005             CALL    BDOSE

  1657                     ; Now we begin scanning for files to place into the memory buffer

  1659   0D6E' 0E 11               LD      C,SRCHF         ; Search for file
  1660   0D70' 18 07'              JR      DIRLP1

  1662   0D72' CD 0DE5'    DIRLP:  CALL    PENTRY          ; Place entry in Dir
  1663   0D75' 28 69'              JR      Z,DIRDNX        ; Memory Overflow Error
  1664   0D77' 0E 12               LD      C,SRCHN         ; Search for Next match
  1665   0D79' ED5B 0005"  DIRLP1: LD      DE,(TFCB)       ; Pt to FCB
  1666   0D7D' CD 0000#            CALL    FSTNXT
  1667   0D80' FE FF               CP      255             ; Done?
  1668   0D82' 20 EE'              JR      NZ,DIRLP

  1670   0D84' 3A 0004"            LD      A,(S2FLG)       ; Loading P2D/NZTIME Stamps?
  1671   0D87' B7                  OR      A
  1672   0D88' 28 54'              JR      Z,DIRPDN        ; ..jump to exit if so

  1674                     ; We are using DateStamper stamps, so append stamps to FN.FT string

  1676   0D8A' AF                  XOR     A               ; Open T&D for Read-only
  1677   0D8B' CD 0000#            CALL    OPENTD          ; ..don't check errs cause CKTD was Ok
  1678   0D8E' ED4B 0009"          LD      BC,(FCOUNT)     ; Load this many records
  1679   0D92' 2A 0007"            LD      HL,(DSTART)     ; ..starting with this entry
  1680   0D95' 11 FFFF             LD      DE,0FFFFH       ; Set dummy Random record # to force read
ZMAC Relocating Macro Assembler v 1.7,                       page   31
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


  1682   0D98' 78          TDLOOP: LD      A,B             ; Are we done?
  1683   0D99' B1                  OR      C
  1684   0D9A' 28 3F'              JR      Z,DIRDDN        ; ..exit if so
  1685   0D9C' C5                  PUSH    BC              ; Save count
  1686   0D9D' 01 0010             LD      BC,FNSIZE       ; Offset to RR #
  1687   0DA0' 09                  ADD     HL,BC
  1688   0DA1' 7E                  LD      A,(HL)          ; Get Index #
  1689   0DA2' E5                  PUSH    HL              ; Save index to entry TD Field
  1690   0DA3' F5                  PUSH    AF              ; ..and index
  1691   0DA4' 23                  INC     HL
  1692   0DA5' 7E                  LD      A,(HL)          ; Get RR # to HL
  1693   0DA6' 23                  INC     HL
  1694   0DA7' 66                  LD      H,(HL)
  1695   0DA8' 6F                  LD      L,A
  1696   0DA9' B7                  OR      A               ; Compare current (DE) w/desired (HL)
  1697   0DAA' ED52                SBC     HL,DE
  1698   0DAC' 19                  ADD     HL,DE
  1699   0DAD' 28 12'              JR      Z,SAMREC        ; ..jump if we already have the record
  1700   0DAF' EB                  EX      DE,HL           ; Else put rec in DE
  1701   0DB0' D5                  PUSH    DE              ; ..and save
  1702   0DB1' AF                  XOR     A
  1703   0DB2' CD 0000#            CALL    RWTD            ; Read the T&D file ignoring errors
  1704   0DB5' 22 0013"            LD      (TDBUF),HL      ; Save TD buffer start addr
  1705   0DB8' 20 06'              JR      NZ,TDRDOK       ; ..jump if T&D File Read Ok
  1706   0DBA' 06 80               LD      B,128           ; Else Null record (A already = 0)
  1707   0DBC' 77          TDNULL: LD      (HL),A
  1708   0DBD' 23                  INC     HL
  1709   0DBE' 10 FC'              DJNZ    TDNULL          ; Loop til sector filled
  1710   0DC0' D1          TDRDOK: POP     DE              ; ..and restore RR #
  1711   0DC1' F1          SAMREC: POP     AF              ; Restore record Index
  1712   0DC2' 87                  ADD     A,A             ; ..and mult by 16 to get relative addr
  1713   0DC3' 87                  ADD     A,A
  1714   0DC4' 87                  ADD     A,A
  1715   0DC5' 87                  ADD     A,A
  1716   0DC6' 4F                  LD      C,A
  1717   0DC7' 06 00               LD      B,0
  1718   0DC9' 2A 0013"            LD      HL,(TDBUF)
  1719   0DCC' 09                  ADD     HL,BC           ; HL Now points at source T&D string in Buffer
  1720   0DCD' EB                  EX      DE,HL           ; Swap regs..
  1721   0DCE' E3                  EX      (SP),HL         ; ..to put RR # on stack, DEst adr in HL
  1722   0DCF' EB                  EX      DE,HL           ; ...then Dest in DE, source in HL
  1723   0DD0' 01 000F             LD      BC,15           ; Move all three stamps
  1724   0DD3' EDB0                LDIR
  1725   0DD5' EB                  EX      DE,HL           ; HL --> Next Dir entry
  1726   0DD6' D1                  POP     DE              ; DE = RR # in Buff
  1727   0DD7' C1                  POP     BC              ; BC = Count
  1728   0DD8' 0B                  DEC     BC
  1729   0DD9' 18 BD'              JR      TDLOOP          ; ..and loop til done

  1731                     ; Now we are done with the Load -- Set up Return Values

  1733   0DDB' CD 0000#    DIRDDN: CALL    CLOSTD          ; Close the T&D tile for safety
  1734   0DDE' F6 FF       DIRPDN: OR      0FFH            ; Set Flags NZ for Load Ok
  1735   0DE0' ED4B 0009"  DIRDNX: LD      BC,(FCOUNT)     ; Get total number of files in BC
  1736   0DE4' C9                  RET
ZMAC Relocating Macro Assembler v 1.7,                       page   32
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00



  1739                     ; PENTRY -- Place entry in Directory Buffer if not an erased entry

  1741                     ; On Input:  A = 0-3 for Adr index in Buff of Entry FCB
  1742                     ;            FCOUNT = Number of files in Dir so far
  1743                     ; On Output: FCOUNT = Number of files in dir so far
  1744                     ;            A = 0 and Zero Flag Set if Memory Overflow Error

  1746   0DE5' 32 0003"    PENTRY: LD      (INDX),A        ; Save index in case of P2Dos Stamp load
  1747   0DE8' D5                  PUSH    DE              ; Save any DS Indices
  1748   0DE9' C5                  PUSH    BC
  1749   0DEA' 0F                  RRCA                    ; Multiply by 32 for Offset computation
  1750   0DEB' 0F                  RRCA
  1751   0DEC' 0F                  RRCA
  1752                     ;;      AND     60H             ; A = Byte Offset
  1753   0DED' 11 0080             LD      DE,BUFF         ; Pt to Buffer Entry
  1754   0DF0' 6F                  LD      L,A             ; Let HL = Offset
  1755   0DF1' 26 00               LD      H,0
  1756   0DF3' 19                  ADD     HL,DE           ; HL = Ptr to FCB

  1758   0DF4' 7E                  LD      A,(HL)
  1759   0DF5' FE 20               CP      20H             ; Is it CP/M Plus Volume or T&D?
  1760   0DF7' D2 0E82'            JP      NC,PEDONE       ; ..jump if so

  1762                     ; HL = Adr of FCB in BUFF.  Check for attributes of file

  1764   0DFA' E5                  PUSH    HL              ; Save ptr
  1765   0DFB' 01 000A             LD      BC,10           ; Pt to System Attribute
  1766   0DFE' 09                  ADD     HL,BC
  1767   0DFF' CB7E                BIT     7,(HL)          ; Check for System Attribute
  1768   0E01' E1                  POP     HL              ; Restore ptr
  1769   0E02' 28 06'              JR      Z,ATDIR         ; ..jump if Not System File (Selflg in A)
  1770   0E04' 3A 001D"            LD      A,(SYSEXC)
  1771   0E07' B7                  OR      A               ; Are we including SYStem Files?
  1772   0E08' 20 78'              JR      NZ,PEDONE       ; ..jump if Not
  1773                                             ;..Else fall thru to continue

  1775                     ; Increment total number of files

  1777   0E0A' ED5B 0009"  ATDIR:  LD      DE,(FCOUNT)     ; Total Files = Total Files + 1
  1778   0E0E' 13                  INC     DE
  1779   0E0F' ED53 0009"          LD      (FCOUNT),DE

  1781                     ; Copy FCB pted to by HL into Directory Buffer

  1783   0E13' ED5B 0000#          LD      DE,(DIRBUF)     ; Pt to Next Entry location
  1784   0E17' 01 0010             LD      BC,FNSIZE       ; Number of Bytes/Entry
  1785   0E1A' EDB0                LDIR                    ; Copy FCB into Memory Buffer
  1786   0E1C' C1                  POP     BC              ; Restore any DS indices
  1787   0E1D' E1                  POP     HL
  1788   0E1E' 3A 0004"            LD      A,(S2FLG)       ; Which method do we use?
  1789   0E21' B7                  OR      A
  1790   0E22' 28 0C'              JR      Z,USEMS         ; ..jump if using MS/P2Dos/NZTime stamps
  1791   0E24' EB                  EX      DE,HL           ; Put destination in HL
  1792   0E25' 70                  LD      (HL),B          ; Stash index into T&D sector
ZMAC Relocating Macro Assembler v 1.7,                       page   33
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1793   0E26' 23                  INC     HL
  1794   0E27' 73                  LD      (HL),E          ; ..and T&D Sector number
  1795   0E28' 23                  INC     HL
  1796   0E29' 72                  LD      (HL),D
  1797   0E2A' 23                  INC     HL
  1798   0E2B' EB                  EX      DE,HL           ; Put Buffer pointer back in DE
  1799   0E2C' 06 0C               LD      B,ESIZE-FNSIZE-3
  1800   0E2E' 18 43'              JR      FILLIT          ; Null out remaining

  1802   0E30' 21 0090     USEMS:  LD      HL,BUFF+16      ; Point to DosDisk Flag bytes
  1803   0E33' 7E                  LD      A,(HL)          ; Get first byte
  1804   0E34' FE FD               CP      0FDH            ; Is it the MS-DOS 40-byte flag?
  1805   0E36' 20 11'              JR      NZ,USEP2D       ; ..jump if not
  1806   0E38' 23                  INC     HL              ; Else check second byte to be sure
  1807   0E39' 96                  SUB     (HL)
  1808   0E3A' 20 0D'              JR      NZ,USEP2D       ; ..jump if no match
  1809   0E3C' 06 0A               LD      B,10            ; Ok, so null Create and Access fields
  1810   0E3E' CD 0EE9'            CALL    NULLIT
  1811   0E41' 21 0096             LD      HL,BUFF+22      ; Point to source MS-DOS DateSpec
  1812   0E44' CD 0000#            CALL    M2UTIM          ; ..and do the conversions to DE
  1813   0E47' 18 2D'              JR      P2DONE          ; Continue with common code

  1815   0E49' 21 00E0     USEP2D: LD      HL,BUFF+60H     ; Point to P2D Time indicator
  1816   0E4C' 7E                  LD      A,(HL)
  1817   0E4D' E6 7F               AND     7FH             ; Mask difference between Z2D and NZTime
  1818   0E4F' FE 21               CP      21H             ; Is there a valid time stamp flag?
  1819   0E51' 20 1E'              JR      NZ,NOTP2D       ; ..jump if not
  1820   0E53' 3A 0003"            LD      A,(INDX)        ; Else calculate offset to correct entry
  1821   0E56' 4F                  LD      C,A
  1822   0E57' 87                  ADD     A,A             ; *2
  1823   0E58' 87                  ADD     A,A             ; *4
  1824   0E59' 81                  ADD     A,C             ; *5
  1825   0E5A' 87                  ADD     A,A             ; *10
  1826   0E5B' 3C                  INC     A               ; +1
  1827   0E5C' 4F                  LD      C,A             ; Entries start at offset=1,11,21 decimal
  1828   0E5D' 06 00               LD      B,0
  1829   0E5F' 7E                  LD      A,(HL)          ; Get Flag Byte (A1=NZTime, 21=P2Dos)
  1830   0E60' 09                  ADD     HL,BC           ; Point to Stamp field for desired entry
  1831   0E61' 17                  RLA                     ; Is it NzTime?
  1832   0E62' 38 23'              JR      C,USENZT        ; ..jump if NZTime Stamping
  1833   0E64' CD 0000#            CALL    P2UTIM          ; ..and parse Create Stamp to Table
  1834   0E67' 06 05               LD      B,5             ; Null the Last Accessed field
  1835   0E69' CD 0EE9'            CALL    NULLIT
  1836   0E6C' CD 0000#            CALL    P2UTIM          ; Parse Modify Stamp
  1837   0E6F' 18 05'              JR      P2DONE          ; ..and continue

  1839   0E71' 06 0F       NOTP2D: LD      B,ESIZE-FNSIZE  ; Set count to fill entire field
  1840   0E73' CD 0EE9'    FILLIT: CALL    NULLIT          ; Fill rest of time with Nulls
  1841   0E76' ED53 0000#  P2DONE: LD      (DIRBUF),DE     ; Set ptr to Next Entry
  1842   0E7A' CD 0000#            CALL    GETMTOP         ; Return highest avail addr in HL
  1843   0E7D' 7C                  LD      A,H             ; Get CCP page in A
  1844   0E7E' 3D                  DEC     A               ; ..and back one page in front of it
  1845   0E7F' BA                  CP      D               ; Is ptr to next entry beyond this?
  1846   0E80' C8                  RET     Z

  1848   0E81' 11                  DEFB    11H             ; Fall thru trashing DE
ZMAC Relocating Macro Assembler v 1.7,                       page   34
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


  1850                     ; Done with PENTRY and No Error

  1852   0E82' C1          PEDONE: POP     BC              ; Clear the stack
  1853   0E83' D1                  POP     DE
  1854   0E84' F6 FF               OR      0FFH            ; Set NZ for No Error
  1855   0E86' C9                  RET

  1857                     ; Gather File Stamps from NZTime-stamped directory

  1859   0E87' 22 0000"    USENZT: LD      (IPTR),HL       ; Save Pointer to input NZTime stamps
  1860   0E8A' 6E                  LD      L,(HL)
  1861   0E8B' 3A 0003"            LD      A,(INDX)        ; Get Index number (0,1,2)
  1862   0E8E' 47                  LD      B,A             ; .save
  1863   0E8F' 3E 08               LD      A,8
  1864   0E91' 90                  SUB     B               ; Compute current byte when starting
  1865   0E92' 4F                  LD      C,A             ;  save
  1866   0E93' 04                  INC     B
  1867   0E94' 05                  DEC     B               ; Is Input byte already aligned?
  1868   0E95' 28 03'              JR      Z,USENZ1        ; ..jump if so
  1869   0E97' 29          USENZ0: ADD     HL,HL           ; Else rotate input byte (H is don't care)
  1870   0E98' 10 FD'              DJNZ    USENZ0          ; ..looping til done
  1871   0E9A' 3E 03       USENZ1: LD      A,3             ; Get all three stamps
  1872   0E9C' 32 0002"    USENZ2: LD      (LPCTR),A       ; Set Outer Loop Counter
  1873   0E9F' 06 07               LD      B,7
  1874   0EA1' CD 0EEF'            CALL    GBITS           ; Get Year (7 bits)
  1875   0EA4' 06 04               LD      B,4
  1876   0EA6' CD 0EEF'            CALL    GBITS           ; Month (4 bits)
  1877   0EA9' 06 05               LD      B,5
  1878   0EAB' CD 0EEF'            CALL    GBITS           ; Day (5 bits)
  1879   0EAE' 06 05               LD      B,5
  1880   0EB0' CD 0EEF'            CALL    GBITS           ; Hour (5 bits)
  1881   0EB3' 06 06               LD      B,6
  1882   0EB5' CD 0EEF'            CALL    GBITS           ; Minute (6 bits)
  1883   0EB8' 3A 0002"            LD      A,(LPCTR)
  1884   0EBB' 3D                  DEC     A               ; Have we done all 3 fields?
  1885   0EBC' 20 DE'              JR      NZ,USENZ2       ; .loop if Not (saving new count)
  1886   0EBE' 18 B6'              JR      P2DONE          ; ..jump to exit when finished

  1888                     ;========================================================================
  1889                     ; NAME - DICOMP.  Compare the directory entry pointed to by HL with that
  1890                     ;               addressed by DE.
  1891                     ; Entry: HL - Points to one FCB extracted entry
  1892                     ;        DE - Points to second FCB extracted entry
  1893                     ; Exit :  F - Carry Set (C) means (DE) < (HL)
  1894                     ;               Zero Set (Z) means (DE) = (HL)
  1895                     ;               Non-Zero (NZ) and No Carry (NC) mans (DE) > (HL)
  1896                     ;========================================================================

  1898   0EC0' C5          DICOMP: PUSH    BC              ; Save count
  1899   0EC1' 06 0B               LD      B,11            ; 11 bytes for FN and FT
  1900   0EC3' E5                  PUSH    HL
  1901   0EC4' D5                  PUSH    DE
  1902   0EC5' 23                  INC     HL              ; Pt to FN
  1903   0EC6' 13                  INC     DE
  1904   0EC7' CD 0000#            CALL    @FNCMP          ; Do comparison
ZMAC Relocating Macro Assembler v 1.7,                       page   35
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1905   0ECA' D1                  POP     DE
  1906   0ECB' E1                  POP     HL
  1907   0ECC' 20 19'              JR      NZ,CMPEX
  1908   0ECE' 1A                  LD      A,(DE)          ; Compare User Number
  1909   0ECF' BE                  CP      (HL)
  1910   0ED0' 20 15'              JR      NZ,CMPEX        ; ..exit if No match
  1911   0ED2' E5                  PUSH    HL              ; Else save ptrs
  1912   0ED3' D5                  PUSH    DE
  1913   0ED4' 01 000E             LD      BC,14
  1914   0ED7' EB                  EX      DE,HL           ; Swap
  1915   0ED8' 09                  ADD     HL,BC           ; .offset File 1 to DM
  1916   0ED9' EB                  EX      DE,HL           ; ..swap
  1917   0EDA' 09                  ADD     HL,BC           ; ...offset File 2 to DM
  1918   0EDB' 1A                  LD      A,(DE)
  1919   0EDC' BE                  CP      (HL)            ; Compare Data Modules
  1920   0EDD' 20 06'              JR      NZ,CMPEX0       ; ..jump if Not Same
  1921   0EDF' 2B                  DEC     HL              ; Else back down to EXT
  1922   0EE0' 2B                  DEC     HL
  1923   0EE1' 1B                  DEC     DE
  1924   0EE2' 1B                  DEC     DE
  1925   0EE3' 1A                  LD      A,(DE)          ; Fetch EX file 1
  1926   0EE4' BE                  CP      (HL)            ; ..compare to EX file 2 and return status
  1927   0EE5' D1          CMPEX0: POP     DE              ; Restore regs
  1928   0EE6' E1                  POP     HL
  1929   0EE7' C1          CMPEX:  POP     BC              ; Restore Count
  1930   0EE8' C9                  RET                     ; ..and exit

  1932                     ;.....
  1933                     ; Fill the string addressed by DE with a zero for B bytes

  1935   0EE9' AF          NULLIT: XOR     A               ; Load a cheap Null
  1936   0EEA' 12          NULL0:  LD      (DE),A          ; Stuff a byte
  1937   0EEB' 13                  INC     DE              ; ..and advance
  1938   0EEC' 10 FC'              DJNZ    NULL0           ; Loop til done
  1939   0EEE' C9                  RET

  1941                     ;.....
  1942                     ; NZTime Support Routine.  Gather # of bits speced from NZTIM, Return BCD Digit
  1943                     ; ENTER: L = Current working byte
  1944                     ;       DE = Ptr to Dest of Univ stamps
  1945                     ;        C = Bit # currently in position (8..1)
  1946                     ;        B = Number of bits to gather
  1947                     ; EXIT : A = BCD Conversion of # bits from entry

  1949   0EEF' 26 00       GBITS:  LD      H,0             ; Clear Bit Accumulator
  1950   0EF1' 29          GBITS0: ADD     HL,HL           ; Shift B7 of L into B0 of H, H shifts left
  1951   0EF2' 0D                  DEC     C               ; Have we shifted last of input Byte?
  1952   0EF3' 20 0D'              JR      NZ,GBITS1       ; ..jump if Not

  1954   0EF5' E5                  PUSH    HL              ; Else need a byte, save regs
  1955   0EF6' 2A 0000"            LD      HL,(IPTR)       ; Get input ptr
  1956   0EF9' 23                  INC     HL              ; .go to next byte
  1957   0EFA' 7E                  LD      A,(HL)          ; ..fetch
  1958   0EFB' 22 0000"            LD      (IPTR),HL       ; ...save updated ptr
  1959   0EFE' E1                  POP     HL              ; .(restore regs)
  1960   0EFF' 6F                  LD      L,A             ; Place new Input byte for shifting
ZMAC Relocating Macro Assembler v 1.7,                       page   36
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  1961   0F00' 0E 08               LD      C,8             ;  and init Bits Remaining counter

  1963   0F02' 10 ED'      GBITS1: DJNZ    GBITS0          ; ..Shift another if not done
  1964   0F04' 7C                  LD      A,H             ; Else get completed output byte
  1965   0F05' CD 0000#            CALL    BIN2BCD         ; .make BCD for Universal
  1966   0F08' 12                  LD      (DE),A          ; ..store in Output
  1967   0F09' 13                  INC     DE              ; ...and advance to next digit
  1968   0F0A' C9                  RET

  1970                     ;====================================================================
  1971                     ; Adapted from SDIR09.Z80 Ver 1.5 by Richard Conn to handle larger
  1972                     ; records needed by DSLib "type" routines.                      HFB
  1973                     ;====================================================================
  1974                     ; Entry: HL - Points to a Directory Buffer
  1975                     ;        BC - Contains the total number of files in Buffer
  1976                     ; Exit : BC - Number of Selected files.  Buffer is restructured
  1977                     ; Uses : BC
  1978                     ; Special Requirements: Required side effect is that the Flag
  1979                     ;       Extent (Set by DIR:) be correct.  In most cases, default
  1980                     ;       of 0 is Ok, except when extent size is greater than 16K
  1981                     ;====================================================================

  1983   0F0B' E5          DIRPAK: PUSH    HL              ; Save Regs
  1984   0F0C' D5                  PUSH    DE
  1985   0F0D' F5                  PUSH    AF
  1986   0F0E' C5                  PUSH    BC              ; Save counter
  1987   0F0F' 01 0000             LD      BC,0
  1988   0F12' ED43 0009"          LD      (FCOUNT),BC     ; Init file count
  1989   0F16' 5D                  LD      E,L             ; Copy Buffer start to DE
  1990   0F17' 54                  LD      D,H

  1992   0F18' C1          DPLOOP: POP     BC              ; Get counter
  1993   0F19' 78                  LD      A,B             ; Check for Done
  1994   0F1A' B1                  OR      C
  1995   0F1B' 28 1B'              JR      Z,DPDONE
  1996   0F1D' 0B                  DEC     BC              ; Count down
  1997   0F1E' C5                  PUSH    BC              ; Save counter
  1998   0F1F' 01 001F             LD      BC,ESIZE        ; Set number of bytes in entry
  1999   0F22' CB7E                BIT     7,(HL)          ; Does 1st byte indicate file is selected?
  2000   0F24' 28 0F'              JR      Z,DPNEXT        ; ..jump and advance to next if not

  2002                     ; Found Selected Entry

  2004   0F26' CBBE                RES     7,(HL)          ; Clear MSB of selected entry
  2005   0F28' EDB0                LDIR                    ; Copy the entry to current bottom of byffer
  2006   0F2A' ED4B 0009"          LD      BC,(FCOUNT)     ; Increment File Count
  2007   0F2E' 03                  INC     BC
  2008   0F2F' ED43 0009"          LD      (FCOUNT),BC
  2009   0F33' 18 E3'              JR      DPLOOP          ; Continue

  2011                     ; Skip to Next Entry

  2013   0F35' 09          DPNEXT: ADD     HL,BC           ; Skip over entry
  2014   0F36' 18 E0'              JR      DPLOOP          ; Continue

  2016                     ; Compression Complete -- Set up returned values
ZMAC Relocating Macro Assembler v 1.7,                       page   37
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00


  2018   0F38' ED4B 0009"  DPDONE: LD      BC,(FCOUNT)     ; Put File Count in BC
  2019   0F3C' F1                  POP     AF              ; Restore regs
  2020   0F3D' D1                  POP     DE
  2021   0F3E' E1                  POP     HL
  2022   0F3F' C9                  RET

  2024                     ;++++++++++++++++++++++++++++++++++++++++++++++++++++++
  2025                     ;                  D a t a    A r e a
  2026                     ;++++++++++++++++++++++++++++++++++++++++++++++++++++++

  2028                             DSEG

  2030                     ;---- Data Storage/Buffers for DDIRQ Routine ----

  2032   0000" 00 00       IPTR:   DEFS    2               ; Pointer for NZTime conversion
  2033   0002" 00          LPCTR:  DEFS    1               ; Loop Counter for NZTime conversion

  2035   0003" 00          INDX:   DEFS    1               ; Directory index into sector
  2036   0004" 00          S2FLG:  DEFS    1               ; Secondary Select Flag (Sort & Stamp method)
  2037   0005" 00 00       TFCB:   DEFS    2               ; Address of Temporary FCB

  2039   0007"             SSB:                            ;\ Sort Selection Block:
  2040   0007" 00 00       DSTART: DEFS    2               ;| Pointer to first Directory Entry
  2041   0009" 00 00       FCOUNT: DEFS    2               ;| Tot Number of Files/Number of Selected Files
  2042   000B" 00 00       ELSIZ:  DEFS    2               ;| Size of each element
  2043   000D" 00 00       COMPIT: DEFS    2               ;| Addr of compare routine
  2044   000F" 00 00       ORDBUF: DEFS    2               ;| Addr of Order buffer
  2045   0011" 00          PTRFLG: DEFS    1               ;| FF=Use ptrs, 0=No ptrs
  2046   0012" 00                  DEFS    1               ;/ If Ptrflg<>0, FF=No reorder, 0=Reorder

  2048   0013" 00 00       TDBUF:  DEFS    2               ; Temp storage loc'n for T&D Sector Buffer adr

  2050                     ;---- End of Data area used by DDIRQ routine ----
  2051                     ; Pointers

  2053         = 0015"     DATABG  EQU     $
  2054   0015" 00 00       MFPTR:  DEFS    2               ; Ptr to first char of next fn spec
  2055   0017" 00 00       NXTPTR: DEFS    2               ; Ptr to next fn spec in line
  2056   0019" 00 00       WORKBF: DEFS    2               ; Ptr to beginning of work buffer

  2058                     ;   ----- Do Not Change following values -----
  2059   001B"             CPYTBL:                         ; ..flags copied from default table
  2060   001B" 00          VERFLG: DEFS    1               ; Verify
  2061   001C" 00          INSP:   DEFS    1               ; Inspect
  2062   001D" 00          SYSEXC: DEFS    1               ; Exclude system files
  2063   001E" 00          NCOPY:  DEFS    1               ; Multiple copy
  2064   001F" 00          EXIST:  DEFS    1               ; Test for existence flag
  2065   0020" 00          EXRO:   DEFS    1               ; Test for R/O existence flag
  2066   0021" 00          ARCHIV: DEFS    1               ; Archive flag
  2067   0022" 00          REPLAC: DEFS    1               ; Replace flag (Copy if exists)
  2068         = 0008      TBLLEN  EQU     $-CPYTBL
  2069                     ;       ----- End of no change area -----

  2071                     ; Disks and Users

ZMAC Relocating Macro Assembler v 1.7,                       page   38
ZSDOS File Copy Program                                     COPY172 .Z80
                                                            04/09/93 00:00

  2073   0023" 00          CDISK:  DEFS    1               ; Current disk
  2074   0024" 00          SUSER:  DEFS    1               ; Source user
  2075   0025" 00          SDRIVE: DEFS    1               ; ..Source disk
  2076   0026" 00          DUSER:  DEFS    1               ; Destination user
  2077   0027" 00                  DEFS    1               ; ..Destination disk

  2079                     ; CRC Value

  2081   0028" 00 00       CRCVAL: DEFS    2               ; CRC check value

  2083                     ; FCBS & FCBD

  2085   002A" 00 00       FCBS:   DEFS    2               ; Source FCB
  2086   002C" 00 00       FCBD:   DEFS    2               ; Destination FCB

  2088                     ; Counts and Flags

  2090   002E" 00          PAGLIM: DEFS    1               ; Max number of pages in work buffer
  2091   002F" 00          LSTCPY: DEFS    1               ; Last file was copied flag
  2092   0030" 00          VERCNT: DEFS    1               ; Error count
  2093   0031" 00          BCNT:   DEFS    1               ; Block count
  2094   0032" 00          CONT:   DEFS    1               ; Continue flag (0=no, 0FFH=yes)
  2095   0033" 00          NOMSGS: DEFS    1               ; 0FFH if there is no ZCPR3 message buffer
  2096   0034" 00          NORST:  DEFS    1               ; Disk reset flag (0=do reset)
  2097   0035" 00          ROFLG:  DEFS    1               ; Dest file R/O flag
  2098   0036" 00          RPQFLG: DEFS    1               ; Replace queery flag (0=replace w/o asking)
  2099   0037" 00          XMOVE:  DEFS    1               ; Delete source after copy flag (Move)
  2100   0038" 00          QUIET:  DEFS    1               ; Quiet
  2101   0039" 00          NOREPL: DEFS    1               ; No copy if file already on dest. flag
  2102   003A" 00          DSFLAG: DEFS    1               ; DateStamper active flag
  2103   003B" 00 00 00 00 TMPTIM: DEFS    6               ; Temporary Clock Date/Time buffer
  2104   0041" 00 00 00 00 SRCTD:  DEFS    15              ; Source Time & Date buffer
  2105   0050" 00 00 00 00 DESTTD: DEFS    15              ; Destination Time &Date Buffer
  2106   005F" 00          HAVFIL: DEFS    1               ; Flag to indicate filecount. 0=No Files
  2107   0060" 00          RENFLG: DEFS    1               ; 0 = No rename, <>0 for rename opn
  2108   0061" 00          REPLCK: DEFS    1               ; Flag for Replacement abort (MCOPYX sets)
  2109   0062" 00          CPYERR: DEFS    1               ; 0=No error in Verify, FF=Verify err

  2111                     ; Dynamic Buffers

  2113   0063" 00 00       INLINE:  DEFS   2               ; Input line buffer
  2114   0065" 00 00       FREEBUF: DEFS   2               ; Free space buffer
  2115   0067" 00 00       PUBS:    DEFS   2               ; ZRDOS PUBLIC bytes from ENV+0FEH
  2116   0069" 00 00 00 00          DEFS   64              ; Space for local Stack
  2117   00A9" 00 00       STACK:   DEFS   2               ; Opsys stack ptr

  2119                             END
